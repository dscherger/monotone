#!/usr/bin/perl -W
##!/usr/bin/perl -w
##############################################################################
#
#   File Name    - mtn-browse
#
#   Description  - Perl GUI utility for browsing a Monotone database without a
#                  workspace.
#
#   Author       - A.E.Cooper.
#
#   Legal Stuff  - Copyright (c) 2007 Anthony Edward Cooper
#                  <aecooper@coosoft.plus.com>.
#
#                  This program is free software; you can redistribute it
#                  and/or modify it under the terms of the GNU General Public
#                  License as published by the Free Software Foundation;
#                  either version 3 of the License, or (at your option) any
#                  later version.
#
#                  This program is distributed in the hope that it will be
#                  useful, but WITHOUT ANY WARRANTY; without even the implied
#                  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#                  PURPOSE. See the GNU General Public License for more
#                  details.
#
#                  You should have received a copy of the GNU General Public
#                  License along with this software; if not, write to the Free
#                  Software Foundation, Inc., 59 Temple Place - Suite 330,
#                  Boston, MA 02111-1307 USA.
#
##############################################################################
#
##############################################################################
#
#   GLOBAL DATA FOR THIS MODULE
#
##############################################################################



# ***** REQUIRED VERSION OF PERL *****

require 5.008;

# ***** REQUIRED PACKAGES *****

use lib "/home/aecoope/perl";

use strict;
use Glib qw(FALSE TRUE);
use Gnome2;
use Gnome2::VFS -init;
use Gtk2 -init;
set_locale Gtk2;
init Gtk2;
use Gtk2::GladeXML;
use Gtk2::Helper;
use Gtk2::Pango;
use Gtk2::SourceView;
use IPC::Open3;
use Monotone::AutomateStdio;
use POSIX qw(:errno_h :sys_wait_h);
use POSIX qw(strftime);

# Temporary debug stuff.

use Data::Dumper;

# ***** GLOBAL DATA DECLARATIONS *****

# Constants used to represent the different groups of widgets.

use constant BRANCH           => 0x01;
use constant DIRECTORY        => 0x02;
use constant DIRECTORY_VIEW   => 0x04;
use constant DISPLAY_OF_FILE  => 0x08;
use constant FILE             => 0x10;
use constant REVISION         => 0x20;
use constant REVISION_LIST    => 0x02;
use constant REVISION_DETAILS => 0x04;

# Constants used to represent the different state changes. Read this as
# `what has just been changed' => `what needs to be updated'.

use constant BRANCH_CHANGED            => (REVISION | DIRECTORY
					   | DIRECTORY_VIEW | FILE
					   | DISPLAY_OF_FILE);
use constant DATABASE_CHANGED          => 0xff;
use constant DIRECTORY_CHANGED         => (DIRECTORY_VIEW | FILE
					   | DISPLAY_OF_FILE);
use constant DISPLAY_OF_FILE_CHANGED   => 0x00;
use constant FILE_CHANGED              => (DISPLAY_OF_FILE);
use constant NEW_FIND                  => 0xff;
use constant REVISION_CHANGED          => (DIRECTORY | REVISION_LIST
					   | DIRECTORY_VIEW | FILE
					   | DISPLAY_OF_FILE);
use constant SELECTED_REVISION_CHANGED => (REVISION_DETAILS);

# Constants for the columns within the manifest ListStore widget.

use constant MLS_ICON_COLUMN           => 0;
use constant MLS_NAME_COLUMN           => 1;
use constant MLS_DATE_COLUMN           => 2;
use constant MLS_AUTHOR_COLUMN         => 3;
use constant MLS_MANIFEST_ENTRY_COLUMN => 4;

# Constants for the columns within the details ListStore widget.

use constant DLS_ICON_COLUMN  => 0;
use constant DLS_NAME_COLUMN  => 1;
use constant DLS_VALUE_COLUMN => 2;

# Text viewable application mime types.

my @text_viewable_app_mime_types =
    qw(postscript
       rtf
       x-awk
       x-cgi
       x-csh
       x-glade
       x-java
       x-javascript
       x-jbuilder-project
       x-perl
       x-php
       x-python
       x-shellscript
       x-troff-man
       x-troff
       xhtml+xml);

# Supported text mime types (used for syntax highlighting.

my @text_mime_types =
    (
     {
	 pattern => qr/.*\.c$/o,
	 type    => "text/x-csrc"
     },
     {
	 pattern => qr/.*\.(C)|(cc)|(cp)|(cpp)|(CPP)|(cxx)|(c\+\+)$/o,
	 type    => "text/x-c++src"
     },
     {
	 pattern => qr/.*\.(h)|(hh)|(H)$/o,
	 type    => "text/x-c++hdr"
     },
     {
	 pattern => qr/.*\.h$/o,
	 type    => "text/x-chdr"
     },
     {
	 pattern => qr/(^[Mm]akefile(\.[^.]+)?)|(.*\.mk)$/o,
	 type    => "text/x-makefile"
     },
     {
	 pattern => qr/.*/o,
	 type    => "text/plain"
     }
    );

# A boolean to signal whether this process has received a SIGCHLD signal or
# not.

# List of window instances.

my @windows;

# The advanced find window management record.

my $advanced_find;

# Assorted pixmaps.

my($app_icon,
   $line_image);

# The busy cursor to use for the mouse.

my $busy_cursor;

# The tooltips widget.

my $tooltips;

# ***** FUNCTIONAL PROTOTYPES FOR THIS FILE *****

# Private routines.

sub advanced_find($$$);
sub advanced_find_button_clicked_cb($$);
sub combo_changed_cb($$);
sub combo_key_release_event_cb($$$);
sub create_advanced_find_window();
sub create_format_tags($);
sub delete_event_cb($$$);
sub destroy_event_cb($$;$);
sub directory_up_button_clicked_cb($$);
sub file_change_log_button_clicked_cb($$);
sub file_history_button_clicked_cb($$);
sub generate_revision_report($$$$);
sub get_change_log_window();
sub get_completion($$$$;$);
sub get_dir_contents($$$);
sub get_file_history_helper($$$);
sub get_file_history_window();
sub get_revision_ids($$);
sub gtk2_update();
sub make_busy($$);
sub manifest_browser_treeview_cursor_changed_cb($$);
sub manifest_browser_treeview_row_activated_cb($$$$);
sub mtn_error_handler($$);
sub new_browser_instance();
sub populate_button_clicked_cb($$);
sub revisions_treeview_cursor_changed_cb($$);
sub revisions_treeview_row_activated_cb($$$$);
sub set_label_value($$);
sub setup_sigchld_handler($);
sub sigchld_handler();
sub simple_query_radiobutton_toggled_cb($$);
sub revision_change_log_button_clicked_cb($$);
sub term_combobox_changed_cb($$);
sub update_advanced_find_state($$);
sub update_browser_state($$);
#
##############################################################################
#
#   Routine      - Main Body Of Code
#
#   Description  - This is the main body of code for the mtn-browse script.
#
#   Data         - @_           : The command line arguments.
#                  Return Value : Unix exit code.
#
##############################################################################



{

    # Initialise the libraries and generate the interface.

    Gnome2::Program->init("mtn-browse", 0.1);
    Monotone::AutomateStdio->register_error_handler("both",
						    \&mtn_error_handler);
    setup_sigchld_handler(\&sigchld_handler);
    $tooltips = Gtk2::Tooltips->new();
    $app_icon = Gtk2::Gdk::Pixbuf->new_from_file("../mtn-browse.png");
    $line_image = Gtk2::Gdk::Pixbuf->new_from_file("../line.png");
    new_browser_instance();

    # Hand control over to Gtk2.

    Gtk2->main();

    # Cleanup.

    if (defined($advanced_find))
    {
	$advanced_find->{window}->destroy();
	$advanced_find = undef;
    }
    foreach my $window (@windows)
    {
	$window->{window}->destroy();
    }
    Gnome2::VFS->shutdown();
    $SIG{CHLD} = "IGNORE";
    @windows = ();

    exit(0);

}
#
##############################################################################
#
#   Routine      - combo_changed_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by selecting an entry from its pulldown
#                  list.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub combo_changed_cb($$)
{

    my($widget, $instance) = @_;

    my ($change_state,
	$combo_details,
	$item,
	$value);

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    if ($widget == $instance->{branch_combo})
    {
	$change_state = BRANCH_CHANGED;
	$combo_details = $instance->{branch_combo_details};
    }
    elsif ($widget == $instance->{revision_combo})
    {
	$change_state = REVISION_CHANGED;
	$combo_details = $instance->{revision_combo_details};
    }
    elsif ($widget == $instance->{directory_combo})
    {
	$change_state = DIRECTORY_CHANGED;
	$combo_details = $instance->{directory_combo_details};
    }
    else
    {
	return;
    }

    # For some reason best known to itself, Gtk+ calls this callback when the
    # user presses a key for the first time (but not subsequently) after a
    # value is selected via the pulldown menu. So we have to guard against
    # this. Under these circumstances the key release callback is also called.
    # So, put simply, only do something inside this callback if the value is a
    # direct match to one in our list.

    $value = $widget->child()->get_text();
    foreach $item (@{$combo_details->{list}})
    {
	if ($value eq $item)
	{
	    $combo_details->{value} = $value;
	    $combo_details->{completed} = 1;
	    $instance->{appbar}->clear_stack();
	    &{$instance->{update_handler}}($instance, $change_state);
	    last;
	}
    }

}
#
##############################################################################
#
#   Routine      - combo_key_release_event_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by entering a character (key release
#                  event).
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $instance    : The window instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub combo_key_release_event_cb($$$)
{

    my($widget, $event, $instance) = @_;

    my ($change_state,
	$combo,
	$combo_details,
	$completed,
	$completion,
	$item,
	$len,
	$name,
	$old_completed,
	$old_value,
	$value);

    return FALSE if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    if ($widget == $instance->{branch_combo}->child())
    {
	$combo = $instance->{branch_combo};
	$change_state = BRANCH_CHANGED;
	$combo_details = $instance->{branch_combo_details};
	$name = "branch";
    }
    elsif ($widget == $instance->{revision_combo}->child())
    {
	$combo = $instance->{revision_combo};
	$change_state = REVISION_CHANGED;
	$combo_details = $instance->{revision_combo_details};
	$name = "revision";
    }
    elsif ($widget == $instance->{directory_combo}->child())
    {
	$combo = $instance->{directory_combo};
	$change_state = DIRECTORY_CHANGED;
	$combo_details = $instance->{directory_combo_details};
	$name = "directory";
    }
    else
    {
	return FALSE;
    }

    # The user has typed something in then validate it and auto-complete it if
    # necessary.

    $completed = 0;
    $old_completed = $combo_details->{completed};
    $old_value = $combo_details->{value};
    $value = $widget->get_text();
    if ($value ne $old_value)
    {

	# Don't auto-complete if the user is simply deleting from the extreme
	# right.

	$len = length($value);
	if ($value ne substr($old_value, 0, $len))
	{

	    # So that the spacebar triggers auto-complete.

	    $value =~ s/\s+$//o;
	    $len = length($value);

	    if (get_completion($value,
			       $combo_details->{list},
			       \$completion,
			       \$completed,
			       $combo_details->{completion_cache}))
	    {
		$instance->{appbar}->clear_stack();
	    }
	    else
	    {
		$instance->{appbar}->
		    push("Invalid " . $name . " name`" . $value . "'");
	    }
	    $value = $completion;
	    $len = length($value);
	    $widget->set_text($value);
	    $widget->set_position(-1);

	}
	$combo_details->{value} = $value;
	$combo_details->{last_typed_len} = length($value);
	$combo_details->{completed} = $completed;

	# Update the pulldown choices.

	$combo->get_model()->clear();
	foreach $item (@{$combo_details->{list}})
	{
	    $combo->append_text($item) if ($value eq substr($item, 0, $len));
	    $combo_details->{completed} = 1
		if (! $completed && $value eq $item);
	}

	# Update the window state on a significant change.

	&{$instance->{update_handler}}($instance, $change_state)
	    if ($combo_details->{completed} != $old_completed
		|| $combo_details->{value} ne $old_value);

    }

    return FALSE;

}
#
##############################################################################
#
#   Routine      - tagged_checkbutton_toggled_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  the tagged_checkbutton.
#                  list.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub tagged_checkbutton_toggled_cb($$)
{

    my($widget, $instance) = @_;

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    $instance->{appbar}->clear_stack();
    &{$instance->{update_handler}}($instance, BRANCH_CHANGED);

}
#
##############################################################################
#
#   Routine      - advanced_find_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  advanced find button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub advanced_find_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    my(@branches,
       $preset_branch,
       $revision_id,
       $state);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    if (advanced_find($browser, \$revision_id, \@branches))
    {

	# Preset branch name. If we already have a selected branch then try and
	# match branch names, if that fails then just pick the first name.

	$preset_branch = 1;
	$state = BRANCH_CHANGED;
	if ($browser->{branch_combo_details}->{completed})
	{
	    foreach my $name (@branches)
	    {
		if ($name eq $browser->{branch_combo_details}->{value})
		{
		    $preset_branch = 0;
		    last;
		}
	    }
	}
	if ($preset_branch)
	{
	    $browser->{branch_combo_details}->{preset} = 1;
	    $browser->{branch_combo_details}->{completed} = 1;
	    $browser->{branch_combo_details}->{value} = $branches[0];
	    $state = DATABASE_CHANGED;
	}

	# Preset revision id.

	$browser->{revision_combo_details}->{preset} = 1;
	$browser->{revision_combo_details}->{completed} = 1;
	$browser->{revision_combo_details}->{value} = $revision_id;

	# A revision id is what is returned so switch off the listing of tag
	# names.

	$browser->{tagged_tick}->set_active(FALSE);

	&{$browser->{update_handler}}($browser, $state);

    }

}
#
##############################################################################
#
#   Routine      - revision_change_log_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  revision change log button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub revision_change_log_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    my (@certs_list,
	$instance,
	@revision_details,
	@revision_ids);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    $instance = get_change_log_window();

    # Get the currently selected revision id.

    get_revision_ids($browser, \@revision_ids);

    # Put the details into the text view and display it.

    $instance->{changelog_buffer}->set_text("");
    $instance->{window}->set_title
	("Revision " . $browser->{revision_combo_details}->{value});
    $browser->{mtn}->certs(\@certs_list, $revision_ids[0]);
    $browser->{mtn}->get_revision(\@revision_details, $revision_ids[0]);
    generate_revision_report($instance->{changelog_buffer},
			     $revision_ids[0],
			     \@certs_list,
			     \@revision_details);
    if ($instance->{changelog_scrolledwindow}->realized())
    {
	$instance->{changelog_scrolledwindow}->get_vadjustment()->set_value(0);
	$instance->{changelog_scrolledwindow}->get_hadjustment()->set_value(0);
    }
    $instance->{window}->show_all();

}
#
##############################################################################
#
#   Routine      - directory_up_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the up
#                  directory button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub directory_up_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    my($len,
       $value);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Simply go up one directory level in the manifest if we aren't already at
    # the top.

    $value = $browser->{directory_combo_details}->{value};
    if ($value ne "")
    {
	if ($value =~ m/^.+\/.+/o)
	{
	    if ($value =~ m/^(.+)\/[^\/]+$/o)
	    {
		($value) = ($value =~ m/^(.+)\/[^\/]+$/o);
	    }
	    else
	    {
		($value) = ($value =~ m/^(.+)\/$/o)
	    }
	}
	else
	{
	    $value = "";
	}
	$browser->{directory_combo_details}->{value} = $value;
	$browser->{directory_combo_details}->{completed} = 1;
	$len = length($value);
	if ($len < $browser->{directory_combo_details}->{last_typed_len})
	{
	    $browser->{directory_combo}->get_model()->clear();
	    foreach my $item (@{$browser->{directory_combo_details}->{list}})
	    {
		$browser->{directory_combo}->append_text($item)
		    if ($value eq substr($item, 0, $len));
	    }
	    $browser->{directory_combo_details}->{last_typed_len} = $len;
	}
	$browser->{directory_combo}->child()->set_text($value);
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - file_change_log_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the file
#                  change log button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub file_change_log_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    my ($button,
	@certs_list,
	$counter,
	$file_name,
	%history_hash,
	$instance,
	@revision_ids);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    $instance = get_file_history_window();
    local $instance->{in_cb} = 1;

    $instance->{mtn} = $browser->{mtn};
    $instance->{file_name} =
	$browser->{file_being_viewed}->{manifest_entry}->{name};
    $instance->{first_revision_id} = "";
    $instance->{second_revision_id} = "";
    $instance->{window}->set_title
	("File History For " . $instance->{file_name});
    $instance->{window}->show_all();

    make_busy($instance, 1);
    $instance->{appbar}->push("");
    gtk2_update();

    # Get the list of file change revisions. Remember that a warning is
    # generated when one goes back beyond a file's addition revision, so
    # temporarily disable the warning handler.

    $instance->{appbar}->set_progress_percentage(0);
    $instance->{appbar}->set_status("Fetching revision list");
    $instance->{stop_button}->set_sensitive(TRUE);
    gtk2_update();
    Monotone::AutomateStdio->register_error_handler("warning", undef);
    get_revision_ids($browser, \@revision_ids);
    get_file_history_helper($instance, \%history_hash, $revision_ids[0]);
    Monotone::AutomateStdio->register_error_handler
	("both", \&mtn_error_handler);
    $instance->{stop_button}->set_sensitive(FALSE);

    # Sort the list.

    $instance->{appbar}->set_status("Sorting revision list");
    gtk2_update();
    $instance->{history} = [];
    $instance->{mtn}->toposort($instance->{history}, keys(%history_hash));
    %history_hash = ();
    @{$instance->{history}} = reverse(@{$instance->{history}});

    # Display the file's history.

    $instance->{appbar}->set_progress_percentage(0);
    $instance->{appbar}->set_status("Displaying file history");
    gtk2_update();
    $counter = 1;
    $instance->{history_buffer}->set_text("");
    for my $revision_id (@{$instance->{history}})
    {

	# Print out the revision summary.

	$instance->{mtn}->certs(\@certs_list, $revision_id);
	generate_revision_report($instance->{history_buffer},
				 $revision_id,
				 \@certs_list,
				 undef);
	$instance->{history_buffer}->
	    insert($instance->{history_buffer}->get_end_iter(), "\n\n ");

	# Add the buttons.

	$button = Gtk2::Button->new("Select As File 1");
	$button->signal_connect("clicked",
				\&file_history_button_clicked_cb,
				{instance    => $instance,
				 revision_id => $revision_id,
				 button_type => "file-1"});
	$tooltips->set_tip($button,
			   "Select this file revision for\n"
			       . "comparison as the first file");
	$instance->{history_textview}->add_child_at_anchor
	    ($button,
	     $instance->{history_buffer}->
	         create_child_anchor($instance->{history_buffer}->
				     get_end_iter()));
	$button->show_all();
	$instance->{history_buffer}->
	    insert($instance->{history_buffer}->get_end_iter(), " ");

	$button = Gtk2::Button->new("Select As File 2");
	$button->signal_connect("clicked",
				\&file_history_button_clicked_cb,
				{instance    => $instance,
				 revision_id => $revision_id,
				 button_type => "file-2"});
	$tooltips->set_tip($button,
			   "Select this file revision for\n"
			       . "comparison as the second file");
	$instance->{history_textview}->add_child_at_anchor
	    ($button,
	     $instance->{history_buffer}->
	         create_child_anchor($instance->{history_buffer}->
				     get_end_iter()));
	$button->show_all();
	$instance->{history_buffer}->
	    insert($instance->{history_buffer}->get_end_iter(), " ");

	$button = Gtk2::Button->new("Full Revision Information");
	$button->signal_connect("clicked",
				\&file_history_button_clicked_cb,
				{instance    => $instance,
				 revision_id => $revision_id,
				 button_type => "revision-info"});
	$tooltips->set_tip($button, "View the revision's change log");
	$instance->{history_textview}->add_child_at_anchor
	    ($button,
	     $instance->{history_buffer}->
	         create_child_anchor($instance->{history_buffer}->
				     get_end_iter()));
	$button->show_all();

	# If we aren't at the end, print out the revision separator.

	if ($counter < scalar(@{$instance->{history}}))
	{
	    $instance->{history_buffer}->
		insert($instance->{history_buffer}->get_end_iter(), "\n");
	    $instance->{history_buffer}->
		insert_pixbuf($instance->{history_buffer}->get_end_iter(),
			      $line_image);
	    $instance->{history_buffer}->
		insert($instance->{history_buffer}->get_end_iter(), "\n");
	}

	$instance->{appbar}->set_progress_percentage
	    ($counter ++ / scalar(@{$instance->{history}}));
	gtk2_update();

    }

    # Make sure we are at the top.

    $instance->{history_scrolledwindow}->get_vadjustment()->set_value(0);
    $instance->{history_scrolledwindow}->get_hadjustment()->set_value(0);
    $instance->{appbar}->set_progress_percentage(0);
    $instance->{appbar}->set_status("");
    gtk2_update();

    $instance->{appbar}->pop();
    make_busy($instance, 0);

}
#
##############################################################################
#
#   Routine      - file_history_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on any of the
#                  buttons displayed in a file's history list.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $details : A reference to an anonymous hash containing the
#                             window instance, revision and action that is
#                             associated with this widget.
#
##############################################################################



sub file_history_button_clicked_cb($$)
{

    my($widget, $details) = @_;

    my($cl_instance,
       $instance,
       $revision_id);

    $instance = $details->{instance};
    $revision_id = $details->{revision_id};

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    if ($details->{button_type} eq "file-1"
	|| $details->{button_type} eq "file-2")
    {
	if ($details->{button_type} eq "file-1")
	{
	    $instance->{first_revision_id} = $revision_id;
	    set_label_value($instance->{revision_id_1_label}, $revision_id);
	    if ($instance->{first_revision_id}
		eq $instance->{second_revision_id})
	    {
		$instance->{second_revision_id} = "";
		set_label_value($instance->{revision_id_2_label}, "");
	    }
	}
	else
	{
	    $instance->{second_revision_id} = $revision_id;
	    set_label_value($instance->{revision_id_2_label}, $revision_id);
	    if ($instance->{second_revision_id}
		eq $instance->{first_revision_id})
	    {
		$instance->{first_revision_id} = "";
		set_label_value($instance->{revision_id_1_label}, "");
	    }
	}
	if ($instance->{first_revision_id} ne ""
	    && $instance->{second_revision_id} ne "")
	{
	    $instance->{compare_button}->set_sensitive(TRUE);
	}
	else
	{
	    $instance->{compare_button}->set_sensitive(FALSE);
	}
    }
    else
    {

	my(@certs_list,
	   @revision_details);

	# Display the full revision change log.

	$cl_instance = get_change_log_window();
	$cl_instance->{changelog_buffer}->set_text("");
	$cl_instance->{window}->set_title("Revision " . $revision_id);
	$instance->{mtn}->certs(\@certs_list, $revision_id);
	$instance->{mtn}->get_revision(\@revision_details, $revision_id);
	generate_revision_report($cl_instance->{changelog_buffer},
				 $revision_id,
				 \@certs_list,
				 \@revision_details);
	if ($cl_instance->{changelog_scrolledwindow}->realized())
	{
	    $cl_instance->{changelog_scrolledwindow}->get_vadjustment()->
		set_value(0);
	    $cl_instance->{changelog_scrolledwindow}->get_hadjustment()->
		set_value(0);
	}
	$cl_instance->{window}->show_all();

    }

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user selects an entry in
#                  the manifest treeview.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub manifest_browser_treeview_cursor_changed_cb($$)
{

    my($widget, $browser) = @_;

    my($manifest_entry,
       $short_name);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Get the manifest entry details for the item that was selected.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a file then display its contents, otherwise if it is a
    # directory then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "file")
    {
	$browser->{file_being_viewed} = {short_name     => $short_name,
					 manifest_entry => $manifest_entry};
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, FILE_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user double clicks on an
#                  entry in the manifest treeview.
#
#   Data         - $widget           : The widget object that received the
#                                      signal.
#                  $tree_path        : A Gtk2::TreePath object for the
#                                      selected item.
#                  $tree_view_column : A Gtk2::TreeViewColumn object for the
#                                      selected item.
#                  $browser          : The browser instance that is associated
#                                      with this widget.
#
##############################################################################



sub manifest_browser_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $browser) = @_;

    my($manifest_entry,
       $short_name);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Get the manifest entry details for the item that was double-clicked.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a directory then change to it, otherwise if it is a file
    # then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "directory")
    {
	$browser->{directory_combo_details}->{value} = $manifest_entry->{name};
	$browser->{directory_combo_details}->{completed} = 1;
	$browser->{directory_combo}->child()->
	    set_text($manifest_entry->{name});
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - simple_query_radiobutton_toggled_cb
#
#   Description  - Callback routine called when the user changes the advanced
#                  find mode radio button.
#
#   Data         - $widget        : The widget object that received the
#                                   signal.
#                  $advanced_find : The advanced find dialog window instance
#                                   that is associated with this widget.
#
##############################################################################



sub simple_query_radiobutton_toggled_cb($$)
{

    my($widget, $advanced_find) = @_;

    my($len,
       $value);

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Simply enable the relevant find widgets depending upon whether simple or
    # advanced mode is selected.

    if ($advanced_find->{simple_query_radiobutton}->get_active())
    {
	$advanced_find->{simple_frame}->set_sensitive(TRUE);
	$advanced_find->{advanced_frame}->set_sensitive(FALSE);
    }
    else
    {
	$advanced_find->{simple_frame}->set_sensitive(FALSE);
	$advanced_find->{advanced_frame}->set_sensitive(TRUE);
    }

}
#
##############################################################################
#
#   Routine      - execute_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  advanced find execute query button.
#
#   Data         - $widget        : The widget object that received the
#                                   signal.
#                  $advanced_find : The advanced find dialog window instance
#                                   that is associated with this widget.
#
##############################################################################



sub execute_button_clicked_cb($$)
{

    my($widget, $advanced_find) = @_;

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Simply let the update handler deal with it.

    &{$advanced_find->{update_handler}}($advanced_find, REVISION_CHANGED);

}
#
##############################################################################
#
#   Routine      - populate_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  advanced find populate selector button.
#
#   Data         - $widget        : The widget object that received the
#                                   signal.
#                  $advanced_find : The advanced find dialog window instance
#                                   that is associated with this widget.
#
##############################################################################



sub populate_button_clicked_cb($$)
{

    my($widget, $advanced_find) = @_;

    my($arg,
       $pos,
       $selector,
       $time_val,
       $to_insert);

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Simply get the currently selected selector and then insert it into the
    # user's query string.

    $selector = $advanced_find->{term_combo}->get_model()->get
	($advanced_find->{term_combo}->get_active_iter(), 0);
    $arg = $advanced_find->{argument_entry}->get_text();
    $time_val = strftime("%Y-%m-%dT%H:%M:%S",
			 localtime($advanced_find->{date_dateedit}->
				   get_time()));
    $to_insert = "";
    if ($selector eq "Author")
    {
	$to_insert = "a:" . (($arg eq "") ? "<Author>" : $arg);
    }
    elsif ($selector eq "Branch")
    {
	$to_insert = "b:" . (($arg eq "") ? "<Branch>" : $arg);
    }
    elsif ($selector eq "Cert")
    {
	$to_insert = "c:" . (($arg eq "") ? "<Cert Expression>" : $arg);
    }
    elsif ($selector eq "Date (=)")
    {
	$to_insert = "d:" . $time_val;
    }
    elsif ($selector eq "Date (<=)")
    {
	$to_insert = "e:" . $time_val;
    }
    elsif ($selector eq "Date (>)")
    {
	$to_insert = "l:" . $time_val;
    }
    elsif ($selector eq "Head Revision")
    {
	$to_insert = "h:";
    }
    elsif ($selector eq "Identifier")
    {
	$to_insert = "i:" . (($arg eq "") ? "<Revision Id>" : $arg);
    }
    elsif ($selector eq "Parent")
    {
	$to_insert = "p:" . (($arg eq "") ? "<Revision Id>" : $arg);
    }
    elsif ($selector eq "Separator")
    {
	$to_insert = "/";
    }
    elsif ($selector eq "Tag")
    {
	$to_insert = "t:" . (($arg eq "") ? "<Tag Name>" : $arg);
    }

    $pos = $advanced_find->{search_term_combo}->child()->get_position();
    $advanced_find->{search_term_combo}->child()->insert_text
	($to_insert, $pos);
    $advanced_find->{search_term_combo}->child()->set_position
	($pos + length($to_insert));

}
#
##############################################################################
#
#   Routine      - term_combobox_changed_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  the term ComboBox by selecting an entry from its pulldown
#                  list.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub term_combobox_changed_cb($$)
{

    my($widget, $advanced_find) = @_;

    my($arg,
       $pos,
       $selector,
       $time_val,
       $to_insert);

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Simply get the currently selected term and then enable/disable the text
    # entry and date entry widgets accordingly.

    $selector = $advanced_find->{term_combo}->get_model()->get
	($advanced_find->{term_combo}->get_active_iter(), 0);

    if ($selector =~ m/^Date .*$/o)
    {
	$advanced_find->{argument_entry}->set_sensitive(FALSE);
	$advanced_find->{date_dateedit}->set_sensitive(TRUE);
    }
    elsif ($selector eq "Head" || $selector eq "Separator")
    {
	$advanced_find->{argument_entry}->set_sensitive(FALSE);
	$advanced_find->{date_dateedit}->set_sensitive(FALSE);
    }
    else
    {
	$advanced_find->{argument_entry}->set_sensitive(TRUE);
	$advanced_find->{date_dateedit}->set_sensitive(FALSE);
    }

}
#
##############################################################################
#
#   Routine      - revisions_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user selects an entry in
#                  the advanced find's revisions treeview.
#
#   Data         - $widget        : The widget object that received the
#                                   signal.
#                  $advanced_find : The advanced find dialog window instance
#                                   that is associated with this widget.
#
##############################################################################



sub revisions_treeview_cursor_changed_cb($$)
{

    my($widget, $advanced_find) = @_;

    my $revision_id;

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Get the selected revision id.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $revision_id = $model->get($iter, 0); });

    if (defined($revision_id)
	&& $revision_id
	    ne $advanced_find->{revisions_treeview_details}->{value})
    {
	$advanced_find->{revisions_treeview_details}->{value} = $revision_id;
	$advanced_find->{appbar}->clear_stack();
	&{$advanced_find->{update_handler}}($advanced_find,
					    SELECTED_REVISION_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - revisions_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user double clicks on an
#                  entry in the advanced find's revisions treeview.
#
#   Data         - $widget           : The widget object that received the
#                                      signal.
#                  $tree_path        : A Gtk2::TreePath object for the
#                                      selected item.
#                  $tree_view_column : A Gtk2::TreeViewColumn object for the
#                                      selected item.
#                  $advanced_find    : The advanced find dialog window
#                                      instance that is associated with this
#                                      widget.
#
##############################################################################



sub revisions_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $advanced_find) = @_;

    my $revision_id;

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Get the selected revision id.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $revision_id = $model->get($iter, 0); });

    if (defined($revision_id))
    {
	$advanced_find->{revisions_treeview_details}->{value} = $revision_id;
	$advanced_find->{appbar}->clear_stack();
	$advanced_find->{selected} = 1;
	$advanced_find->{done} = 1;
    }

}
#
##############################################################################
#
#   Routine      - delete_event_cb
#
#   Description  - Callback routine called when the used has attempted to
#                  close the main window.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub delete_event_cb($$$)
{

    my($widget, $event, $browser) = @_;

    if ($browser->{in_cb})
    {
	return TRUE;
    }
    else
    {
	return FALSE;
    }

}
#
##############################################################################
#
#   Routine      - destroy_event_cb
#
#   Description  - Callback routine called when the main window is about to be
#                  destroyed.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $client_data : The client data associated with this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub destroy_event_cb($$;$)
{

    my($widget, $event, $client_data) = @_;

    my $browser = defined($client_data) ? $client_data : $event;

    Gtk2->main_quit();

    return FALSE;

}
#
##############################################################################
#
#   Routine      - new_browser_instance
#
#   Description  - Construct a new browser instance record. This creates a new
#                  main window, a new connection to Monotone and initialising
#                  sensible defaults.
#
#   Data         - Return Value : A reference to the newly created browser
#                                 instance record.
#
##############################################################################



sub new_browser_instance()
{

    my($browser,
       $font,
       $image,
       $renderer,
       $tv_column,
       $div);

    $browser = {};
    $browser->{type} = "browser_window";
    $browser->{mtn} = Monotone::AutomateStdio->new();
    $browser->{glade} =
	Gtk2::GladeXML->new("../mtn-browse.glade", "main_window");

    # Flag to stop recursive calling of callbacks.

    $browser->{in_cb} = 0;

    # Connect Glade registered signal handlers.

    $browser->{glade}->signal_autoconnect
	(sub {
	     my($callback_name, $widget, $signal_name, $signal_data,
		$connect_object, $after, $user_data) = @_;
	     my $func = $after ? "signal_connect_after" : "signal_connect";
	     $widget->$func($signal_name,
			    $callback_name,
			    $connect_object ? $connect_object : $user_data); },
	 $browser);

    # Link in the update handler for the browser.

    $browser->{update_handler} = \&update_browser_state;

    # Get the widgets that we are interested in.

    $browser->{window} = $browser->{glade}->get_widget("main_window");
    $browser->{window}->set_icon($app_icon);
    $browser->{appbar} = $browser->{glade}->get_widget("appbar");
    $browser->{branch_combo} =
	$browser->{glade}->get_widget("branch_comboboxentry");
    $browser->{revision_combo} =
	$browser->{glade}->get_widget("revision_comboboxentry");
    $browser->{tagged_tick} =
	$browser->{glade}->get_widget("tagged_checkbutton");
    $browser->{directory_combo} =
	$browser->{glade}->get_widget("directory_comboboxentry");
    $browser->{directory_up_button} =
	$browser->{glade}->get_widget("directory_up_button");
    $browser->{manifest_treeview} =
	$browser->{glade}->get_widget("manifest_browser_treeview");
    $browser->{file_view_scrolledwindow} =
	$browser->{glade}->get_widget("file_view_scrolledwindow");
    $browser->{file_name_label} =
	$browser->{glade}->get_widget("file_name_value_label");
    $browser->{file_id_label} =
	$browser->{glade}->get_widget("file_id_value_label");
    $browser->{last_update_label} =
	$browser->{glade}->get_widget("last_update_value_label");
    $browser->{file_revision_id_label} =
	$browser->{glade}->get_widget("file_revision_id_value_label");
    $browser->{file_button_vbox} =
	$browser->{glade}->get_widget("file_button_vbox");
    $browser->{database_name_label} =
	$browser->{glade}->get_widget("database_name_value_label");
    $browser->{revision_id_label} =
	$browser->{glade}->get_widget("revision_id_value_label");
    $browser->{author_label} =
	$browser->{glade}->get_widget("author_value_label");
    $browser->{change_log_label} =
	$browser->{glade}->get_widget("change_log_value_label");

    # Setup button sensitivity groups.

    $browser->{text_file_sensitive_group} = ();
    foreach my $item ("search_text", "annotate")
    {
	push(@{$browser->{text_file_sensitive_group}}, 
	     $browser->{glade}->get_widget($item . "_button"));
    }
    $browser->{revision_sensitive_group} = ();
    foreach my $item ("revision_change_log", "revision_compare")
    {
	push(@{$browser->{revision_sensitive_group}}, 
	     $browser->{glade}->get_widget($item . "_button"));
    }

    # Setup the comboboxentry key release signal handlers.

    $browser->{branch_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{directory_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{revision_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);

    # Move the pane separator to a sensible position.

    # $div = $browser->{glade}->get_widget("browser_hpaned");
    # $div->set_position(300);

    # Setup the comboboxes.

    $browser->{branch_combo}->set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{branch_combo}->set_text_column(0);
    $browser->{branch_combo}->set_wrap_width(2);
    $browser->{directory_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{directory_combo}->set_text_column(0);
    $browser->{directory_combo}->set_wrap_width(2);
    $browser->{revision_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{revision_combo}->set_text_column(0);
    $browser->{revision_combo}->set_wrap_width(2);

    # Setup the tree view manifest file browser.

    $browser->{manifest_liststore} = Gtk2::ListStore->new("Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::Scalar");
    $browser->{manifest_treeview}->set_model($browser->{manifest_liststore});

    $tv_column = Gtk2::TreeViewColumn->new();
    $image = Gtk2::Image->new_from_stock("gtk-file", "menu");
    $image->show_all();
    $tv_column->set_widget($image);
    $tv_column->set_resizable(FALSE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(25);
    $tv_column->set_sort_column_id(MLS_ICON_COLUMN);
    $renderer = Gtk2::CellRendererPixbuf->new();
    $tv_column->pack_start($renderer, TRUE);
    $tv_column->set_attributes($renderer, "stock-id" => MLS_ICON_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("File Name");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(180);
    $tv_column->set_sort_column_id(MLS_NAME_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_NAME_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Last Update");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(MLS_DATE_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_DATE_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Author");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(MLS_AUTHOR_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_AUTHOR_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $browser->{manifest_treeview}->set_search_column(MLS_NAME_COLUMN);

    # $tv_column = $browser->{manifest_treeview}->get_column(MLS_DATE_COLUMN);
    # $browser->{manifest_treeview}->remove_column($tv_column);

    # Setup the file file viewer (with syntax highlighting).

    $browser->{file_view_svbuffer} = Gtk2::SourceView::Buffer->new(undef);
    $browser->{file_view_svbuffer}->set_max_undo_levels(0);
    $browser->{file_view_svbuffer}->begin_not_undoable_action();
    $browser->{file_view_svlangmgr} =
	Gtk2::SourceView::LanguagesManager->new();
    $browser->{file_view_sv} = Gtk2::SourceView::View->
	new_with_buffer($browser->{file_view_svbuffer});
    $font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $browser->{file_view_sv}->modify_font($font) if (defined($font));
    $browser->{file_view_sv}->set_cursor_visible(FALSE);
    $browser->{file_view_sv}->set_editable(FALSE);
    $browser->{glade}->get_widget("file_view_scrolledwindow")->
	add($browser->{file_view_sv});
    $browser->{file_view_sv}->show_all();

    $browser->{window}->show_all();

    # Update the browser's internal state.

    $browser->{branch_combo_details}->{preset} = 0;
    $browser->{revision_combo_details}->{preset} = 0;
    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);

    push(@windows, $browser);

    return $browser;

}
#
##############################################################################
#
#   Routine      - advanced_find
#
#   Description  - Displays the advanced find dialog window and then gets the
#                  user to select the revision they want.
#
#   Data         - $browser     : The browser instance that started the
#                                 advanced find.
#                  $revision_id : A reference to a variable that is to contain
#                                 the selected revision id.
#                  $branches    : A reference to a list that is to contain the
#                                 list of branches that the selected revision
#                                 is on.
#                  Return Value : True if a revision has been selected,
#                                 otherwise false.
#
##############################################################################



sub advanced_find($$$)
{

    my($browser, $revision_id, $branches) = @_;

    my($height,
       $width);

    $advanced_find = create_advanced_find_window()
	unless (defined($advanced_find));

    $advanced_find->{mtn} = $browser->{mtn};

    # Update the window's internal state.

    {
	local $advanced_find->{in_cb} = 1;
	$advanced_find->{selected} = 0;

	# Reset the window contents, then show it.

	$advanced_find->{window}->set_transient_for($browser->{window});
	$advanced_find->{branch_combo_details}->{preset} = 0;
	$advanced_find->{revision_combo_details}->{preset} = 0;
	$advanced_find->{appbar}->clear_stack();
	&{$advanced_find->{update_handler}}($advanced_find, NEW_FIND);
	($width, $height) = $advanced_find->{window}->get_default_size();
	$advanced_find->{window}->resize($width, $height);
	$advanced_find->{window}->show_all();

	# Now actually update it with any preset values.

	$advanced_find->{branch_combo_details}->{preset} = 1;
	$advanced_find->{branch_combo_details}->{completed} =
	    $browser->{branch_combo_details}->{completed};
	$advanced_find->{branch_combo_details}->{value} =
	    $browser->{branch_combo_details}->{value};

	$advanced_find->{revision_combo_details}->{preset} = 1;
	$advanced_find->{revision_combo_details}->{completed} =
	    $browser->{revision_combo_details}->{completed};
	$advanced_find->{revision_combo_details}->{value} =
	    $browser->{revision_combo_details}->{value};

	$advanced_find->{tagged_tick}->
	    set_active($browser->{tagged_tick}->get_active());

	&{$advanced_find->{update_handler}}($advanced_find, NEW_FIND);
    }

    # Handle all events until the dialog is dismissed.

    $advanced_find->{done} = 0;
    while (! $advanced_find->{done})
    {
	Gtk2->main_iteration();
    }
    $advanced_find->{window}->hide();

    # Deal with the result.

    @$branches = ();
    $$revision_id = "";
    if ($advanced_find->{selected})
    {
	my($branch_list,
	   @certs_list,
	   $found);

	$$revision_id = $advanced_find->{revisions_treeview_details}->{value};

	# Build up a list of branches that the selected revision is on, putting
	# the branch named in the branch combo box at the head if it is still
	# applicable.

	$advanced_find->{mtn}->certs(\@certs_list, $$revision_id);
	$found = 0;
	foreach my $cert (@certs_list)
	{
	    if ($cert->{name} eq "branch")
	    {
		if ($cert->{value}
		    ne $advanced_find->{branch_combo_details}->{value})
		{
		    push(@$branches, $cert->{value});
		}
		else
		{
		    $found = 1;
		}
	    }
	}
	unshift(@$branches, $advanced_find->{branch_combo_details}->{value})
	    if ($found);
	push(@$branches, "") if (scalar(@$branches) == 0);

	return 1;
    }
    else
    {
	return;
    }

}
#
##############################################################################
#
#   Routine      - create_advanced_find_window
#
#   Description  - Creates the advanced find dialog window.
#
#   Data         - Return Value : A reference to the newly created advanced
#                                 find instance record.
#
##############################################################################



sub create_advanced_find_window()
{

    my(@branch_list,
       $font,
       $instance,
       $renderer,
       $tv_column);

    $instance = {};
    $instance->{glade} =
	Gtk2::GladeXML->new("../mtn-browse.glade", "advanced_find_window");

    # Flag to stop recursive calling of callbacks.

    $instance->{in_cb} = 0;

    # Connect Glade registered signal handlers.

    $instance->{glade}->signal_autoconnect
	(sub {
	     my($callback_name, $widget, $signal_name, $signal_data,
		$connect_object, $after, $user_data) = @_;
	     my $func = $after ? "signal_connect_after" : "signal_connect";
	     $widget->$func($signal_name,
			    $callback_name,
			    $connect_object ? $connect_object : $user_data); },
	 $instance);

    # Link in the update handler for the advanced find window.

    $instance->{update_handler} = \&update_advanced_find_state;

    # Get the widgets that we are interested in.

    $instance->{window} =
	$instance->{glade}->get_widget("advanced_find_window");
    $instance->{window}->set_icon($app_icon);
    $instance->{appbar} = $instance->{glade}->get_widget("appbar");
    $instance->{simple_query_radiobutton} =
	$instance->{glade}->get_widget("simple_query_radiobutton");
    $instance->{simple_frame} = $instance->{glade}->get_widget("simple_frame");
    $instance->{advanced_frame} =
	$instance->{glade}->get_widget("advanced_frame");
    $instance->{branch_combo} =
	$instance->{glade}->get_widget("branch_comboboxentry");
    $instance->{revision_combo} =
	$instance->{glade}->get_widget("revision_comboboxentry");
    $instance->{tagged_tick} =
	$instance->{glade}->get_widget("tagged_checkbutton");
    $instance->{search_term_combo} =
	$instance->{glade}->get_widget("search_term_comboboxentry");
    $instance->{term_combo} = $instance->{glade}->get_widget("term_combobox");
    $instance->{argument_entry} =
	$instance->{glade}->get_widget("argument_entry");
    $instance->{date_dateedit} =
	$instance->{glade}->get_widget("date_dateedit");
    $instance->{revisions_treeview} =
	$instance->{glade}->get_widget("revisions_treeview");
    $instance->{details_textview} =
	$instance->{glade}->get_widget("details_textview");
    $instance->{details_scrolledwindow} =
	$instance->{glade}->get_widget("details_scrolledwindow");
    $instance->{selected_branch_label} =
	$instance->{glade}->get_widget("selected_branch_value_label");
    $instance->{selected_revision_label} =
	$instance->{glade}->get_widget("selected_revision_value_label");
    $instance->{ok_button} = $instance->{glade}->get_widget("ok_button");

    # Setup the advanced find window deletion handlers.

    $instance->{window}->signal_connect
	("delete_event",
	 sub { $_[2]->{done} = 1 unless ($_[2]->{in_cb}); return TRUE; },
         $instance);
    $instance->{glade}->get_widget("cancel_button")->signal_connect
	("clicked", sub { $_[1]->{done} = 1; }, $instance);
    $instance->{glade}->get_widget("ok_button")->signal_connect
	("clicked", sub { $_[1]->{done} = $_[1]->{selected} = 1; }, $instance);

    # Setup the comboboxentry key release signal handlers.

    $instance->{branch_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $instance);
    $instance->{revision_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $instance);

    # Setup the comboboxes.

    $instance->{branch_combo}->set_model(Gtk2::ListStore->new("Glib::String"));
    $instance->{branch_combo}->set_text_column(0);
    $instance->{branch_combo}->set_wrap_width(2);
    $instance->{revision_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $instance->{revision_combo}->set_text_column(0);
    $instance->{revision_combo}->set_wrap_width(2);
    $instance->{search_term_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $instance->{search_term_combo}->set_text_column(0);
    $instance->{query_history} = [];
    $instance->{term_combo}->set_active(0);

    # Setup the revisions list browser.

    $instance->{revisions_liststore} = Gtk2::ListStore->new("Glib::String");
    $instance->{revisions_treeview}->
	set_model($instance->{revisions_liststore});
    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Matching Revision Ids");
    $tv_column->set_sort_column_id(0);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => 0);
    $instance->{revisions_treeview}->append_column($tv_column);
    $instance->{revisions_treeview}->set_search_column(0);

    # Setup the revision details viewer.

    $instance->{details_buffer} = $instance->{details_textview}->get_buffer();
    create_format_tags($instance->{details_textview}->get_buffer());
    $font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $instance->{details_textview}->modify_font($font) if (defined($font));

    return $instance;

}
#
##############################################################################
#
#   Routine      - get_change_log_window
#
#   Description  - Creates or prepares an existing a change log window for
#                  use.
#
#   Data         - Return Value : A reference to the newly created or unused
#                                 change log instance record.
#
##############################################################################



sub get_change_log_window()
{

    my ($font,
	$height,
	$instance,
	$width);

    foreach my $window (@windows)
    {
	if ($window->{type} eq "change_log_window"
	    && ! $window->{window}->mapped())
	{
	    $instance = $window;
	    last;
	}
    }

    # Create a new change log window if an unused one wasn't found, otherwise
    # reuse an existing unused one.

    if (! defined($instance))
    {
	$instance = {};
	$instance->{type} = "change_log_window";
	$instance->{glade} =
	    Gtk2::GladeXML->new("../mtn-browse.glade", "changelog_window");

	# Flag to stop recursive calling of callbacks.

	$instance->{in_cb} = 0;

	# Connect Glade registered signal handlers.

	$instance->{glade}->signal_autoconnect
	    (sub {
		 my($callback_name, $widget, $signal_name, $signal_data,
		    $connect_object, $after, $user_data) = @_;
		 my $func = $after ? "signal_connect_after" : "signal_connect";
		 $widget->$func($signal_name,
				$callback_name,
				$connect_object ?
				    $connect_object : $user_data); },
	     $instance);

	# Get the widgets that we are interested in.

	$instance->{window} =
	    $instance->{glade}->get_widget("changelog_window");
	$instance->{window}->set_icon($app_icon);
	$instance->{changelog_textview} =
	    $instance->{glade}->get_widget("changelog_textview");
	$instance->{changelog_scrolledwindow} =
	    $instance->{glade}->get_widget("changelog_scrolledwindow");

	# Setup the changelog window deletion handler.

	$instance->{window}->signal_connect
	    ("delete_event",
	     sub { $_[0]->hide() unless ($_[2]->{in_cb}); return TRUE; },
	     $instance);

	# Setup the revision changelog viewer.

	$instance->{changelog_buffer} =
	    $instance->{changelog_textview}->get_buffer();
	create_format_tags($instance->{changelog_buffer});
	$font = Gtk2::Pango::FontDescription->from_string("monospace 10");
	$instance->{changelog_textview}->modify_font($font)
	    if (defined($font));

	$instance->{grab_widget} = $instance->{window};

	push(@windows, $instance);
    }
    else
    {
	($width, $height) = $instance->{window}->get_default_size();
	$instance->{window}->resize($width, $height);
    }

    # Empty out the contents.

    $instance->{changelog_buffer}->set_text("");

    return $instance;

}
#
##############################################################################
#
#   Routine      - get_file_history_window
#
#   Description  - Creates or prepares an existing a change log window for
#                  use.
#
#   Data         - Return Value : A reference to the newly created or unused
#                                 change log instance record.
#
##############################################################################



sub get_file_history_window()
{

    my ($font,
	$height,
	$instance,
	$width);

    foreach my $window (@windows)
    {
	if ($window->{type} eq "file_history_window"
	    && ! $window->{window}->mapped())
	{
	    $instance = $window;
	    last;
	}
    }

    # Create a new file history window if an unused one wasn't found, otherwise
    # reuse an existing unused one.

    if (! defined($instance))
    {
	$instance = {};
	$instance->{type} = "file_history_window";
	$instance->{glade} =
	    Gtk2::GladeXML->new("../mtn-browse.glade", "file_history_window");

	# Flag to stop recursive calling of callbacks.

	$instance->{in_cb} = 0;

	# Connect Glade registered signal handlers.

	$instance->{glade}->signal_autoconnect
	    (sub {
		 my($callback_name, $widget, $signal_name, $signal_data,
		    $connect_object, $after, $user_data) = @_;
		 my $func = $after ? "signal_connect_after" : "signal_connect";
		 $widget->$func($signal_name,
				$callback_name,
				$connect_object ?
				    $connect_object : $user_data); },
	     $instance);

	# Get the widgets that we are interested in.

	$instance->{window} =
	    $instance->{glade}->get_widget("file_history_window");
	$instance->{window}->set_icon($app_icon);
	$instance->{appbar} = $instance->{glade}->get_widget("appbar");
	$instance->{history_textview} =
	    $instance->{glade}->get_widget("history_textview");
	$instance->{history_scrolledwindow} =
	    $instance->{glade}->get_widget("history_scrolledwindow");
	$instance->{stop_button} =
	    $instance->{glade}->get_widget("stop_button");
	$instance->{compare_button} =
	    $instance->{glade}->get_widget("compare_button");
	$instance->{numbers_label} =
	    $instance->{glade}->get_widget("numbers_value_label");
	$instance->{revision_id_1_label} =
	    $instance->{glade}->get_widget("revision_id_1_value_label");
	$instance->{revision_id_2_label} =
	    $instance->{glade}->get_widget("revision_id_2_value_label");

	# Setup the file history callbacks.

	$instance->{window}->signal_connect
	    ("delete_event",
	     sub { $_[0]->hide() unless ($_[2]->{in_cb}); return TRUE; },
	     $instance);
	$instance->{stop_button}->signal_connect
	    ("clicked", sub { $_[1]->{stop} = 1; }, $instance);

	# Setup the file history viewer.

	$instance->{history_buffer} =
	    $instance->{history_textview}->get_buffer();
	create_format_tags($instance->{history_buffer});
	$font = Gtk2::Pango::FontDescription->from_string("monospace 10");
	$instance->{history_textview}->modify_font($font) if (defined($font));

	# Make the stop button the grab widget when busy, this is so the user
	# can interrupt the history gathering process.

	$instance->{grab_widget} = $instance->{stop_button};

	push(@windows, $instance);
    }
    else
    {
	($width, $height) = $instance->{window}->get_default_size();
	$instance->{window}->resize($width, $height);
	$instance->{stop_button}->set_sensitive(FALSE);
	$instance->{compare_button}->set_sensitive(FALSE);
	set_label_value($instance->{numbers_label}, "");
	set_label_value($instance->{revision_id_1_label}, "");
	set_label_value($instance->{revision_id_2_label}, "");
    }

    $instance->{stop} = 0;

    # Empty out the contents.

    $instance->{history_buffer}->set_text("");

    return $instance;

}
#
##############################################################################
#
#   Routine      - get_file_history_helper
#
#   Description  - Recursive routine for getting the revisions in a file's
#                  change history.
#
#   Data         - $instance    : The file history window instance.
#                  $hash        : A reference to a hash that is to contain the
#                                 list of revision ids.
#                  $revision_id : The revision id from where the search is to
#                                 commence.
#
##############################################################################



sub get_file_history_helper($$$)
{

    my($instance, $hash, $revision_id) = @_;

    my(@change_parents,
       @parents);

    return if ($instance->{stop});

    $instance->{mtn}->get_content_changed(\@change_parents,
					  $revision_id,
					  $instance->{file_name});
    foreach my $revision (@change_parents)
    {
	if (! exists($hash->{$revision}))
	{
	    $hash->{$revision} = 1;
	    set_label_value($instance->{numbers_label}, scalar(keys(%$hash)));
	    gtk2_update();
	    @parents = ();
	    $instance->{mtn}->parents(\@parents, $revision);
	    foreach my $parent (@parents)
	    {
		get_file_history_helper($instance, $hash, $parent);
	    }
	}
    }

}
#
##############################################################################
#
#   Routine      - update_browser_state
#
#   Description  - Update the display of the specified browser instance
#                  according to the specified state.
#
#   Data         - $browser : The browser instance that is to have its state
#                             updated.
#                  $changed : What the user has changed.
#
##############################################################################



sub update_browser_state($$)
{

    my($browser, $changed) = @_;

    make_busy($browser, 1);
    $browser->{appbar}->push("");
    gtk2_update();

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the branch selection.

	$browser->{branch_combo_details}->{completion_cache} = {};
	if (! $browser->{branch_combo_details}->{preset})
	{
	    $browser->{branch_combo_details}->{completed} = 0;
	    $browser->{branch_combo_details}->{value} = "";
	}
	$browser->{branch_combo_details}->{preset} = 0;
	set_label_value($browser->{database_name_label}, "<WorkSpace>");

	# Get the new list of branches.

	$browser->{appbar}->set_status("Fetching branch list");
	gtk2_update();
	$browser->{mtn}->branches(\@branch_list) if (defined($browser->{mtn}));
	$browser->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$browser->{appbar}->set_status("Populating branch list");
	gtk2_update();
	my $counter = 1;
	$browser->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $browser->{branch_combo}->append_text($branch);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@branch_list));
	    gtk2_update();
	}
	$browser->{branch_combo}->child()->
	    set_text($browser->{branch_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$browser->{revision_combo_details}->{completion_cache} = {};
	if (! $browser->{revision_combo_details}->{preset})
	{
	    $browser->{revision_combo_details}->{completed} = 0;
	    $browser->{revision_combo_details}->{value} = "";
	}
	$browser->{revision_combo_details}->{preset} = 0;

	# Get the new list of revisions.

	if ($browser->{branch_combo_details}->{completed})
	{
	    $browser->{appbar}->set_status("Fetching revision list");
	    gtk2_update();

	    # Get either a list of tags or revision ids depending upon what the
	    # user has chosen.

	    if ($browser->{tagged_tick}->get_active())
	    {
		my(%dup_list,
		   @list);
		$browser->{mtn}->
		    tags(\@list, $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.5);
		gtk2_update();
		foreach my $item (@list)
		{
		    if (! exists($dup_list{$item->{tag}}))
		    {
			push(@revision_list, $item->{tag});
			$dup_list{$item->{tag}} = 1;
		    }
		}
	    }
	    else
	    {
		$browser->{mtn}->
		    select(\@revision_list,
			   "b:" . $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.33);
		gtk2_update();
		$browser->{mtn}->toposort(\@revision_list, @revision_list);
		$browser->{appbar}->set_progress_percentage(0.66);
		gtk2_update();
		splice(@revision_list, 0, scalar(@revision_list) - 100);
		@revision_list = reverse(@revision_list);
	    }
	    $browser->{appbar}->set_progress_percentage(1);
	    gtk2_update();
	}
	$browser->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating revision list");
	gtk2_update();
	my $counter = 1;
	$browser->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $browser->{revision_combo}->append_text($revision);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_list));
	    gtk2_update();
	}
	$browser->{revision_combo}->child()->
	    set_text($browser->{revision_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available files and directories has changed.

    if ($changed & DIRECTORY)
    {

	my(@directory_list,
	   @manifest_list);

	# Reset the directory combo.

	$browser->{directory_combo_details}->{completion_cache} = {};
	$browser->{directory_combo_details}->{completed} = 0;
	$browser->{directory_combo_details}->{last_typed_len} = 0;
	$browser->{directory_combo_details}->{value} = "";
	set_label_value($browser->{revision_id_label}, "");
	set_label_value($browser->{author_label}, "");
	set_label_value($browser->{change_log_label}, "");

	# Reset the name of the file being viewed.

	$browser->{file_being_viewed} = {};

	# Get the new manifest.

	$browser->{appbar}->set_status("Fetching manifest");
	gtk2_update();
	if ($browser->{revision_combo_details}->{completed})
	{
	    my @revision_ids;
	    get_revision_ids($browser, \@revision_ids);
	    if (scalar(@revision_ids) > 1)
	    {
		my $message;
		$message =
		    sprintf("The `%s' tag is not unique on this branch.\n"
			        . "Please either select the revision by its "
			            . "id\n"
			        . "or use the <i>Advanced Find</i> feature.\n"
			        . "The matching revision ids are:",
			    $browser->{revision_combo_details}->{value});
		foreach my $item (@revision_ids)
		{
		    $message .= "\n" . Glib::Markup::escape_text($item);
		}
		my $dialog = Gtk2::MessageDialog->new_with_markup
		    ($browser->{window}, ["modal"], "info", "close", $message);
		$dialog->run();
		$dialog->destroy();
		$browser->{revision_combo_details}->{completed} = 0;
		$browser->{revision_combo_details}->{value} = "";
		$browser->{revision_combo}->child()->set_text("");
	    }
	    else
	    {
		my($author,
		   @certs_list,
		   $change_log);
		$browser->{mtn}->get_manifest_of(\@manifest_list,
						 $revision_ids[0]);
		$browser->{mtn}->certs(\@certs_list, $revision_ids[0]);
		$author = $change_log = "";
		foreach my $cert (@certs_list)
		{
		    $author = $cert->{value}
		        if ($cert->{name} eq "author");
		    if ($cert->{name} eq "changelog")
		    {
			$change_log = $cert->{value};
			$change_log =~ s/\s+$//os;
		    }
		}
		set_label_value($browser->{revision_id_label},
				$revision_ids[0]);
		set_label_value($browser->{author_label}, $author);
		set_label_value($browser->{change_log_label}, $change_log);
	    }
	}
	$browser->{manifest} = \@manifest_list;

	# Generate a simple list of directories for auto completion.

	$browser->{appbar}->set_progress_percentage(0.5);
	gtk2_update();
	foreach my $item (@manifest_list)
	{
	    push(@directory_list, $item->{name})
		if ($item->{type} eq "directory");
	}
	$browser->{directory_combo_details}->{list} = \@directory_list;
	$browser->{appbar}->set_progress_percentage(1);
	gtk2_update();

	# Update the directory list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating directory list");
	gtk2_update();
	my $counter = 1;
	$browser->{directory_combo}->get_model()->clear();
	foreach my $item (@directory_list)
	{
	    $browser->{directory_combo}->append_text($item);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@directory_list));
	    gtk2_update();
	}
	$browser->{directory_combo}->child()->set_text("");
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	foreach my $widget (@{$browser->{revision_sensitive_group}})
	{
	    $widget->
		set_sensitive($browser->{revision_combo_details}->{completed});
	}
	gtk2_update();

    }

    # The list of displayed files and directories has changed.

    if ($changed & DIRECTORY_VIEW)
    {

	my($author,
	   @certs_list,
	   $counter,
	   @directory_entry_list,
	   $last_update,
	   @revision_ids,
	   @revision_list,
	   $taking_our_time);

	# Reset the manifest tree view.

	$browser->{manifest_liststore}->clear();

	# Get the contents of the new directory.

	if ($browser->{directory_combo_details}->{completed}
	    || $browser->{directory_combo_details}->{value} eq "")
	{
	    get_dir_contents($browser->{directory_combo_details}->{value},
			     $browser->{manifest},
			     \@directory_entry_list);
	}

	# Disable the directory up button if we are already at the top level,
	# otherwise make sure it is enabled.

	$browser->{directory_up_button}->set_sensitive
	    (($browser->{directory_combo_details}->{value} eq "")
	     ? FALSE : TRUE);

	# Update the directory tree view.

	$browser->{appbar}->set_status("Populating file details");
	$counter = 1;
	$taking_our_time = 0;
	get_revision_ids($browser, \@revision_ids);
	foreach my $item (@directory_entry_list)
	{

	    # Get the latest modification time and the author if the entry is a
	    # file (caching the result in the manifest for future reference if
	    # we have to work it out).

	    if ($item->{manifest_entry}->{type} eq "file")
	    {
		if (! exists($item->{manifest_entry}->{author}))
		{
		    $taking_our_time = 1;
		    $browser->{mtn}->get_content_changed
			(\@revision_list,
			 $revision_ids[0],
			 $item->{manifest_entry}->{name});
		    $item->{manifest_entry}->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    $author = $last_update = "";
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "author")
			{
			    $author = $cert->{value};
			    $item->{manifest_entry}->{author} = $author;
			}
			if ($cert->{name} eq "date")
			{
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $item->{manifest_entry}->{last_update} =
				$last_update;
			}
			last if ($author ne "" && $last_update ne "");
		    }
		}
		else
		{
		    $author = $item->{manifest_entry}->{author};
		    $last_update = $item->{manifest_entry}->{last_update};
		}
	    }
	    else
	    {
		$author = "";
		$last_update = "";
	    }

	    # Put the entry into the liststore.

	    $browser->{manifest_liststore}->
		set($browser->{manifest_liststore}->append(),
		    MLS_ICON_COLUMN,
		        ($item->{manifest_entry}->{type} eq "directory")
		        ? "gtk-open" : "gtk-file",
		    MLS_NAME_COLUMN, $item->{name},
		    MLS_DATE_COLUMN, $last_update,
		    MLS_AUTHOR_COLUMN, $author,
		    MLS_MANIFEST_ENTRY_COLUMN, $item->{manifest_entry});

	    if ($taking_our_time)
	    {
		$browser->{appbar}->set_progress_percentage
		    ($counter / scalar(@directory_entry_list));
		gtk2_update();
	    }
	    ++ $counter;

	}

	$browser->{manifest_treeview}->scroll_to_point(0, 0)
	    if ($browser->{manifest_treeview}->realized());

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The displayed file contents has changed.

    if ($changed & DISPLAY_OF_FILE)
    {

	# Load up the selected file's contents into the file viewer.

	if (exists($browser->{file_being_viewed}->{manifest_entry}))
	{
	    my $manifest_entry;
	    $manifest_entry =
		$browser->{file_being_viewed}->{manifest_entry};
	    if ($browser->{file_id_label}->get_text()
		ne $manifest_entry->{file_id})
	    {

		my($contents,
		   $lang,
		   $mime_type,
		   $scrolled_window);

		# Reset the file view buffer.

		$browser->{file_button_vbox}->set_sensitive(TRUE);
		foreach my $widget (@{$browser->{text_file_sensitive_group}})
		{
		    $widget->set_sensitive(FALSE);
		}
		$browser->{file_view_svbuffer}->set_text("");
		$browser->{file_view_svbuffer}->set("highlight", FALSE);

		# Get contents.

		$manifest_entry =
		    $browser->{file_being_viewed}->{manifest_entry};
		$browser->{mtn}->get_file(\$contents,
					  $manifest_entry->{file_id});

		# Try and work out the mime type, first based on contents and
		# then based on the file name extension.

		if (! defined($mime_type =
			       Gnome2::VFS->get_mime_type_for_data($contents))
		    || $mime_type eq "text/plain")
		{
		    my $name = $browser->{file_being_viewed}->{short_name};
		    foreach my $item (@text_mime_types)
		    {
			if ($name =~ m/$item->{pattern}/)
			{
			    $mime_type = $item->{type};
			    last;
			}
		    }
		}

		# Override some mis-identified types.

		$mime_type = "image/svg+xml"
		    if ($mime_type eq "text/xml"
			&& $browser->{file_being_viewed}->{short_name}
			    =~ m/.*\.svg$/o);

		# If it's image data then attempt to render it.

		if ($mime_type =~ m/^image\/.+$/o)
		{
		    eval
		    {
			my $loader = Gtk2::Gdk::PixbufLoader->new();
			$loader->write($contents);
			$loader->close();
			$browser->{file_view_svbuffer}->insert_pixbuf
			    ($browser->{file_view_svbuffer}->get_start_iter(),
			     $loader->get_pixbuf());
		    };
		    $browser->{file_view_svbuffer}->
			set_text("<" . $mime_type . ">\n") if ($@ ne "");
		}
		else
		{

		    my $ok_to_render = 0;

		    # Attempt to syntax highlight the file if it looks safe.

		    if ($mime_type =~ m/^application\/.+$/o)
		    {
			my $part;
			($part) = ($mime_type =~ m/^application\/(.+)$/o);
			foreach my $item (@text_viewable_app_mime_types)
			{
			    if ($part eq $item)
			    {
				$ok_to_render = 1;
				last;
			    }
			}
		    }

		    if ($mime_type =~ m/^text\/.+$/o || $ok_to_render)
		    {
			if (defined($lang = $browser->{file_view_svlangmgr}->
				    get_language_from_mime_type($mime_type)))
			{
			    $browser->{file_view_svbuffer}->
				set("highlight", TRUE);
			    $browser->{file_view_svbuffer}->
				set_language($lang);
			}

			# Load in the contents.

			$browser->{file_view_svbuffer}->set_text($contents);
			foreach my $widget
			    (@{$browser->{text_file_sensitive_group}})
			{
			    $widget->set_sensitive(TRUE);
			}
		    }
		    else
		    {
			$browser->{file_view_svbuffer}->
			    set("highlight", FALSE);
			$browser->{file_view_svbuffer}->
			    set_text("<" . $mime_type . ">\n");
		    }

		}

		# Scroll back up to the top left.

		if ($browser->{file_view_scrolledwindow}->realized())
		{
		    $browser->{file_view_scrolledwindow}->
			get_vadjustment()->set_value(0);
		    $browser->{file_view_scrolledwindow}->
			get_hadjustment()->set_value(0);
		}

		# Update the file details labels.

		if (! exists($manifest_entry->{last_changed_revision}))
		{
		    my(@certs_list,
		       @revision_ids,
		       @revision_list);
		    get_revision_ids($browser, \@revision_ids);
		    $browser->{mtn}->
			get_content_changed(\@revision_list,
					    $revision_ids[0],
					    $manifest_entry->{name});
		    $manifest_entry->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "date")
			{
			    my $last_update;
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $manifest_entry->{last_update} = $last_update;
			    last;
			}
		    }
		}
		set_label_value($browser->{file_name_label},
				$manifest_entry->{name});
		set_label_value($browser->{file_id_label},
				$manifest_entry->{file_id});
		set_label_value($browser->{last_update_label},
				$manifest_entry->{last_update});
		set_label_value($browser->{file_revision_id_label},
				$manifest_entry->{last_changed_revision});
	    }
	}
	else
	{

	    # Reset the file view buffer.

	    $browser->{file_button_vbox}->set_sensitive(FALSE);
	    $browser->{file_view_svbuffer}->set_text("");
	    $browser->{file_view_svbuffer}->set("highlight", FALSE);
	    set_label_value($browser->{file_name_label}, "");
	    set_label_value($browser->{file_id_label}, "");
	    set_label_value($browser->{last_update_label}, "");
	    set_label_value($browser->{file_revision_id_label}, "");

	}

    }

    if ($changed & FILE)
    {
    }

    $browser->{appbar}->pop();
    make_busy($browser, 0);

}
#
##############################################################################
#
#   Routine      - update_advanced_find_state
#
#   Description  - Update the display of the specified advanced find dialog
#                  window instance according to the specified state.
#
#   Data         - $advanced_find : The advanced find dialog window instance
#                                   that is to have its state updated.
#                  $changed       : What the user has changed.
#
##############################################################################



sub update_advanced_find_state($$)
{

    my($advanced_find, $changed) = @_;

    my $made_busy = 0;

    if ($advanced_find->{window}->realized())
    {
	$made_busy = 1;
	make_busy($advanced_find, 1);
    }
    $advanced_find->{appbar}->push("");
    gtk2_update();

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the query mode.

	$advanced_find->{simple_query_radiobutton}->set_active(TRUE);
	$advanced_find->{simple_frame}->set_sensitive(TRUE);
	$advanced_find->{advanced_frame}->set_sensitive(FALSE);

	# Reset the branch selection.

	$advanced_find->{branch_combo_details}->{completion_cache} = {};
	if (! $advanced_find->{branch_combo_details}->{preset})
	{
	    $advanced_find->{branch_combo_details}->{completed} = 0;
	    $advanced_find->{branch_combo_details}->{value} = "";
	}
	$advanced_find->{branch_combo_details}->{preset} = 0;

	# Get the new list of branches.

	$advanced_find->{appbar}->set_status("Fetching branch list");
	gtk2_update();
	$advanced_find->{mtn}->branches(\@branch_list)
	    if (defined($advanced_find->{mtn}));
	$advanced_find->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$advanced_find->{appbar}->set_status("Populating branch list");
	gtk2_update();
	my $counter = 1;
	$advanced_find->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $advanced_find->{branch_combo}->append_text($branch);
	    $advanced_find->{appbar}->set_progress_percentage
		($counter ++ / scalar(@branch_list));
	    gtk2_update();
	}
	$advanced_find->{branch_combo}->child()->
	    set_text($advanced_find->{branch_combo_details}->{value});
	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$advanced_find->{revision_combo_details}->{completion_cache} = {};
	if (! $advanced_find->{revision_combo_details}->{preset})
	{
	    $advanced_find->{revision_combo_details}->{completed} = 0;
	    $advanced_find->{revision_combo_details}->{value} = "";
	}
	$advanced_find->{revision_combo_details}->{preset} = 0;

	# Get the new list of revisions.

	if ($advanced_find->{branch_combo_details}->{completed})
	{
	    $advanced_find->{appbar}->set_status("Fetching revision list");
	    gtk2_update();

	    # Get either a list of tags or revision ids depending upon what the
	    # user has chosen.

	    if ($advanced_find->{tagged_tick}->get_active())
	    {
		my(%dup_list,
		   @list);
		$advanced_find->{mtn}->
		    tags(\@list,
			 $advanced_find->{branch_combo_details}->{value});
		$advanced_find->{appbar}->set_progress_percentage(0.5);
		gtk2_update();
		foreach my $item (@list)
		{
		    if (! exists($dup_list{$item->{tag}}))
		    {
			push(@revision_list, $item->{tag});
			$dup_list{$item->{tag}} = 1;
		    }
		}
	    }
	    else
	    {
		$advanced_find->{mtn}->
		    select(\@revision_list,
			   "b:" . $advanced_find->{branch_combo_details}->
			       {value});
		$advanced_find->{appbar}->set_progress_percentage(0.33);
		gtk2_update();
		$advanced_find->{mtn}->toposort(\@revision_list,
						@revision_list);
		$advanced_find->{appbar}->set_progress_percentage(0.66);
		gtk2_update();
		splice(@revision_list, 0, scalar(@revision_list) - 100);
		@revision_list = reverse(@revision_list);
	    }
	    $advanced_find->{appbar}->set_progress_percentage(1);
	    gtk2_update();
	}
	$advanced_find->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("Populating revision list");
	gtk2_update();
	my $counter = 1;
	$advanced_find->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $advanced_find->{revision_combo}->append_text($revision);
	    $advanced_find->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_list));
	    gtk2_update();
	}
	$advanced_find->{revision_combo}->child()->
	    set_text($advanced_find->{revision_combo_details}->{value});
	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of displayed revisions has changed.

    if ($changed & REVISION_LIST)
    {

	my($counter,
	   @revision_ids);

	# Reset the revisions tree view.

	$advanced_find->{revisions_liststore}->clear();
	$advanced_find->{revisions_treeview_details}->{value} = "";

	# Get the list of matching revisions.

	$advanced_find->{appbar}->set_status("Finding revisions");
	gtk2_update();
	if ($advanced_find->{simple_query_radiobutton}->get_active())
	{
	    if ($advanced_find->{revision_combo_details}->{completed})
	    {
		get_revision_ids($advanced_find, \@revision_ids);
	    }
	}
	else
	{
	    my $query;
	    $query = $advanced_find->{search_term_combo}->child()->get_text();

	    # Remember the user can type in any old rubbish with advanced
	    # queries! So protect ourselves.

	    Monotone::AutomateStdio->register_error_handler
		("both",
		 sub {
		     my($severity, $message) = @_;
		     my $dialog;
		     $dialog = Gtk2::MessageDialog->new_with_markup
			 ($advanced_find->{window},
			  ["modal"],
			  "warning",
			  "close",
			  sprintf("Problem with your query, Monotone "
				      . "gave:\n<b><i>%s</i></b>",
				  Glib::Markup::escape_text($message)));
		     $dialog->run();
		     $dialog->destroy();
		     die("Bad query"); });
	    eval
	    {
		$advanced_find->{mtn}->select(\@revision_ids, $query);
	    };

	    # If the query was valid the store it in the history.

	    if (! $@)
	    {
		my $found;
		if (scalar(@revision_ids) == 0)
		{
		    my $dialog;
		    $dialog = Gtk2::MessageDialog->new
			($advanced_find->{window},
			 ["modal"],
			 "info",
			 "close",
			 "No revisions matched your query");
		     $dialog->run();
		     $dialog->destroy();
		}
		$found = 0;
		foreach my $entry (@{$advanced_find->{query_history}})
		{
		    if ($entry eq $query)
		    {
			$found = 1;
			last;
		    }
		}
		if (! $found)
		{
		    if (unshift(@{$advanced_find->{query_history}}, $query)
			> 20)
		    {
			pop(@{$advanced_find->{query_history}});
		    }
		    $advanced_find->{search_term_combo}->get_model()->clear();
		    foreach my $entry (@{$advanced_find->{query_history}})
		    {
			$advanced_find->{search_term_combo}->
			    append_text($entry);
		    }
		}
	    }
	    Monotone::AutomateStdio->register_error_handler
		("both", \&mtn_error_handler);

	}

	# Update the revisions tree view.

	$advanced_find->{appbar}->set_status("Populating revision details");
	$counter = 1;
	foreach my $item (@revision_ids)
	{
	    $advanced_find->{revisions_liststore}->
		set($advanced_find->{revisions_liststore}->append(),
		    0, $item);
	    $advanced_find->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_ids));
	    gtk2_update();
	}
	$advanced_find->{revisions_treeview}->scroll_to_point(0, 0)
	    if ($advanced_find->{revisions_treeview}->realized());

	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("");
	gtk2_update();

    }

    # The selected revision has changed.

    if ($changed & REVISION_DETAILS)
    {

	if ($advanced_find->{revisions_treeview_details}->{value} ne "")
	{
	    if ($advanced_find->{selected_revision_label}->get_text()
		ne $advanced_find->{revisions_treeview_details}->{value})
	    {
		my ($branch,
		    @certs_list,
		    @revision_details);

		$advanced_find->{details_buffer}->set_text("");
		$advanced_find->{mtn}->certs
		    (\@certs_list,
		     $advanced_find->{revisions_treeview_details}->{value});
		$advanced_find->{mtn}->get_revision
		    (\@revision_details,
		     $advanced_find->{revisions_treeview_details}->{value});
		generate_revision_report
		    ($advanced_find->{details_buffer},
		     $advanced_find->{revisions_treeview_details}->{value},
		     \@certs_list,
		     \@revision_details);

		# Scroll back up to the top left.

		if ($advanced_find->{details_scrolledwindow}->realized())
		{
		    $advanced_find->{details_scrolledwindow}->
			get_vadjustment()->set_value(0);
		    $advanced_find->{details_scrolledwindow}->
			get_hadjustment()->set_value(0);
		}

		# Update the selected branch and revision labels.

		$branch = "";
		foreach my $cert (@certs_list)
		{
		    if ($cert->{name} eq "branch")
		    {
			$branch = $cert->{value};
			last;
		    }
		}
		set_label_value($advanced_find->{selected_branch_label},
				$branch);
		set_label_value($advanced_find->{selected_revision_label},
				$advanced_find->{revisions_treeview_details}->
				    {value});

		$advanced_find->{ok_button}->set_sensitive(TRUE);
	    }
	}
	else
	{
	    $advanced_find->{ok_button}->set_sensitive(FALSE);
	    $advanced_find->{details_buffer}->set_text("");
	    set_label_value($advanced_find->{selected_branch_label}, "");
	    set_label_value($advanced_find->{selected_revision_label}, "");
	}

    }

    $advanced_find->{appbar}->pop();
    make_busy($advanced_find, 0) if ($made_busy);

}
#
##############################################################################
#
#   Routine      - generate_revision_report
#
#   Description  - Populate the specified Gtk2::TextBuffer with a pretty
#                  printed report on the specified revision.
#
#   Data         - $text_buffer      : The Gtk2::TextBuffer that is to be
#                                      populated.
#                  $revision_id      : The id of the revision being reported
#                                      on.
#                  $certs_list       : A reference to a certs list as returned
#                                      by $mtn->certs().
#                  $revision_details : Either a reference to a revision
#                                      details list as returned by
#                                      $mtn->get_revision() if a detailed
#                                      report is to be generated or undef if
#                                      the report is to just be a summary.
#
##############################################################################



sub generate_revision_report($$$$)
{

    my($text_buffer, $revision_id, $certs_list, $revision_details) = @_;

    my($change_log,
       $manifest_id,
       @parent_revision_ids,
       %revision_data,
       %seen,
       @unique);
    my @types =
	("Added", "Removed", "Changed", "Renamed", "Attributes");

    # Revision id.

    $text_buffer->insert_with_tags_by_name($text_buffer->get_end_iter(),
					   "Revision id: ",
					   "bold");
    $text_buffer->insert($text_buffer->get_end_iter(),
			 $revision_id . "\n\n");

    # Certs.

    foreach my $cert (@$certs_list)
    {
	if ($cert->{name} eq "changelog")
	{
	    $change_log = $cert->{value};
	    $change_log =~ s/\s+$//os;
	}
	else
	{
	    $cert->{value} =~ s/T/ /o if ($cert->{name} eq "date");
	    $text_buffer->insert_with_tags_by_name
		($text_buffer->get_end_iter(),
		 sprintf("%s:\t", ucfirst($cert->{name})),
		 "bold");
	    $text_buffer->insert($text_buffer->get_end_iter(),
				 sprintf("%s\n", $cert->{value}));
	}
    }

    # Change log.

    $text_buffer->insert_with_tags_by_name
	($text_buffer->get_end_iter(), "\nChange Log:\n", "bold");
    $text_buffer->insert($text_buffer->get_end_iter(),
			 sprintf("%s", $change_log));

    # The rest is only provided if it is a detailed report.

    if (defined($revision_details))
    {

	# Revision details.

	$text_buffer->insert_with_tags_by_name($text_buffer->get_end_iter(),
					       "\n\nChanges Made:\n", "bold");
	foreach my $type (@types)
	{
	    $revision_data{$type} = [];
	}
	foreach my $change (@$revision_details)
	{
	    if ($change->{type} eq "add_dir")
	    {
		push(@{$revision_data{"Added"}}, $change->{name} . "/");
	    }
	    elsif ($change->{type} eq "add_file")
	    {
		push(@{$revision_data{"Added"}}, $change->{name});
	    }
	    elsif ($change->{type} eq "delete")
	    {
		push(@{$revision_data{"Removed"}}, $change->{name});
	    }
	    elsif ($change->{type} eq "patch")
	    {
		push(@{$revision_data{"Changed"}}, $change->{name});
	    }
	    elsif ($change->{type} eq "rename")
	    {
		push(@{$revision_data{"Renamed"}},
		     $change->{from_name} . " -> " . $change->{to_name});
	    }
	    elsif ($change->{type} eq "clear")
	    {
		push(@{$revision_data{"Attributes"}},
		     sprintf("%s: %s was cleared",
			     $change->{name},
			     $change->{attribute}));
	    }
	    elsif ($change->{type} eq "clear" || $change->{type} eq "set")
	    {
		push(@{$revision_data{"Attributes"}},
		     sprintf("%s: %s = %s",
			     $change->{name},
			     $change->{attribute},
			     $change->{value}));
	    }
	    elsif ($change->{type} eq "old_revision")
	    {
		push(@parent_revision_ids, $change->{revision_id});
	    }
	    elsif ($change->{type} eq "new_manifest")
	    {
		$manifest_id = $change->{manifest_id};
	    }
	}
	foreach my $type (@types)
	{
	    if (scalar(@{$revision_data{$type}}) > 0)
	    {
		$text_buffer->insert_with_tags_by_name
		    ($text_buffer->get_end_iter(),
		     "    " . $type . ":\n", "italics");
		%seen = ();
		@unique = sort(grep { ! $seen{$_} ++ }
			       @{$revision_data{$type}});
		foreach my $line (@unique)
		{
		    $text_buffer->insert($text_buffer->get_end_iter(),
					 "\t" . $line . "\n");
		}
	    }
	}

	# Parent revision and manifest ids.

	$text_buffer->insert_with_tags_by_name($text_buffer->get_end_iter(),
					       "\nParent revision id(s):\t",
					       "bold");
	$text_buffer->insert($text_buffer->get_end_iter(),
			     join(" ", @parent_revision_ids) . "\n");
	$text_buffer->insert_with_tags_by_name($text_buffer->get_end_iter(),
					       "Manifest id:\t\t",
					       "bold");
	$text_buffer->insert($text_buffer->get_end_iter(), $manifest_id);

    }

}
#
##############################################################################
#
#   Routine      - get_completion
#
#   Description  - Given a value and a list, work out the largest unique
#                  match. Used for auto completion.
#
#   Data         - $value       : The value to be completed.
#                  $list        : A reference to a list containing all
#                                 possible completions.
#                  $result      : A reference to a buffer that is to contain
#                                 the result.
#                  $complete    : A reference to a boolean that is to contain
#                                 a `result is complete' indicator.
#                  $cache       : An optional reference to a hash that will be
#                                 used to cache the hash tree (saved
#                                 recomputation).
#                  Return Value : True if $value was expanded, otherwise false
#                                 if $value had to be truncated due to no
#                                 match (the maximum valid completion is still
#                                 returned in $result).
#
##############################################################################



sub get_completion($$$$;$)
{

    my($value, $list, $result, $complete, $cache) = @_;

    my($char,
       $item,
       $level,
       %local_cache,
       $tree);

    # Work out what cache we are to use.

    $tree = (defined($cache)) ? $cache : \%local_cache;

    # Unless we are given an already built hash tree, build one up for the list
    # of possible items.

    if (scalar(keys(%$tree)) == 0)
    {
	foreach $item (@$list)
	{

	    # Build up nodes for an item.

	    $level = $tree;
	    foreach $char (split(//o, $item))
	    {
		if (! exists($level->{$char}))
		{
		    $level->{$char} = {};
		}
		$level = $level->{$char};
	    }

	    # By adding this dummy node here it stops the auto-complete moving
	    # too far should another item extend beyond this point. I.e. auto
	    # completion stops at `net.venge.monotone.contrib' and not
	    # `net.venge.monotone.contrib.'. You could simply think of this
	    # node as an `end of string' token if you prefer.

	    $level->{""} = "";

	}
    }

    # Lookup value, stopping when it becomes ambiguous or we get to the end of
    # $value.

    $level = $tree;
    $$result = "";
    foreach $char (split(//o, $value))
    {
	last unless (exists($level->{$char}));
	$level = $level->{$char};
	$$result .= $char;
    }

    # Detect truncations.

    return if (length($value) > length($$result));

    # Now try and expand it further.

    while (defined(%$level) && keys(%$level) == 1)
    {
	($char) = keys(%$level);
	$$result .= $char;
	$level = $level->{$char};
    }

    # Detect complete completions (doesn't mean to say that it can't be
    # extended, just that as it stands at the moment $$result does contain a
    # valid unique value).

    if (! defined(%$level) || exists($level->{""}))
    {
	$$complete = 1;
    }
    else
    {
	$$complete = 0;
    }

    return 1;

}
#
##############################################################################
#
#   Routine      - get_dir_contents
#
#   Description  - Given a path and a Monotone manifest, return a subset of
#                  the manifest that represents the contents of just that
#                  directory along with the directory entry names.
#
#   Data         - $path     : The path to the directory from the top level of
#                              the manifest.
#                  $manifest : A reference to a Monotone manifest.
#                  $result   : A reference to a list that is to contain the
#                              result (a list of records containing the short
#                              directory entry name and a reference to the
#                              related manifest entry).
#
##############################################################################



sub get_dir_contents($$$)
{

    my($path, $manifest, $result) = @_;

    my($entry,
       $extract_re,
       $i,
       $match_re,
       $name);

    $i = 0;
    if ($path eq "")
    {
	$match_re = qr/^[^\/]+$/;
	$extract_re = qr/^([^\/]+)$/;
    }
    else
    {
	$match_re = qr/^${path}\/[^\/]+$/;
	$extract_re = qr/^${path}\/([^\/]+)$/;
    }
    @$result = ();
    foreach $entry (@$manifest)
    {
	if ($entry->{name} =~ m/$match_re/)
	{
	    ($name) = ($entry->{name} =~ m/$extract_re/);
	    $$result[$i ++] = {manifest_entry => $entry,
			       name           => $name};
	}
    }

}
#
##############################################################################
#
#   Routine      - mtn_error_handler
#
#   Description  - This routine is called when ever there is a problem with
#                  Monotone.
#
#   Data         - $severity : The severity of the error.
#                  $message  : The error message.
#
##############################################################################



sub mtn_error_handler($$)
{

    my($severity, $message) = @_;

    my $dialog;

    if ($severity eq "warning")
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "warning",
	     "close",
	     sprintf("Problem with monotone request, got:\n<b><i>%s</i></b>\n"
		         . "This should not be happening!",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	die($message);
    }
    else
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "error",
	     "close",
	     sprintf("Monotone process unexpectedly exiting with:\n"
		         . "<b><i>%s</i></b>\n"
		         . "This is fatal, I am going to exit.",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	Gtk2->main_quit() unless (Gtk2->main_level() == 0);
	die($message);
    }

}
#
##############################################################################
#
#   Routine      - sigchld_handler
#
#   Description  - This routine is called when ever a subprocess exits.
#
#   Data         - None.
#
##############################################################################



sub sigchld_handler()
{

    my($pid,
       $status);

    while (($pid = waitpid(-1, WNOHANG)) > 0)
    {
	$status = $?;
	if (WIFEXITED($status) || WIFSIGNALED($status))
	{

	    # If it is an mtn process then close down the relevant object so
	    # that it will automatically restart when needed.

	    foreach my $window (@windows)
	    {
		if (exists($window->{mtn})
		    && $window->{mtn}->get_pid() == $pid)
		{
		    $window->{mtn}->closedown();
		    my $dialog = Gtk2::MessageDialog->new
			(undef,
			 ["modal"],
			 "warning",
			 "close",
			 sprintf("The mtn subprocess just unexpectedly\n"
				     . "exited (%s).\n"
				     . "This shouldn't happen.\n"
				     . "It will be restarted when needed.",
				 WIFSIGNALED($status) ?
				     sprintf("terminated by signal %d",
					     WTERMSIG($status)) :
				     sprintf("exited with status %d",
					     WEXITSTATUS($status))));
		    $dialog->run();
		    $dialog->destroy();
		    last;
		}
	    }

	    if (WIFSIGNALED($status))
	    {
	    }
	}
    }
    warn("waitpid failed: $!") if ($pid < 0 && $! != ECHILD);

}
#
##############################################################################
#
#   Routine      - setup_sigchld_handler
#
#   Description  - This routine sets up the handler for SIGCHLD signals.
#
#   Data         - $handler - A reference to the SIGCHLD handler routine.
#
##############################################################################



sub setup_sigchld_handler($)
{

    my $handler = $_[0];

    my($reader,
       $writer);

    # Basically set up a SIGCHLD handler that simply writes a character down an
    # anonymous pipe in order to wake up the actual handler that is registered
    # with Gtk2 as a file activity handler. This is efficient and safer than
    # some alternatives.

    pipe($reader, $writer) or die("pipe failed: $!");
    $SIG{CHLD} = sub { syswrite($writer, "\n", 1); };
    Gtk2::Helper->add_watch(fileno($reader), "in",
			    sub {
				my $buffer;
				sysread($reader, $buffer, 1);
				&$handler();
				return 1; });

}
#
##############################################################################
#
#   Routine      - get_revision_ids
#
#   Description  - Return the currently selected revision id, whether this is
#                  specified via a tag or as a revision id.
#
#   Data         - $instance     : The window instance.
#                  $revision_ids : The list of selected revision ids. Normally
#                                  the list will have at most one element but
#                                  may contain more if the tag isn't unique on
#                                  the current branch.
#
##############################################################################



sub get_revision_ids($$)
{

    my($instance, $revision_ids) = @_;

    @$revision_ids=();
    return unless ($instance->{revision_combo_details}->{completed});
    if ($instance->{tagged_tick}->get_active())
    {
	$instance->{mtn}->
	    select($revision_ids,
		   "t:" . $instance->{revision_combo_details}->{value});
    }
    else
    {
	push(@$revision_ids, $instance->{revision_combo_details}->{value});
    }

}
#
##############################################################################
#
#   Routine      - make_busy
#
#   Description  - This routine simply makes the main window busy or active.
#
#   Data         - $instance : The window instance.
#                  $busy     : True if the window is to be made busy,
#                              otherwise false if the window is to be made
#                              active.
#
##############################################################################



sub make_busy($$)
{

    my($instance, $busy) = @_;

    # Create and store the cursors if we haven't done so already.

    $busy_cursor = Gtk2::Gdk::Cursor->new("watch")
	unless (defined($busy_cursor));

    # Do it. Make the application bar grab the input when the window is busy,
    # that way we gobble up keyboard and mouse events that could muck up the
    # application state.

    if ($busy)
    {
	if (exists($instance->{grab_widget}))
	{
	    Gtk2->grab_add($instance->{grab_widget});
	}
	else
	{
	    Gtk2->grab_add($instance->{appbar});
	}
	foreach my $window (@windows)
	{
	    $window->{window}->window()->set_cursor($busy_cursor);
	}
    }
    else
    {
	if (exists($instance->{grab_widget}))
	{
	    Gtk2->grab_remove($instance->{grab_widget});
	}
	else
	{
	    Gtk2->grab_remove($instance->{appbar});
	}
	foreach my $window (@windows)
	{
	    $window->{window}->window()->set_cursor(undef);
	}
    }

}
#
##############################################################################
#
#   Routine      - gtk2_update
#
#   Description  - Process all outstanding Gtk2 toolkit events. This is used
#                  to update the GUI whilst the application is busy doing
#                  something.
#
#   Data         - None.
#
##############################################################################



sub gtk2_update()
{

    return if (Gtk2->main_level() == 0);
    while (Gtk2->events_pending())
    {
	Gtk2->main_iteration();
    }

}
#
##############################################################################
#
#   Routine      - create_format_tags
#
#   Description  - Creates the Gtk2::TextBuffer tags that are used to pretty
#                  print stuff.
#
#   Data         - $text_view : The GTK2::TextBuffer widget that is to have
#                               its tags created.
#
##############################################################################



sub create_format_tags($)
{

    my ($text_buffer) = @_;

    $text_buffer->create_tag("bold", weight => PANGO_WEIGHT_BOLD);
    $text_buffer->create_tag("italics", style => "italic");
    $text_buffer->create_tag("bold-italics",
			     weight => PANGO_WEIGHT_BOLD,
			     style => "italic");

}
#
##############################################################################
#
#   Routine      - set_label_value
#
#   Description  - Set the text for the given label and the tooltip for the
#                  parent widget, assumed to be an event box, to the specified
#                  text.
#
#   Data         - $widget : The label widget that has an event box as its
#                            parent.
#                  $value  : The text that the label and tooltip are to be set
#                            to.
#
##############################################################################



sub set_label_value($$)
{

    my($widget, $value) = @_;

    $widget->set_text($value);
    $tooltips->set_tip($widget->parent(), $value);

}
