#!/usr/bin/perl -W
##!/usr/bin/perl -w
##############################################################################
#
#   File Name    - mtn-browse
#
#   Description  - Perl GUI utility for browsing a Monotone database without a
#                  workspace.
#
#   Author       - A.E.Cooper.
#
#   Legal Stuff  - Copyright (c) 2007 Anthony Edward Cooper
#                  <aecooper@coosoft.plus.com>.
#
#                  This program is free software; you can redistribute it
#                  and/or modify it under the terms of the GNU General Public
#                  License as published by the Free Software Foundation;
#                  either version 3 of the License, or (at your option) any
#                  later version.
#
#                  This program is distributed in the hope that it will be
#                  useful, but WITHOUT ANY WARRANTY; without even the implied
#                  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#                  PURPOSE. See the GNU General Public License for more
#                  details.
#
#                  You should have received a copy of the GNU General Public
#                  License along with this software; if not, write to the Free
#                  Software Foundation, Inc., 59 Temple Place - Suite 330,
#                  Boston, MA 02111-1307 USA.
#
##############################################################################
#
##############################################################################
#
#   Global Data For This Module
#
##############################################################################



# ***** DIRECTIVES *****

require 5.008;

BEGIN
{
    use constant LIB_PATH => "/home/aecoope/perl";
}
use lib LIB_PATH;
use strict;

# ***** REQUIRED PACKAGES *****

# Standard Perl and CPAN modules.

use File::Basename;
use File::Temp;
use Glib qw(FALSE TRUE);
use Gnome2;
use Gnome2::VFS -init;
use Gtk2 -init;
use Gtk2::GladeXML;
use Gtk2::Helper;
use Gtk2::Pango;
use Gtk2::SourceView;
use IO::File;
use IPC::Open3;
use POSIX qw(:errno_h :sys_wait_h strftime);
use Symbol qw(gensym);
use Text::Tabs;

# Temporary debug stuff.

use Data::Dumper;

# Monotone AutomateStdio module.

use Monotone::AutomateStdio;

# Modules specific to this application.

use Globals qw(:constants :variables);
use AdvancedFind;
use Annotate;
use ChangeLog;
use ComboAutoCompletion;
use Completion;
use FindText;
use History;
use Utilities;
use WindowManager;

# ***** GLOBAL DATA DECLARATIONS *****

# Constants for the columns within the manifest ListStore widget.

use constant MLS_ICON_COLUMN           => 0;
use constant MLS_NAME_COLUMN           => 1;
use constant MLS_DATE_COLUMN           => 2;
use constant MLS_AUTHOR_COLUMN         => 3;
use constant MLS_MANIFEST_ENTRY_COLUMN => 4;

# The type of window that is going to be managed by this module.

my $window_type = "main_window";

# the large logo used for the about dialog window.

my $large_logo;

# ***** FUNCTIONAL PROTOTYPES FOR THIS FILE *****

# Private routines.

sub about_activate_cb($$);
sub advanced_find_button_clicked_cb($$);
sub annotate_button_clicked_cb($$);
sub close_toolbutton_clicked_cb($$);
sub directory_up_button_clicked_cb($$);
sub file_change_history_button_clicked_cb($$);
sub get_browser_window(;$$$$$);
sub help_toolbutton_clicked_cb($$);
sub main_window_delete_event_cb($$$);
sub manifest_browser_treeview_cursor_changed_cb($$);
sub manifest_browser_treeview_row_activated_cb($$$$);
sub monotone_viz_button_clicked_cb($$);
sub mtn_error_handler($$);
sub new_toolbutton_clicked_cb($$);
sub open_toolbutton_clicked_cb($$);
sub preferences_toolbutton_clicked_cb($$);
sub properties_toolbutton_clicked_cb($$);
sub quit_activate_cb($$);
sub revision_change_history_button_clicked_cb($$);
sub revision_change_log_button_clicked_cb($$);
sub save_as_button_clicked_cb($$);
sub search_text_button_clicked_cb($$);
sub setup_sigchld_handler($);
sub sigchld_handler();
sub update_browser_state($$);
sub view_button_clicked_cb($$);
#
##############################################################################
#
#   Routine      - Main Body Of Code
#
#   Description  - This is the main body of code for the mtn-browse script.
#
#   Data         - @_           : The command line arguments.
#                  Return Value : Unix exit code.
#
##############################################################################



{

    my($branch,
       $browser,
       $mtn,
       $revision_id);

    # Initialise stuff.

    set_locale Gtk2;
    Gnome2::Program->init("mtn-browse", 0.1);
    setup_sigchld_handler(\&sigchld_handler);
    $glade_file = LIB_PATH . "/UI/mtn-browse.glade";
    $tooltips = Gtk2::Tooltips->new();
    $mono_font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $line_image = Gtk2::Gdk::Pixbuf->new_from_file(LIB_PATH . "/UI/line.png");

    # Create the temporary working directory.

    eval
    {
	$tmp_dir = File::Temp::tempdir("mtn-browse_XXXXXXXXXX",
				       TMPDIR => 1,
				       CLEANUP => 1);
    };
    if ($@ ne "")
    {
	my $dialog = Gtk2::MessageDialog->new
	    (undef,
	     ["modal"],
	     "error",
	     "close",
	     sprintf("%s\nThis is fatal, I am going to exit.", $@));
	$dialog->run();
	$dialog->destroy();
	exit(1);
    }

    # Attempt to create an mtn handle, if it fails then assume that we are not
    # inside a workspace. However if it does work then pre-load the browser
    # with the relevant branch and revision.

    eval
    {
	$mtn = Monotone::AutomateStdio->new();
	$mtn->get_option(\$branch, "branch");
	$mtn->get_base_revision_id(\$revision_id);
    };

    # Set up the error handlers for the Monotone library.

    Monotone::AutomateStdio->register_error_handler("both",
						    \&mtn_error_handler);

    # Create the browser window and display it. Please note that updating the
    # browser to reflect the current workspace is done in an idle handler so
    # that control can be handed over to Gtk2 before updating the display.

    $browser = get_browser_window($mtn);
    if (defined($mtn))
    {
	Glib::Idle->add
	    (sub {
		 my $browser = $_[0];

		 return if ($browser->{in_cb});
		 local $browser->{in_cb} = 1;

		 $browser->{branch_combo_details}->{preset} = 1;
		 $browser->{branch_combo_details}->{value} = $branch;
		 $browser->{revision_combo_details}->{preset} = 1;
		 $browser->{revision_combo_details}->{value} = $revision_id;
		 $browser->{tagged_tick}->set_active(FALSE);
		 &{$browser->{update_handler}}($browser, ALL_CHANGED);

		 return FALSE;
	     },
	     $browser);
	$mtn = undef;
    }

    # Hand control over to Gtk2.

    Gtk2->main();

    # Cleanup.

    WindowManager->instance()->cleanup();
    Gnome2::VFS->shutdown();
    $SIG{CHLD} = "IGNORE";

    exit(0);

}
#
##############################################################################
#
#   Routine      - quit_activate_cb
#
#   Description  - Callback routine called when the user selects the quit file
#                  menu option.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub quit_activate_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Hide all the windows, close all the database handles and then exit Gtk2.

    WindowManager->instance()->cond_find
	(undef,
	 sub {
	     my $instance = $_[0];
	     $instance->{window}->hide() if ($instance->{window}->mapped());
	     $instance->{mtn} = undef if (exists($instance->{mtn}));
	     return;
	 });
    Gtk2->main_quit();

}
#
##############################################################################
#
#   Routine      - about_activate_cb
#
#   Description  - Callback routine called when the user selects the about
#                  help menu option.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub about_activate_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    $large_logo = Gtk2::Gdk::Pixbuf->new_from_file
	(LIB_PATH . "/UI/mtn-browse-large.png")
	if (! defined($large_logo));
    Gnome2::About->new
	("mtn-browse",
	 "0.1b",
	 "Copyright \xa9 2007-2009 Anthony Cooper",
	 "A graphical front-end browser for Monotone VCS databases",
	 ["Anthony Cooper <support\@coosoft.plus.com>"],
	 "TBD",
	 "TBD",
	 $large_logo)->run();

}
#
##############################################################################
#
#   Routine      - new_toolbutton_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  new toolbutton in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub new_toolbutton_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Simply get a new/unused browser window and display it.

    get_browser_window();

}
#
##############################################################################
#
#   Routine      - open_toolbutton_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  open toolbutton in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub open_toolbutton_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($chooser_dialog,
       $done);

    $chooser_dialog = Gtk2::FileChooserDialog->new("Open Database",
						   $browser->{window},
						   "open",
						   "gtk-cancel" => "cancel",
						   "gtk-open" => "ok");

    do
    {
	if ($chooser_dialog->run() eq "ok")
	{

	    my ($err,
		$fh,
		$file_name,
		$mtn);

	    $file_name = $chooser_dialog->get_filename();

	    # The user has selected a file. First make sure we can open it for
	    # reading (I know I could use the -r test but this takes care of
	    # any other unforeseen access problems as well).

	    if (! defined($fh = IO::File->new($file_name, "r")))
	    {
		my $dialog = Gtk2::MessageDialog->new
		    ($browser->{window},
		     ["modal"],
		     "warning",
		     "close",
		     $!);
		$dialog->run();
		$dialog->destroy();
	    }
	    else
	    {

		$fh->close();
		$fh = undef;

		# Ok it is a readable file, try and open it but deal with any
		# errors in a nicer way than normal.

		Monotone::AutomateStdio->register_error_handler("both");
		eval
		{
		    $mtn = Monotone::AutomateStdio->new($file_name);
		};
		$err = $@;
		Monotone::AutomateStdio->register_error_handler
		    ("both", \&mtn_error_handler);
		if ($err ne "")
		{
		    my $dialog = Gtk2::MessageDialog->new
			($browser->{window},
			 ["modal"],
			 "warning",
			 "close",
			 "Not a valid Monotone database");
		    $dialog->run();
		    $dialog->destroy();
		}
		else
		{

		    # Seems to be ok so update the browser with the new
		    # database.

		    $browser->{mtn} = $mtn;
		    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);
		    $done = 1;

		}

	    }

	}
	else
	{
	    $done = 1;
	}
    }
    while (! $done);

    $chooser_dialog->destroy();

}
#
##############################################################################
#
#   Routine      - close_toolbutton_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  close toolbutton in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub close_toolbutton_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Simply reset the browser's Monotone instance and update its display.

    $browser->{mtn} = undef;
    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);

}
#
##############################################################################
#
#   Routine      - properties_toolbutton_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  properties toolbutton in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub properties_toolbutton_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my $dialog = Gtk2::MessageDialog->new($browser->{window},
					  ["modal"],
					  "info",
					  "close",
					  "Not implemented");
    $dialog->run();
    $dialog->destroy();

}
#
##############################################################################
#
#   Routine      - preferences_toolbutton_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  preferences toolbutton in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub preferences_toolbutton_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my $dialog = Gtk2::MessageDialog->new($browser->{window},
					  ["modal"],
					  "info",
					  "close",
					  "Not implemented");
    $dialog->run();
    $dialog->destroy();

}
#
##############################################################################
#
#   Routine      - help_toolbutton_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  help toolbutton in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub help_toolbutton_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my $dialog = Gtk2::MessageDialog->new($browser->{window},
					  ["modal"],
					  "info",
					  "close",
					  "Not implemented");
    $dialog->run();
    $dialog->destroy();

}
#
##############################################################################
#
#   Routine      - tagged_checkbutton_toggled_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  the tagged check button.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub tagged_checkbutton_toggled_cb($$)
{

    my($widget, $instance) = @_;

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    $instance->{appbar}->clear_stack();
    &{$instance->{update_handler}}($instance, BRANCH_CHANGED);

}
#
##############################################################################
#
#   Routine      - advanced_find_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  advanced find button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub advanced_find_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my(@branches,
       $preset_branch,
       $revision_id,
       $state);

    if (advanced_find($browser, \$revision_id, \@branches))
    {

	# Preset branch name. If we already have a selected branch then try and
	# match branch names, if that fails then just pick the first name.

	$preset_branch = 1;
	$state = BRANCH_CHANGED;
	if ($browser->{branch_combo_details}->{complete})
	{
	    foreach my $name (@branches)
	    {
		if ($name eq $browser->{branch_combo_details}->{value})
		{
		    $preset_branch = 0;
		    last;
		}
	    }
	}
	if ($preset_branch)
	{
	    $browser->{branch_combo_details}->{preset} = 1;
	    $browser->{branch_combo_details}->{value} = $branches[0];
	    $state = ALL_CHANGED;
	}

	# Preset revision id.

	$browser->{revision_combo_details}->{preset} = 1;
	$browser->{revision_combo_details}->{value} = $revision_id;

	# A revision id is what is returned so switch off the listing of tag
	# names.

	$browser->{tagged_tick}->set_active(FALSE);

	&{$browser->{update_handler}}($browser, $state);

    }

}
#
##############################################################################
#
#   Routine      - revision_change_history_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  revision change history button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub revision_change_history_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    get_revision_ids($browser, \@revision_ids);
    display_revision_change_history($browser->{mtn}, $revision_ids[0]);

}
#
##############################################################################
#
#   Routine      - revision_change_log_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  revision change log button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub revision_change_log_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    # Get the currently selected revision id and then display its change log.

    get_revision_ids($browser, \@revision_ids);
    display_change_log($browser->{mtn},
		       $revision_ids[0],
		       "",
		       $browser->{revision_combo_details}->{value});

}
#
##############################################################################
#
#   Routine      - monotone_viz_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  monotone-viz button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub monotone_viz_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($cmd,
       $db_name);

    # Build up the monotone-viz command, we need the database name and then
    # optionally the branch and revision ids.

    $cmd = "monotone-viz ";
    if (! defined($db_name = $browser->{mtn}->get_db_name()))
    {
	$browser->{mtn}->get_option(\$db_name, "database");
    }
    $cmd .= $db_name;
    if ($browser->{branch_combo_details}->{complete})
    {
	$cmd .= " " . $browser->{branch_combo_details}->{value};
	if ($browser->{revision_combo_details}->{complete})
	{
	    $cmd .= " " . $browser->{revision_combo_details}->{value};
	}
    }

    # Launch Monotone-Viz.

    system($cmd . " &");

}
#
##############################################################################
#
#   Routine      - directory_up_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the up
#                  directory button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub directory_up_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($len,
       $old_len,
       $value);

    # Simply go up one directory level in the manifest if we aren't already at
    # the top.

    $value = $browser->{directory_combo_details}->{value};
    if ($value ne "")
    {
	$old_len = length($value);
	$value = dirname($value);
	$value = "" if ($value eq ".");
	$browser->{directory_combo_details}->{value} = $value;
	$browser->{directory_combo_details}->{complete} = 1;
	$len = length($value);
	if ($len < $old_len)
	{
	    $browser->{directory_combo}->get_model()->clear();
	    foreach my $item (@{$browser->{directory_combo_details}->{list}})
	    {
		$browser->{directory_combo}->append_text($item)
		    if ($value eq substr($item, 0, $len));
	    }
	}
	$browser->{directory_combo}->child()->set_text($value);
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - search_text_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the search
#                  text button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub search_text_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    find_text($browser->{window}, $browser->{file_view_sv});

}
#
##############################################################################
#
#   Routine      - save_as_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the save as
#                  button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub save_as_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($chooser_dialog,
       $continue,
       $done);

    $chooser_dialog = Gtk2::FileChooserDialog->new("Save As",
						   $browser->{window},
						   "save",
						   "gtk-cancel" => "cancel",
						   "gtk-save" => "ok");
    $chooser_dialog->set_current_name
	($browser->{file_being_viewed}->{short_name});

    do
    {
	if ($chooser_dialog->run() eq "ok")
	{

	    my ($data,
		$fh,
		$file_name);

	    $continue = 1;
	    $file_name = $chooser_dialog->get_filename();

	    # See if the file exists, if so then get a confirmation from the
	    # user.

	    if (-e $file_name)
	    {
		my $dialog = Gtk2::MessageDialog->new
		    ($browser->{window},
		     ["modal"],
		     "question",
		     "yes-no",
		     "File already exists.\nDo you want to replace it?");
		$dialog->set_title("Confirm");
		$continue = 0 if ($dialog->run() ne "yes");
		$dialog->destroy();
	    }

	    if ($continue)
	    {

		# Attempt to save the contents to the file.

		if (! defined($fh = IO::File->new($file_name, "w")))
		{
		    my $dialog = Gtk2::MessageDialog->new
			($browser->{window},
			 ["modal"],
			 "warning",
			 "close",
			 $!);
		    $dialog->run();
		    $dialog->destroy();
		}
		else
		{
		    $browser->{mtn}->get_file(\$data,
					      $browser->{file_being_viewed}->
						  {manifest_entry}->{file_id});
		    $fh->print($data);
		    $fh->close();
		    $done = 1;
		}

	    }

	}
	else
	{
	    $done = 1;
	}
    }
    while (! $done);

    $chooser_dialog->destroy();

}
#
##############################################################################
#
#   Routine      - view_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the view
#                  button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub view_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($data,
       $editor,
       $fh,
       $file_name);

    if (! defined($file_name =
		  generate_tmp_path($browser->{file_being_viewed}->
				    {short_name})))
    {
	my $dialog = Gtk2::MessageDialog->new
	    ($browser->{window},
	     ["modal"],
	     "warning",
	     "Cannot generate temporary file name",
	     $!);
	$dialog->run();
	$dialog->destroy();
	return;
    }

    # Attempt to save the contents to the file.

    if (! defined($fh = IO::File->new($file_name, "w")))
    {
	my $dialog = Gtk2::MessageDialog->new
	    ($browser->{window},
	     ["modal"],
	     "warning",
	     "close",
	     $!);
	$dialog->run();
	$dialog->destroy();
	return;
    }
    $browser->{mtn}->get_file(\$data,
			      $browser->{file_being_viewed}->
			          {manifest_entry}->{file_id});
    $fh->print($data);
    $fh->close();
    $fh = undef;

    # Load into an editor.

    if (exists($ENV{EDITOR})
	&& ($ENV{EDITOR} eq "emacs"
	    || $ENV{EDITOR} eq "xemacs"
	    || $ENV{EDITOR} eq "gvim"))
    {
	$editor = $ENV{EDITOR};
    }
    else
    {
	$editor = "xterm -e vi";
    }
    system($editor . " " . $file_name . " &");

}
#
##############################################################################
#
#   Routine      - annotate_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  annotate button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub annotate_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    get_revision_ids($browser, \@revision_ids);
    display_annotation($browser->{mtn},
		       $revision_ids[0],
		       $browser->{file_being_viewed}->{manifest_entry}->
		           {name});

}
#
##############################################################################
#
#   Routine      - file_change_history_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the file
#                  change history button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub file_change_history_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    get_revision_ids($browser, \@revision_ids);
    display_file_change_history($browser->{mtn},
				$revision_ids[0],
				$browser->{file_being_viewed}->
				    {manifest_entry}->{name});

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user selects an entry in
#                  the manifest treeview in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub manifest_browser_treeview_cursor_changed_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($manifest_entry,
       $short_name);

    # Get the manifest entry details for the item that was selected.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a file then display its contents, otherwise if it is a
    # directory then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "file")
    {
	$browser->{file_being_viewed} = {short_name     => $short_name,
					 manifest_entry => $manifest_entry};
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, FILE_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user double clicks on an
#                  entry in the manifest treeview in a main browser window.
#
#   Data         - $widget           : The widget object that received the
#                                      signal.
#                  $tree_path        : A Gtk2::TreePath object for the
#                                      selected item.
#                  $tree_view_column : A Gtk2::TreeViewColumn object for the
#                                      selected item.
#                  $browser          : The browser instance that is associated
#                                      with this widget.
#
##############################################################################



sub manifest_browser_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($manifest_entry,
       $short_name);

    # Get the manifest entry details for the item that was double-clicked.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a directory then change to it, otherwise if it is a file
    # then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "directory")
    {
	$browser->{directory_combo_details}->{value} = $manifest_entry->{name};
	$browser->{directory_combo_details}->{complete} = 1;
	$browser->{directory_combo}->child()->
	    set_text($manifest_entry->{name});
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - main_window_delete_event_cb
#
#   Description  - Callback routine called when a main window is about to be
#                  dismissed.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $client_data : The client data associated with this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub main_window_delete_event_cb($$$)
{

    my($widget, $event, $browser) = @_;

    return TRUE if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my $others_mapped;

    # Only exit if this is the only browser window currently being shown.

    $others_mapped = 0;
    WindowManager->instance()->cond_find
	($window_type,
	 sub {
	     my $instance = $_[0];
	     if ($instance != $browser && $instance->{window}->mapped())
	     {
		 $others_mapped = 1;
		 return 1;
	     }
	     return;
	 });

    $browser->{window}->hide();
    $browser->{mtn} = undef;
    $browser->{branch_combo_details}->{preset} = 0;
    $browser->{revision_combo_details}->{preset} = 0;
    $browser->{directory_combo_details}->{preset} = 0;
    $browser->{file_being_viewed_preset_value} = "";
    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);

    Gtk2->main_quit() unless ($others_mapped);

    return TRUE;

}
#
##############################################################################
#
#   Routine      - get_browser_window
#
#   Description  - Creates or prepares an existing browser window for use.
#
#   Data         - $mtn         : The Monotone instance handle that is to be
#                                 used for the browser window. If it is undef
#                                 then no database is used and a blank browser
#                                 window is displayed.
#                  $branch      : The branch name that is to be preselected in
#                                 the browser window. This is optional unless
#                                 any of the following arguments are
#                                 specified.
#                  $revision_id : The revision id that is to be preselected in
#                                 the browser window. This is optional unless
#                                 any of the following arguments are
#                                 specified.
#                  $directory   : The directory that is to be preselected in
#                                 the browser window. This is optional unless
#                                 the following argument is specified.
#                  $file        : The file that is to be displayed in the
#                                 browser window. This is optional.
#                  Return Value : A reference to the newly created or unused
#                                 browser instance record.
#
##############################################################################



sub get_browser_window(;$$$$$)
{

    my($mtn, $branch, $revision_id, $directory, $file) = @_;

    my $browser;
    my $wm = WindowManager->instance();

    # Create a new browser window if an unused one wasn't found, otherwise
    # reuse an existing unused one.

    if (! defined($browser = $wm->find_unused($window_type)))
    {

	my($image,
	   $renderer,
	   $tv_column);

	$browser = {};
	$browser->{mtn} = $mtn;
	$browser->{glade} = Gtk2::GladeXML->new($glade_file, $window_type);

	# Flag to stop recursive calling of callbacks.

	$browser->{in_cb} = 0;

	# Connect Glade registered signal handlers.

	glade_signal_autoconnect($browser->{glade}, $browser);

	# Link in the update handler for the browser.

	$browser->{update_handler} = \&update_browser_state;

	# Get the widgets that we are interested in.

	$browser->{window} = $browser->{glade}->get_widget($window_type);
	$browser->{appbar} = $browser->{glade}->get_widget("appbar");
	$browser->{main_vbox} = $browser->{glade}->get_widget("main_vbox");
	$browser->{close_toolbutton} =
	    $browser->{glade}->get_widget("close_toolbutton");
	$browser->{properties_toolbutton} =
	    $browser->{glade}->get_widget("properties_toolbutton");
	$browser->{branch_combo} =
	    $browser->{glade}->get_widget("branch_comboboxentry");
	$browser->{revision_combo} =
	    $browser->{glade}->get_widget("revision_comboboxentry");
	$browser->{tagged_tick} =
	    $browser->{glade}->get_widget("tagged_checkbutton");
	$browser->{directory_combo} =
	    $browser->{glade}->get_widget("directory_comboboxentry");
	$browser->{directory_up_button} =
	    $browser->{glade}->get_widget("directory_up_button");
	$browser->{manifest_treeview} =
	    $browser->{glade}->get_widget("manifest_browser_treeview");
	$browser->{file_view_scrolledwindow} =
	    $browser->{glade}->get_widget("file_view_scrolledwindow");
	$browser->{file_name_label} =
	    $browser->{glade}->get_widget("file_name_value_label");
	$browser->{file_id_label} =
	    $browser->{glade}->get_widget("file_id_value_label");
	$browser->{last_update_label} =
	    $browser->{glade}->get_widget("last_update_value_label");
	$browser->{file_revision_id_label} =
	    $browser->{glade}->get_widget("file_revision_id_value_label");
	$browser->{file_button_vbox} =
	    $browser->{glade}->get_widget("file_button_vbox");
	$browser->{database_name_label} =
	    $browser->{glade}->get_widget("database_name_value_label");
	$browser->{revision_id_label} =
	    $browser->{glade}->get_widget("revision_id_value_label");
	$browser->{author_label} =
	    $browser->{glade}->get_widget("author_value_label");
	$browser->{change_log_label} =
	    $browser->{glade}->get_widget("change_log_value_label");

	# Setup button sensitivity groups.

	$browser->{text_file_sensitive_group} = ();
	foreach my $item ("search_text", "annotate")
	{
	    push(@{$browser->{text_file_sensitive_group}},
		 $browser->{glade}->get_widget($item . "_button"));
	}
	$browser->{revision_sensitive_group} = ();
	foreach my $item ("revision_change_history", "revision_change_log")
	{
	    push(@{$browser->{revision_sensitive_group}},
		 $browser->{glade}->get_widget($item . "_button"));
	}

	# Setup the comboboxentry key release signal handlers.

	$browser->{branch_combo}->child()->
	    signal_connect("key_release_event",
			   \&combo_key_release_event_cb,
			   $browser);
	$browser->{directory_combo}->child()->
	    signal_connect("key_release_event",
			   \&combo_key_release_event_cb,
			   $browser);
	$browser->{revision_combo}->child()->
	    signal_connect("key_release_event",
			   \&combo_key_release_event_cb,
			   $browser);

	# Setup the comboboxes.

	$browser->{branch_combo}->
	    set_model(Gtk2::ListStore->new("Glib::String"));
	$browser->{branch_combo}->set_text_column(0);
	$browser->{branch_combo}->set_wrap_width(2);
	$browser->{directory_combo}->
	    set_model(Gtk2::ListStore->new("Glib::String"));
	$browser->{directory_combo}->set_text_column(0);
	$browser->{directory_combo}->set_wrap_width(2);
	$browser->{revision_combo}->
	    set_model(Gtk2::ListStore->new("Glib::String"));
	$browser->{revision_combo}->set_text_column(0);
	$browser->{revision_combo}->set_wrap_width(2);

	# Setup the tree view manifest file browser.

	$browser->{manifest_liststore} = Gtk2::ListStore->new("Glib::String",
							      "Glib::String",
							      "Glib::String",
							      "Glib::String",
							      "Glib::Scalar");
	$browser->{manifest_treeview}->
	    set_model($browser->{manifest_liststore});

	$tv_column = Gtk2::TreeViewColumn->new();
	$image = Gtk2::Image->new_from_stock("gtk-file", "menu");
	$image->show_all();
	$tv_column->set_widget($image);
	$tv_column->set_resizable(FALSE);
	$tv_column->set_sizing("fixed");
	$tv_column->set_fixed_width(25);
	$tv_column->set_sort_column_id(MLS_ICON_COLUMN);
	$renderer = Gtk2::CellRendererPixbuf->new();
	$tv_column->pack_start($renderer, TRUE);
	$tv_column->set_attributes($renderer, "stock-id" => MLS_ICON_COLUMN);
	$browser->{manifest_treeview}->append_column($tv_column);

	$tv_column = Gtk2::TreeViewColumn->new();
	$tv_column->set_title("File Name");
	$tv_column->set_resizable(TRUE);
	$tv_column->set_sizing("fixed");
	$tv_column->set_fixed_width(180);
	$tv_column->set_sort_column_id(MLS_NAME_COLUMN);
	$renderer = Gtk2::CellRendererText->new();
	$tv_column->pack_start($renderer, FALSE);
	$tv_column->set_attributes($renderer, "text" => MLS_NAME_COLUMN);
	$browser->{manifest_treeview}->append_column($tv_column);

	$tv_column = Gtk2::TreeViewColumn->new();
	$tv_column->set_title("Last Update");
	$tv_column->set_resizable(TRUE);
	$tv_column->set_sizing("grow-only");
	$tv_column->set_sort_column_id(MLS_DATE_COLUMN);
	$renderer = Gtk2::CellRendererText->new();
	$tv_column->pack_start($renderer, FALSE);
	$tv_column->set_attributes($renderer, "text" => MLS_DATE_COLUMN);
	$browser->{manifest_treeview}->append_column($tv_column);

	$tv_column = Gtk2::TreeViewColumn->new();
	$tv_column->set_title("Author");
	$tv_column->set_resizable(TRUE);
	$tv_column->set_sizing("grow-only");
	$tv_column->set_sort_column_id(MLS_AUTHOR_COLUMN);
	$renderer = Gtk2::CellRendererText->new();
	$tv_column->pack_start($renderer, FALSE);
	$tv_column->set_attributes($renderer, "text" => MLS_AUTHOR_COLUMN);
	$browser->{manifest_treeview}->append_column($tv_column);

	$browser->{manifest_treeview}->set_search_column(MLS_NAME_COLUMN);

	# $tv_column =
	#     $browser->{manifest_treeview}->get_column(MLS_DATE_COLUMN);
	# $browser->{manifest_treeview}->remove_column($tv_column);

	# Setup the file file viewer (with syntax highlighting).

	$browser->{file_view_svbuffer} = Gtk2::SourceView::Buffer->new(undef);
	$browser->{file_view_svbuffer}->set_max_undo_levels(0);
	$browser->{file_view_svbuffer}->begin_not_undoable_action();
	$browser->{file_view_svlangmgr} =
	    Gtk2::SourceView::LanguagesManager->new();
	$browser->{file_view_sv} = Gtk2::SourceView::View->
	    new_with_buffer($browser->{file_view_svbuffer});
	$browser->{file_view_sv}->modify_font($mono_font);
	$browser->{file_view_sv}->set_cursor_visible(FALSE);
	$browser->{file_view_sv}->set_editable(FALSE);
	$browser->{glade}->get_widget("file_view_scrolledwindow")->
	    add($browser->{file_view_sv});
	$browser->{file_view_sv}->show_all();

	$browser->{window}->show_all();

	# Register the window for management.

	$wm->manage($browser, $window_type);
	$wm->add_busy_widgets($browser,
			      $browser->{file_view_sv}->get_window("text"));

	# Update the browser's internal state.

	$browser->{branch_combo_details}->{preset} = 0;
	$browser->{revision_combo_details}->{preset} = 0;
	$browser->{directory_combo_details}->{preset} = 0;
	$browser->{file_being_viewed_preset_value} = "";
	&{$browser->{update_handler}}($browser, DATABASE_CHANGED);

    }
    else
    {

	my($height,
	   $width);

	$browser->{in_cb} = 0;
	local $browser->{in_cb} = 1;

	# Reset the browser's state.

	($width, $height) = $browser->{window}->get_default_size();
	$browser->{window}->resize($width, $height);
	$browser->{glade}->get_widget("browser_hpaned")->set_position(300);
	$browser->{tagged_tick}->set_active(FALSE);
	$browser->{window}->show_all();

	# Now update with the details of the specified database.

	if (defined($mtn))
	{
	    $browser->{mtn} = $mtn;
	    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);
	}

    }

    # Now deal with any presetting that is required.

    if (defined($branch))
    {
	local $browser->{in_cb} = 1;
	$browser->{branch_combo_details}->{preset} = 1;
	$browser->{branch_combo_details}->{value} = $branch;
	if (defined($revision_id))
	{
	    $browser->{revision_combo_details}->{preset} = 1;
	    $browser->{revision_combo_details}->{value} = $revision_id;
	    if (defined($directory))
	    {
		$browser->{directory_combo_details}->{preset} = 1;
		$browser->{directory_combo_details}->{value} = $directory;
		if (defined($file))
		{
		    $browser->{file_being_viewed_preset_value} = $file;
		}
	    }
	}
	&{$browser->{update_handler}}($browser, ALL_CHANGED);
    }

    # Make sure that the branch comboboxentry has the focus and not the bonobo
    # dock.

    $browser->{branch_combo}->child()->grab_focus();
    $browser->{branch_combo}->child()->set_position(-1);

    return $browser;

}
#
##############################################################################
#
#   Routine      - update_browser_state
#
#   Description  - Update the display of the specified browser instance
#                  according to the specified state.
#
#   Data         - $browser : The browser instance that is to have its state
#                             updated.
#                  $changed : What the user has changed.
#
##############################################################################



sub update_browser_state($$)
{

    my($browser, $changed) = @_;

    my $wm = WindowManager->instance();

    $wm->make_busy($browser, 1);
    $browser->{appbar}->push("");
    gtk2_update();

    # The database has changed.

    if ($changed & BRANCH)
    {

	my $db_name;

	if (! defined($browser->{mtn}))
	{

	    # Disable the browser as no database is associated with it.

	    $browser->{close_toolbutton}->set_sensitive(FALSE);
	    $browser->{properties_toolbutton}->set_sensitive(FALSE);
	    $browser->{main_vbox}->set_sensitive(FALSE);
	    set_label_value($browser->{database_name_label}, "");

	}
	else
	{

	    # Enable the browser as there is a database associated with it.

	    $browser->{close_toolbutton}->set_sensitive(TRUE);
	    $browser->{properties_toolbutton}->set_sensitive(TRUE);
	    $browser->{main_vbox}->set_sensitive(TRUE);
	    if (! defined($browser->{mtn}->get_db_name()))
	    {
		$browser->{mtn}->get_option(\$db_name, "database");
		set_label_value($browser->{database_name_label},
				sprintf("<WorkSpace> (%s)", $db_name));
	    }
	    else
	    {
		set_label_value($browser->{database_name_label},
				$browser->{mtn}->get_db_name());
	    }

	    # Make sure that the branch comboboxentry has the focus and not the
	    # bonobo dock.

	    $browser->{branch_combo}->child()->grab_focus();
	    $browser->{branch_combo}->child()->set_position(-1);

	}

    }

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the branch selection.

	$browser->{branch_combo_details}->{completion} = undef;
	if ($browser->{branch_combo_details}->{preset})
	{
	    $browser->{branch_combo_details}->{complete} = 1;
	    $browser->{branch_combo_details}->{preset} = 0;
	}
	else
	{
	    $browser->{branch_combo_details}->{complete} = 0;
	    $browser->{branch_combo_details}->{value} = "";
	}

	# Get the new list of branches.

	$browser->{appbar}->set_status("Fetching branch list");
	gtk2_update();
	$browser->{mtn}->branches(\@branch_list) if (defined($browser->{mtn}));
	$browser->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$browser->{appbar}->set_status("Populating branch list");
	gtk2_update();
	my $counter = 1;
	$browser->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $browser->{branch_combo}->append_text($branch);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@branch_list));
	    gtk2_update();
	}
	$browser->{branch_combo}->child()->
	    set_text($browser->{branch_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$browser->{revision_combo_details}->{completion} = undef;
	if ($browser->{revision_combo_details}->{preset})
	{
	    $browser->{revision_combo_details}->{complete} = 1;
	    $browser->{revision_combo_details}->{preset} = 0;
	}
	else
	{
	    $browser->{revision_combo_details}->{complete} = 0;
	    $browser->{revision_combo_details}->{value} = "";
	}

	# Get the new list of revisions.

	if ($browser->{branch_combo_details}->{complete})
	{
	    $browser->{appbar}->set_status("Fetching revision list");
	    gtk2_update();

	    # Get either a list of tags or revision ids depending upon what the
	    # user has chosen.

	    if ($browser->{tagged_tick}->get_active())
	    {
		my(%dup_list,
		   @list);
		$browser->{mtn}->
		    tags(\@list, $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.5);
		gtk2_update();
		foreach my $item (@list)
		{
		    if (! exists($dup_list{$item->{tag}}))
		    {
			push(@revision_list, $item->{tag});
			$dup_list{$item->{tag}} = 1;
		    }
		}
	    }
	    else
	    {
		$browser->{mtn}->
		    select(\@revision_list,
			   "b:" . $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.33);
		gtk2_update();
		$browser->{mtn}->toposort(\@revision_list, @revision_list);
		$browser->{appbar}->set_progress_percentage(0.66);
		gtk2_update();
		splice(@revision_list, 0, scalar(@revision_list) - 100);
		@revision_list = reverse(@revision_list);
	    }
	    $browser->{appbar}->set_progress_percentage(1);
	    gtk2_update();
	}
	$browser->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating revision list");
	gtk2_update();
	my $counter = 1;
	$browser->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $browser->{revision_combo}->append_text($revision);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_list));
	    gtk2_update();
	}
	$browser->{revision_combo}->child()->
	    set_text($browser->{revision_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available files and directories has changed.

    if ($changed & DIRECTORY)
    {

	my(@directory_list,
	   @manifest_list);

	# Reset the directory combo.

	$browser->{directory_combo_details}->{completion} = undef;
	if ($browser->{directory_combo_details}->{preset})
	{
	    $browser->{directory_combo_details}->{complete} = 1;
	    $browser->{revision_combo_details}->{preset} = 0;
	}
	else
	{
	    $browser->{directory_combo_details}->{complete} = 0;
	    $browser->{directory_combo_details}->{value} = "";
	}
	set_label_value($browser->{revision_id_label}, "");
	set_label_value($browser->{author_label}, "");
	set_label_value($browser->{change_log_label}, "");

	# Reset the name of the file being viewed.

	$browser->{file_being_viewed} = {};

	# Get the new manifest.

	$browser->{appbar}->set_status("Fetching manifest");
	gtk2_update();
	if ($browser->{revision_combo_details}->{complete})
	{
	    my @revision_ids;
	    get_revision_ids($browser, \@revision_ids);
	    if (scalar(@revision_ids) > 1)
	    {
		my $message;
		$message =
		    sprintf("The `%s' tag is not unique on this branch.\n"
			        . "Please either select the revision by its "
			            . "id\n"
			        . "or use the <i>Advanced Find</i> feature.\n"
			        . "The matching revision ids are:",
			    $browser->{revision_combo_details}->{value});
		foreach my $item (@revision_ids)
		{
		    $message .= "\n" . Glib::Markup::escape_text($item);
		}
		my $dialog = Gtk2::MessageDialog->new_with_markup
		    ($browser->{window}, ["modal"], "info", "close", $message);
		$dialog->run();
		$dialog->destroy();
		$browser->{revision_combo_details}->{complete} = 0;
		$browser->{revision_combo_details}->{value} = "";
		$browser->{revision_combo}->child()->set_text("");
	    }
	    else
	    {
		my($author,
		   @certs_list,
		   $change_log);
		$browser->{mtn}->get_manifest_of(\@manifest_list,
						 $revision_ids[0]);
		$browser->{mtn}->certs(\@certs_list, $revision_ids[0]);
		$author = $change_log = "";
		foreach my $cert (@certs_list)
		{
		    $author = $cert->{value}
		        if ($cert->{name} eq "author");
		    if ($cert->{name} eq "changelog")
		    {
			$change_log = $cert->{value};
			$change_log =~ s/\s+$//os;
		    }
		}
		set_label_value($browser->{revision_id_label},
				$revision_ids[0]);
		set_label_value($browser->{author_label}, $author);
		set_label_value($browser->{change_log_label}, $change_log);
	    }
	}
	$browser->{manifest} = \@manifest_list;

	# Generate a simple list of directories for auto completion.

	$browser->{appbar}->set_progress_percentage(0.5);
	gtk2_update();
	foreach my $item (@manifest_list)
	{
	    push(@directory_list, $item->{name})
		if ($item->{type} eq "directory");
	}
	$browser->{directory_combo_details}->{list} = \@directory_list;
	$browser->{appbar}->set_progress_percentage(1);
	gtk2_update();

	# Update the directory list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating directory list");
	gtk2_update();
	my $counter = 1;
	$browser->{directory_combo}->get_model()->clear();
	foreach my $item (@directory_list)
	{
	    $browser->{directory_combo}->append_text($item);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@directory_list));
	    gtk2_update();
	}
	$browser->{directory_combo}->child()->
	    set_text($browser->{directory_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	foreach my $widget (@{$browser->{revision_sensitive_group}})
	{
	    $widget->
		set_sensitive($browser->{revision_combo_details}->{complete});
	}
	gtk2_update();

    }

    # The list of displayed files and directories has changed.

    if ($changed & DIRECTORY_VIEW)
    {

	my($author,
	   @certs_list,
	   $counter,
	   @directory_entry_list,
	   $last_update,
	   @revision_ids,
	   @revision_list,
	   $taking_our_time);

	# Reset the manifest tree view.

	$browser->{manifest_liststore}->clear();

	# Get the contents of the new directory.

	if ($browser->{directory_combo_details}->{complete}
	    || $browser->{directory_combo_details}->{value} eq "")
	{
	    get_dir_contents($browser->{directory_combo_details}->{value},
			     $browser->{manifest},
			     \@directory_entry_list);
	}

	# Disable the directory up button if we are already at the top level,
	# otherwise make sure it is enabled.

	$browser->{directory_up_button}->set_sensitive
	    (($browser->{directory_combo_details}->{value} eq "")
	     ? FALSE : TRUE);

	# Update the directory tree view.

	$browser->{appbar}->set_status("Populating file details");
	$counter = 1;
	$taking_our_time = 0;
	get_revision_ids($browser, \@revision_ids);
	foreach my $item (@directory_entry_list)
	{

	    # Get the latest modification time and the author if the entry is a
	    # file (caching the result in the manifest for future reference if
	    # we have to work it out).

	    if ($item->{manifest_entry}->{type} eq "file")
	    {
		if (! exists($item->{manifest_entry}->{author}))
		{
		    $taking_our_time = 1;
		    $browser->{mtn}->get_content_changed
			(\@revision_list,
			 $revision_ids[0],
			 $item->{manifest_entry}->{name});
		    $item->{manifest_entry}->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    $author = $last_update = "";
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "author")
			{
			    $author = $cert->{value};
			    $item->{manifest_entry}->{author} = $author;
			}
			if ($cert->{name} eq "date")
			{
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $item->{manifest_entry}->{last_update} =
				$last_update;
			}
			last if ($author ne "" && $last_update ne "");
		    }
		}
		else
		{
		    $author = $item->{manifest_entry}->{author};
		    $last_update = $item->{manifest_entry}->{last_update};
		}
	    }
	    else
	    {
		$author = "";
		$last_update = "";
	    }

	    # Put the entry into the liststore.

	    $browser->{manifest_liststore}->
		set($browser->{manifest_liststore}->append(),
		    MLS_ICON_COLUMN,
		        ($item->{manifest_entry}->{type} eq "directory")
		        ? "gtk-open" : "gtk-file",
		    MLS_NAME_COLUMN, $item->{name},
		    MLS_DATE_COLUMN, $last_update,
		    MLS_AUTHOR_COLUMN, $author,
		    MLS_MANIFEST_ENTRY_COLUMN, $item->{manifest_entry});

	    if ($browser->{file_being_viewed_preset_value} ne ""
		&& $browser->{file_being_viewed_preset_value} eq $item->{name})
	    {
		$browser->{file_being_viewed} =
		    {short_name     => $item->{name},
		     manifest_entry => $item->{manifest_entry}};
		$browser->{file_being_viewed_preset_value} = "";
	    }

	    if ($taking_our_time)
	    {
		$browser->{appbar}->set_progress_percentage
		    ($counter / scalar(@directory_entry_list));
		gtk2_update();
	    }
	    ++ $counter;

	}

	$browser->{manifest_treeview}->scroll_to_point(0, 0)
	    if ($browser->{manifest_treeview}->realized());

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The displayed file contents has changed.

    if ($changed & DISPLAY_OF_FILE)
    {

	# Load up the selected file's contents into the file viewer.

	if (exists($browser->{file_being_viewed}->{manifest_entry}))
	{

	    my $manifest_entry;
	    $manifest_entry =
		$browser->{file_being_viewed}->{manifest_entry};

	    # Only do anything if the selected file has changed.

	    if ($browser->{file_id_label}->get_text()
		ne $manifest_entry->{file_id})
	    {

		my($contents,
		   $lang,
		   $mime_type,
		   $scrolled_window);

		# Reset the file view buffer and the associated find text
		# window.

		$browser->{file_button_vbox}->set_sensitive(TRUE);
		foreach my $widget (@{$browser->{text_file_sensitive_group}})
		{
		    $widget->set_sensitive(FALSE);
		}
		$browser->{file_view_svbuffer}->
		    place_cursor($browser->{file_view_svbuffer}->
				 get_start_iter());
		$browser->{file_view_svbuffer}->set_text("");
		$browser->{file_view_svbuffer}->set("highlight", FALSE);
		reset_find_text($browser->{file_view_sv});
		disable_find_text($browser->{file_view_sv}, 1);

		# Get contents.

		$browser->{mtn}->get_file(\$contents,
					  $manifest_entry->{file_id});

		# Try and work out the mime type, first based on contents and
		# then based on the file name extension.

		if (! defined($mime_type =
			      Gnome2::VFS->get_mime_type_for_data($contents))
		    || $mime_type eq "text/plain")
		{
		    my $name = $browser->{file_being_viewed}->{short_name};
		    foreach my $item (@text_mime_types)
		    {
			if ($name =~ m/$item->{pattern}/)
			{
			    $mime_type = $item->{type};
			    last;
			}
		    }
		}

		# Override some mis-identified types.

		$mime_type = "image/svg+xml"
		    if ($mime_type eq "text/xml"
			&& $browser->{file_being_viewed}->{short_name}
			    =~ m/.*\.svg$/o);

		# If it's image data then attempt to render it.

		if ($mime_type =~ m/^image\/.+$/o)
		{

		    # Image data.

		    eval
		    {
			my $loader = Gtk2::Gdk::PixbufLoader->new();
			$loader->write($contents);
			$loader->close();
			$browser->{file_view_svbuffer}->insert_pixbuf
			    ($browser->{file_view_svbuffer}->get_start_iter(),
			     $loader->get_pixbuf());
		    };
		    $browser->{file_view_svbuffer}->
			set_text("<" . $mime_type . ">") if ($@ ne "");

		}
		else
		{

		    # Non-image data.

		    my $ok_to_render = 0;

		    # Attempt to syntax highlight the file if it looks safe.

		    if ($mime_type =~ m/^application\/.+$/o)
		    {
			my $part;
			($part) = ($mime_type =~ m/^application\/(.+)$/o);
			foreach my $item (@text_viewable_app_mime_types)
			{
			    if ($part eq $item)
			    {
				$ok_to_render = 1;
				last;
			    }
			}
		    }

		    if ($mime_type =~ m/^text\/.+$/o || $ok_to_render)
		    {

			# Contents is displayable text.

			my $iter;

			# Enable syntax highlighting if it is available for
			# this type of text file.

			if (defined($lang = $browser->{file_view_svlangmgr}->
				    get_language_from_mime_type($mime_type)))
			{
			    $browser->{file_view_svbuffer}->
				set("highlight", TRUE);
			    $browser->{file_view_svbuffer}->
				set_language($lang);
			}

			# Load in the contents and then delete the trailing
			# newline.

			$browser->{file_view_svbuffer}->set_text($contents);
			$iter = $browser->{file_view_svbuffer}->get_end_iter();
			$browser->{file_view_svbuffer}->delete
			    ($iter,
			     $browser->{file_view_svbuffer}->get_end_iter())
			    if ($iter->backward_char());

			# Enable the file buttons applicable to text files.

			foreach my $widget
			    (@{$browser->{text_file_sensitive_group}})
			{
			    $widget->set_sensitive(TRUE);
			}

			# Enable any associated find text window that may be
			# displayed.

			disable_find_text($browser->{file_view_sv}, 0);

		    }
		    else
		    {

			# Display mime type for undisplayable file contents.

			$browser->{file_view_svbuffer}->
			    set("highlight", FALSE);
			$browser->{file_view_svbuffer}->
			    set_text("<" . $mime_type . ">");

		    }

		}

		# Scroll back up to the top left.

		$browser->{file_view_svbuffer}->
		    place_cursor($browser->{file_view_svbuffer}->
				 get_start_iter());
		if ($browser->{file_view_scrolledwindow}->realized())
		{
		    $browser->{file_view_scrolledwindow}->
			get_vadjustment()->set_value(0);
		    $browser->{file_view_scrolledwindow}->
			get_hadjustment()->set_value(0);
		}

		# Update the file details labels.

		if (! exists($manifest_entry->{last_changed_revision}))
		{
		    my(@certs_list,
		       @revision_ids,
		       @revision_list);
		    get_revision_ids($browser, \@revision_ids);
		    $browser->{mtn}->
			get_content_changed(\@revision_list,
					    $revision_ids[0],
					    $manifest_entry->{name});
		    $manifest_entry->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "date")
			{
			    my $last_update;
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $manifest_entry->{last_update} = $last_update;
			    last;
			}
		    }
		}
		set_label_value($browser->{file_name_label},
				$manifest_entry->{name});
		set_label_value($browser->{file_id_label},
				$manifest_entry->{file_id});
		set_label_value($browser->{last_update_label},
				$manifest_entry->{last_update});
		set_label_value($browser->{file_revision_id_label},
				$manifest_entry->{last_changed_revision});
	    }

	}
	else
	{

	    # Reset the file view buffer and the associated find text window.

	    $browser->{file_button_vbox}->set_sensitive(FALSE);
	    $browser->{file_view_svbuffer}->
		place_cursor($browser->{file_view_svbuffer}->get_start_iter());
	    $browser->{file_view_svbuffer}->set_text("");
	    $browser->{file_view_svbuffer}->set("highlight", FALSE);
	    set_label_value($browser->{file_name_label}, "");
	    set_label_value($browser->{file_id_label}, "");
	    set_label_value($browser->{last_update_label}, "");
	    set_label_value($browser->{file_revision_id_label}, "");
	    disable_find_text($browser->{file_view_sv}, 1);

	}

    }

    $browser->{appbar}->pop();
    $wm->make_busy($browser, 0);

}
#
##############################################################################
#
#   Routine      - mtn_error_handler
#
#   Description  - This routine is called when ever there is a problem with
#                  Monotone.
#
#   Data         - $severity : The severity of the error.
#                  $message  : The error message.
#
##############################################################################



sub mtn_error_handler($$)
{

    my($severity, $message) = @_;

    my $dialog;

    if ($severity eq "warning")
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "warning",
	     "close",
	     sprintf("Problem with monotone request, got:\n<b><i>%s</i></b>\n"
		         . "This should not be happening!",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	die($message);
    }
    else
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "error",
	     "close",
	     sprintf("Monotone process unexpectedly exiting with:\n"
		         . "<b><i>%s</i></b>\n"
		         . "This is fatal, I am going to exit.",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	Gtk2->main_quit() unless (Gtk2->main_level() == 0);
	die($message);
    }

}
#
##############################################################################
#
#   Routine      - sigchld_handler
#
#   Description  - This routine is called when ever a subprocess exits.
#
#   Data         - None.
#
##############################################################################



sub sigchld_handler()
{

    my($pid,
       $status);

    while (($pid = waitpid(-1, WNOHANG)) > 0)
    {
	$status = $?;
	if (WIFEXITED($status) || WIFSIGNALED($status))
	{

	    # If it is an mtn process then close down the relevant object so
	    # that it will automatically restart when needed.

	    WindowManager->instance()->cond_find
		(undef,
		 sub {
		     my $instance = $_[0];
		     if (exists($instance->{mtn}) && defined($instance->{mtn})
			 && $instance->{mtn}->get_pid() == $pid)
		     {
			 $instance->{mtn}->closedown();
			 my $dialog = Gtk2::MessageDialog->new
			     (undef,
			      ["modal"],
			      "warning",
			      "close",
			      sprintf("The mtn subprocess just unexpectedly\n"
				          . "exited (%s).\n"
				          . "This shouldn't happen.\n"
				          . "It will be restarted when "
				          .  "needed.",
				      WIFSIGNALED($status) ?
				          sprintf("terminated by signal %d",
						  WTERMSIG($status)) :
				          sprintf("exited with status %d",
						  WEXITSTATUS($status))));
			 $dialog->run();
			 $dialog->destroy();
			 return 1;
		     }
		     return;
		 });

	}
    }
    warn("waitpid failed: $!") if ($pid < 0 && $! != ECHILD);

}
#
##############################################################################
#
#   Routine      - setup_sigchld_handler
#
#   Description  - This routine sets up the handler for SIGCHLD signals.
#
#   Data         - $handler - A reference to the SIGCHLD handler routine.
#
##############################################################################



sub setup_sigchld_handler($)
{

    my $handler = $_[0];

    my($reader,
       $writer);

    # Basically set up a SIGCHLD handler that simply writes a character down an
    # anonymous pipe in order to wake up the actual handler that is registered
    # with Gtk2 as a file activity handler. This is efficient and safer than
    # some alternatives.

    pipe($reader, $writer) or die("pipe failed: $!");
    $SIG{CHLD} = sub { syswrite($writer, "\n", 1); };
    Gtk2::Helper->add_watch(fileno($reader), "in",
			    sub {
				my $buffer;
				sysread($reader, $buffer, 1);
				&$handler();
				return 1; });

}
