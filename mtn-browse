#!/usr/bin/perl -W
##!/usr/bin/perl -w
##############################################################################
#
#   File Name    - mtn-browse
#
#   Description  - Perl GUI utility for browsing a Monotone database without a
#                  workspace.
#
#   Author       - A.E.Cooper.
#
#   Legal Stuff  - Copyright (c) 2007 Anthony Edward Cooper
#                  <aecooper@coosoft.plus.com>.
#
#                  This program is free software; you can redistribute it
#                  and/or modify it under the terms of the GNU General Public
#                  License as published by the Free Software Foundation;
#                  either version 3 of the License, or (at your option) any
#                  later version.
#
#                  This program is distributed in the hope that it will be
#                  useful, but WITHOUT ANY WARRANTY; without even the implied
#                  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#                  PURPOSE. See the GNU General Public License for more
#                  details.
#
#                  You should have received a copy of the GNU General Public
#                  License along with this software; if not, write to the Free
#                  Software Foundation, Inc., 59 Temple Place - Suite 330,
#                  Boston, MA 02111-1307 USA.
#
##############################################################################
#
##############################################################################
#
#   GLOBAL DATA FOR THIS MODULE
#
##############################################################################



# ***** REQUIRED VERSION OF PERL *****

require 5.008;

# ***** REQUIRED PACKAGES *****

use lib "/home/aecoope/perl";

use strict;
use Glib qw(FALSE TRUE);
use Gnome2;
use Gnome2::VFS -init;
use Gtk2 -init;
set_locale Gtk2;
init Gtk2;
use Gtk2::GladeXML;
use Gtk2::Helper;
use Gtk2::Pango;
use Gtk2::SourceView;
use IPC::Open3;
use Monotone::AutomateStdio;
use POSIX qw(:errno_h :sys_wait_h);

# Temporary debug stuff.

use Data::Dumper;

# ***** GLOBAL DATA DECLARATIONS *****

# Constants used to represent the different groups of widgets.

use constant BRANCH           => 0x01;
use constant DIRECTORY        => 0x02;
use constant DIRECTORY_VIEW   => 0x04;
use constant DISPLAY_OF_FILE  => 0x08;
use constant FILE             => 0x10;
use constant REVISION         => 0x20;
use constant REVISION_LIST    => 0x02;
use constant REVISION_DETAILS => 0x04;

# Constants used to represent the different state changes. Read this as
# `what has just been changed' => `what needs to be updated'.

use constant BRANCH_CHANGED            => (REVISION | DIRECTORY
					   | DIRECTORY_VIEW | FILE
					   | DISPLAY_OF_FILE);
use constant DATABASE_CHANGED          => 0xff;
use constant DIRECTORY_CHANGED         => (DIRECTORY_VIEW | FILE
					   | DISPLAY_OF_FILE);
use constant DISPLAY_OF_FILE_CHANGED   => 0x00;
use constant FILE_CHANGED              => (DISPLAY_OF_FILE);
use constant NEW_FIND                  => 0xff;
use constant REVISION_CHANGED          => (DIRECTORY | REVISION_LIST
					   | DIRECTORY_VIEW | FILE
					   | DISPLAY_OF_FILE);
use constant SELECTED_REVISION_CHANGED => (REVISION_DETAILS);

# Constants for the columns within the manifest ListStore widget.

use constant MLS_ICON_COLUMN           => 0;
use constant MLS_NAME_COLUMN           => 1;
use constant MLS_DATE_COLUMN           => 2;
use constant MLS_AUTHOR_COLUMN         => 3;
use constant MLS_MANIFEST_ENTRY_COLUMN => 4;

# Constants for the columns within the details ListStore widget.

use constant DLS_ICON_COLUMN  => 0;
use constant DLS_NAME_COLUMN  => 1;
use constant DLS_VALUE_COLUMN => 2;

# Text viewable application mime types.

my @text_viewable_app_mime_types =
    qw(postscript
       rtf
       x-awk
       x-cgi
       x-csh
       x-glade
       x-java
       x-javascript
       x-jbuilder-project
       x-perl
       x-php
       x-python
       x-shellscript
       x-troff-man
       x-troff
       xhtml+xml);

# Supported text mime types (used for syntax highlighting.

my @text_mime_types =
    (
     {
	 pattern => qr/.*\.c$/o,
	 type    => "text/x-csrc"
     },
     {
	 pattern => qr/.*\.(C)|(cc)|(cp)|(cpp)|(CPP)|(cxx)|(c\+\+)$/o,
	 type    => "text/x-c++src"
     },
     {
	 pattern => qr/.*\.(h)|(hh)|(H)$/o,
	 type    => "text/x-c++hdr"
     },
     {
	 pattern => qr/.*\.h$/o,
	 type    => "text/x-chdr"
     },
     {
	 pattern => qr/(^[Mm]akefile(\.[^.]+)?)|(.*\.mk)$/o,
	 type    => "text/x-makefile"
     },
     {
	 pattern => qr/.*/o,
	 type    => "text/plain"
     }
    );

# A boolean to signal whether this process has received a SIGCHLD signal or
# not.

# List of browser instances.

my @browsers;

# The advanced find window management record.

my $advanced_find;

# The pixmap for the application's icon.

my $app_icon;

# The tooltips widget.

my $tooltips;

# ***** FUNCTIONAL PROTOTYPES FOR THIS FILE *****

# Private routines.

sub advanced_find($);
sub advanced_find_button_clicked_cb($$);
sub combo_changed_cb($$);
sub combo_key_release_event_cb($$$);
sub create_advanced_find_window();
sub delete_event_cb($$$);
sub destroy_event_cb($$;$);
sub directory_up_button_clicked_cb($$);
sub get_completion($$$$;$);
sub get_dir_contents($$$);
sub get_revision_ids($$);
sub gtk2_update();
sub make_busy($$);
sub manifest_browser_treeview_cursor_changed_cb($$);
sub manifest_browser_treeview_row_activated_cb($$$$);
sub mtn_error_handler($$);
sub new_browser_instance();
sub revisions_treeview_cursor_changed_cb($$);
sub revisions_treeview_row_activated_cb($$$$);
sub set_label_value($$);
sub setup_sigchld_handler($);
sub sigchld_handler();
sub simple_query_radiobutton_toggled_cb($$);
sub update_advanced_find_state($$);
sub update_browser_state($$);
#
##############################################################################
#
#   Routine      - Main Body Of Code
#
#   Description  - This is the main body of code for the mtn-browse script.
#
#   Data         - @_           : The command line arguments.
#                  Return Value : Unix exit code.
#
##############################################################################



{

    # Initialise the libraries and generate the interface.

    Gnome2::Program->init("mtn-browse", 0.1);
    Monotone::AutomateStdio->register_error_handler("both",
						    \&mtn_error_handler);
    setup_sigchld_handler(\&sigchld_handler);
    $tooltips = Gtk2::Tooltips->new();
    $app_icon = Gtk2::Gdk::Pixbuf->new_from_file("../mtn-browse.png");
    push(@browsers, new_browser_instance());

    # Hand control over to Gtk2.

    Gtk2->main();

    # Cleanup.

    if (defined($advanced_find))
    {
	$advanced_find->{window}->destroy();
	$advanced_find = undef;
    }
    foreach my $browser (@browsers)
    {
	$browser->{window}->destroy();
    }
    Gnome2::VFS->shutdown();
    $SIG{CHLD} = "IGNORE";
    @browsers = ();

    exit(0);

}
#
##############################################################################
#
#   Routine      - new_browser_instance
#
#   Description  - Construct a new browser instance record. This creates a new
#                  main window, a new connection to Monotone and initialising
#                  sensible defaults.
#
#   Data         - Return Value : A reference to the newly created browser
#                                 instance record.
#
##############################################################################



sub new_browser_instance()
{

    my($browser,
       $font,
       $renderer,
       $tv_column,
       $div);

    $browser = {};
    $browser->{mtn} = Monotone::AutomateStdio->new();
    # $browser->{glade} = Gtk2::GladeXML->new("../mtn-browse.glade");
    $browser->{glade} =
	Gtk2::GladeXML->new("../mtn-browse.glade", "main_window");

    # Flag to stop recursive calling of callbacks.

    $browser->{in_cb} = 0;

    # Connect Glade registered signal handlers.

    $browser->{glade}->signal_autoconnect
	(sub
	 {
	     my($callback_name, $widget, $signal_name, $signal_data,
		$connect_object, $after, $user_data) = @_;
	     my $func = $after ? "signal_connect_after" : "signal_connect";
	     $widget->$func($signal_name,
			    $callback_name,
			    $connect_object ? $connect_object : $user_data);
	 },
	 $browser);

    # Link in the update handler for the browser.

    $browser->{update_handler} = \&update_browser_state;

    # Get the widgets that we are interested in.

    $browser->{window} = $browser->{glade}->get_widget("main_window");
    $browser->{window}->set_icon($app_icon);
    $browser->{appbar} = $browser->{glade}->get_widget("appbar");
    $browser->{branch_combo} =
	$browser->{glade}->get_widget("branch_comboboxentry");
    $browser->{revision_combo} =
	$browser->{glade}->get_widget("revision_comboboxentry");
    $browser->{tagged_tick} =
	$browser->{glade}->get_widget("tagged_checkbutton");
    $browser->{directory_combo} =
	$browser->{glade}->get_widget("directory_comboboxentry");
    $browser->{directory_up_button} =
	$browser->{glade}->get_widget("directory_up_button");
    $browser->{manifest_treeview} =
	$browser->{glade}->get_widget("manifest_browser_treeview");
    $browser->{file_view_scrolledwindow} =
	$browser->{glade}->get_widget("file_view_scrolledwindow");
    $browser->{file_name_label} =
	$browser->{glade}->get_widget("file_name_value_label");
    $browser->{file_id_label} =
	$browser->{glade}->get_widget("file_id_value_label");
    $browser->{last_update_label} =
	$browser->{glade}->get_widget("last_update_value_label");
    $browser->{file_revision_id_label} =
	$browser->{glade}->get_widget("file_revision_id_value_label");
    $browser->{file_button_vbox} =
	$browser->{glade}->get_widget("file_button_vbox");
    $browser->{database_name_label} =
	$browser->{glade}->get_widget("database_name_value_label");
    $browser->{revision_id_label} =
	$browser->{glade}->get_widget("revision_id_value_label");
    $browser->{author_label} =
	$browser->{glade}->get_widget("author_value_label");
    $browser->{change_log_label} =
	$browser->{glade}->get_widget("change_log_value_label");

    # Setup button sensitive groups.

    $browser->{text_file_sensitive_group} = ();
    foreach my $item ("search_text", "annotate", "file_compare")
    {
	push(@{$browser->{text_file_sensitive_group}}, 
	     $browser->{glade}->get_widget($item . "_button"));
    }
    $browser->{revision_sensitive_group} = ();
    foreach my $item ("revision_information", "revision_compare")
    {
	push(@{$browser->{revision_sensitive_group}}, 
	     $browser->{glade}->get_widget($item . "_button"));
    }

    # Setup the comboboxentry key release signal handlers.

    $browser->{branch_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{directory_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{revision_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);

    # Move the pane separator to a sensible position.

    # $div = $browser->{glade}->get_widget("browser_hpaned");
    # $div->set_position(300);

    # Setup the comboboxes.

    $browser->{branch_combo}->set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{branch_combo}->set_text_column(0);
    $browser->{branch_combo}->set_wrap_width(2);
    $browser->{directory_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{directory_combo}->set_text_column(0);
    $browser->{directory_combo}->set_wrap_width(2);
    $browser->{revision_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{revision_combo}->set_text_column(0);
    $browser->{revision_combo}->set_wrap_width(2);

    # Setup the tree view manifest file browser.

    $browser->{manifest_liststore} = Gtk2::ListStore->new("Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::Scalar");
    $browser->{manifest_treeview}->set_model($browser->{manifest_liststore});

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_resizable(FALSE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(25);
    $tv_column->set_sort_column_id(MLS_ICON_COLUMN);
    $renderer = Gtk2::CellRendererPixbuf->new();
    $tv_column->pack_start($renderer, TRUE);
    $tv_column->set_attributes($renderer, "stock-id" => MLS_ICON_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("File Name");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(180);
    $tv_column->set_sort_column_id(MLS_NAME_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_NAME_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Last Update");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(MLS_DATE_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_DATE_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Author");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(MLS_AUTHOR_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_AUTHOR_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $browser->{manifest_treeview}->set_search_column(MLS_NAME_COLUMN);

    # $tv_column = $browser->{manifest_treeview}->get_column(MLS_DATE_COLUMN);
    # $browser->{manifest_treeview}->remove_column($tv_column);

    # Setup the file file viewer (with syntax highlighting).

    $browser->{file_view_svbuffer} = Gtk2::SourceView::Buffer->new(undef);
    $browser->{file_view_svbuffer}->set_max_undo_levels(0);
    $browser->{file_view_svbuffer}->begin_not_undoable_action();
    $browser->{file_view_svlangmgr} =
	Gtk2::SourceView::LanguagesManager->new();
    $browser->{file_view_sv} = Gtk2::SourceView::View->
	new_with_buffer($browser->{file_view_svbuffer});
    $font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $browser->{file_view_sv}->modify_font($font) if (defined($font));
    $browser->{file_view_sv}->set_cursor_visible(FALSE);
    $browser->{file_view_sv}->set_editable(FALSE);
    $browser->{glade}->get_widget("file_view_scrolledwindow")->
	add($browser->{file_view_sv});
    $browser->{file_view_sv}->show_all();

    # Update the browser's internal state.

    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);

    return $browser;

}
#
##############################################################################
#
#   Routine      - combo_changed_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by selecting an entry from its pulldown
#                  list.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub combo_changed_cb($$)
{

    my($widget, $instance) = @_;

    my ($change_state,
	$combo_details,
	$item,
	$value);

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    if ($widget == $instance->{branch_combo})
    {
	$change_state = BRANCH_CHANGED;
	$combo_details = $instance->{branch_combo_details};
    }
    elsif ($widget == $instance->{revision_combo})
    {
	$change_state = REVISION_CHANGED;
	$combo_details = $instance->{revision_combo_details};
    }
    elsif ($widget == $instance->{directory_combo})
    {
	$change_state = DIRECTORY_CHANGED;
	$combo_details = $instance->{directory_combo_details};
    }
    else
    {
	return;
    }

    # For some reason best known to itself, Gtk+ calls this callback when the
    # user presses a key for the first time (but not subsequently) after a
    # value is selected via the pulldown menu. So we have to guard against
    # this. Under these circumstances the key release callback is also called.
    # So, put simply, only do something inside this callback if the value is a
    # direct match to one in our list.

    $value = $widget->child()->get_text();
    foreach $item (@{$combo_details->{list}})
    {
	if ($value eq $item)
	{
	    $combo_details->{value} = $value;
	    $combo_details->{completed} = 1;
	    $instance->{appbar}->clear_stack();
	    &{$instance->{update_handler}}($instance, $change_state);
	    last;
	}
    }

}
#
##############################################################################
#
#   Routine      - combo_key_release_event_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by entering a character (key release
#                  event).
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $instance    : The window instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub combo_key_release_event_cb($$$)
{

    my($widget, $event, $instance) = @_;

    my ($change_state,
	$combo,
	$combo_details,
	$completed,
	$completion,
	$item,
	$len,
	$name,
	$old_completed,
	$old_value,
	$value);

    return FALSE if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    if ($widget == $instance->{branch_combo}->child())
    {
	$combo = $instance->{branch_combo};
	$change_state = BRANCH_CHANGED;
	$combo_details = $instance->{branch_combo_details};
	$name = "branch";
    }
    elsif ($widget == $instance->{revision_combo}->child())
    {
	$combo = $instance->{revision_combo};
	$change_state = REVISION_CHANGED;
	$combo_details = $instance->{revision_combo_details};
	$name = "revision";
    }
    elsif ($widget == $instance->{directory_combo}->child())
    {
	$combo = $instance->{directory_combo};
	$change_state = DIRECTORY_CHANGED;
	$combo_details = $instance->{directory_combo_details};
	$name = "directory";
    }
    else
    {
	return FALSE;
    }

    # The user has typed something in then validate it and auto-complete it if
    # necessary.

    $completed = 0;
    $old_completed = $combo_details->{completed};
    $old_value = $combo_details->{value};
    $value = $widget->get_text();
    if ($value ne $old_value)
    {

	# Don't auto-complete if the user is simply deleting from the extreme
	# right.

	$len = length($value);
	if ($value ne substr($old_value, 0, $len))
	{

	    # So that the spacebar triggers auto-complete.

	    $value =~ s/\s+$//o;
	    $len = length($value);

	    if (get_completion($value,
			       $combo_details->{list},
			       \$completion,
			       \$completed,
			       $combo_details->{completion_cache}))
	    {
		$instance->{appbar}->clear_stack();
	    }
	    else
	    {
		$instance->{appbar}->
		    push("Invalid " . $name . " name`" . $value . "'");
	    }
	    $value = $completion;
	    $len = length($value);
	    $widget->set_text($value);
	    $widget->set_position(-1);

	}
	$combo_details->{value} = $value;
	$combo_details->{last_typed_len} = length($value);
	$combo_details->{completed} = $completed;

	# Update the pulldown choices.

	$combo->get_model()->clear();
	foreach $item (@{$combo_details->{list}})
	{
	    $combo->append_text($item) if ($value eq substr($item, 0, $len));
	    $combo_details->{completed} = 1
		if (! $completed && $value eq $item);
	}

	# Update the browser state on a significant change.

	&{$instance->{update_handler}}($instance, $change_state)
	    if ($combo_details->{completed} != $old_completed
		|| $combo_details->{value} ne $old_value);

    }

    return FALSE;

}
#
##############################################################################
#
#   Routine      - tagged_checkbutton_toggled_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  the tagged_checkbutton.
#                  list.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub tagged_checkbutton_toggled_cb($$)
{

    my($widget, $instance) = @_;

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    $instance->{appbar}->clear_stack();
    &{$instance->{update_handler}}($instance, BRANCH_CHANGED);

}
#
##############################################################################
#
#   Routine      - advanced_find_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the up
#                  directory button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub advanced_find_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    my($len,
       $value);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    advanced_find($browser);

}
#
##############################################################################
#
#   Routine      - directory_up_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the up
#                  directory button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub directory_up_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    my($len,
       $value);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Simply go up one directory level in the manifest if we aren't already at
    # the top.

    $value = $browser->{directory_combo_details}->{value};
    if ($value ne "")
    {
	if ($value =~ m/^.+\/.+/o)
	{
	    if ($value =~ m/^(.+)\/[^\/]+$/o)
	    {
		($value) = ($value =~ m/^(.+)\/[^\/]+$/o);
	    }
	    else
	    {
		($value) = ($value =~ m/^(.+)\/$/o)
	    }
	}
	else
	{
	    $value = "";
	}
	$browser->{directory_combo_details}->{value} = $value;
	$browser->{directory_combo_details}->{completed} = 1;
	$len = length($value);
	if ($len < $browser->{directory_combo_details}->{last_typed_len})
	{
	    $browser->{directory_combo}->get_model()->clear();
	    foreach my $item (@{$browser->{directory_combo_details}->{list}})
	    {
		$browser->{directory_combo}->append_text($item)
		    if ($value eq substr($item, 0, $len));
	    }
	    $browser->{directory_combo_details}->{last_typed_len} = $len;
	}
	$browser->{directory_combo}->child()->set_text($value);
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user selects an entry in
#                  the manifest treeview.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub manifest_browser_treeview_cursor_changed_cb($$)
{

    my($widget, $browser) = @_;

    my($manifest_entry,
       $short_name);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Get the manifest entry details for the item that was selected.

    $widget->get_selection()->selected_foreach
	(sub
	 {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a file then display its contents, otherwise if it is a
    # directory then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "file")
    {
	$browser->{file_being_viewed} = {short_name     => $short_name,
					 manifest_entry => $manifest_entry};
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, FILE_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user double clicks on an
#                  entry in the manifest treeview.
#
#   Data         - $widget           : The widget object that received the
#                                      signal.
#                  $tree_path        : A Gtk2::TreePath object for the
#                                      selected item.
#                  $tree_view_column : A Gtk2::TreeViewColumn object for the
#                                      selected item.
#                  $browser          : The browser instance that is associated
#                                      with this widget.
#
##############################################################################



sub manifest_browser_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $browser) = @_;

    my($manifest_entry,
       $short_name);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Get the manifest entry details for the item that was double-clicked.

    $widget->get_selection()->selected_foreach
	(sub
	 {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a directory then change to it, otherwise if it is a file
    # then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "directory")
    {
	$browser->{directory_combo_details}->{value} = $manifest_entry->{name};
	$browser->{directory_combo_details}->{completed} = 1;
	$browser->{directory_combo}->child()->
	    set_text($manifest_entry->{name});
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - simple_query_radiobutton_toggled_cb
#
#   Description  - Callback routine called when the user changes the advanced
#                  find mode radio button.
#
#   Data         - $widget        : The widget object that received the
#                                   signal.
#                  $advanced_find : The advanced find dialog window instance
#                                   that is associated with this widget.
#
##############################################################################



sub simple_query_radiobutton_toggled_cb($$)
{

    my($widget, $advanced_find) = @_;

    my($len,
       $value);

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Simply enable the relevant find widgets depending upon whether simple or
    # advanced mode is selected.

    if ($advanced_find->{simple_query_radiobutton}->get_active())
    {
	$advanced_find->{simple_frame}->set_sensitive(TRUE);
	$advanced_find->{advanced_frame}->set_sensitive(FALSE);
    }
    else
    {
	$advanced_find->{simple_frame}->set_sensitive(FALSE);
	$advanced_find->{advanced_frame}->set_sensitive(TRUE);
    }

}
#
##############################################################################
#
#   Routine      - revisions_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user selects an entry in
#                  the advanced find's revisions treeview.
#
#   Data         - $widget        : The widget object that received the
#                                   signal.
#                  $advanced_find : The advanced find dialog window instance
#                                   that is associated with this widget.
#
##############################################################################



sub revisions_treeview_cursor_changed_cb($$)
{

    my($widget, $advanced_find) = @_;

    my $revision_id;

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    # Get the selected revision id.

    $widget->get_selection()->selected_foreach
	(sub
	 {
	     my($model, $path, $iter) = @_;
	     $revision_id = $model->get($iter, 0);
	 });

    if (defined($revision_id))
    {
	$advanced_find->{revisions_treeview_details}->{value} = $revision_id;
	$advanced_find->{appbar}->clear_stack();
	&{$advanced_find->{update_handler}}($advanced_find,
					    SELECTED_REVISION_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - revisions_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user double clicks on an
#                  entry in the advanced find's revisions treeview.
#
#   Data         - $widget           : The widget object that received the
#                                      signal.
#                  $tree_path        : A Gtk2::TreePath object for the
#                                      selected item.
#                  $tree_view_column : A Gtk2::TreeViewColumn object for the
#                                      selected item.
#                  $advanced_find    : The advanced find dialog window
#                                      instance that is associated with this
#                                      widget.
#
##############################################################################



sub revisions_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $advanced_find) = @_;

    my($manifest_entry,
       $short_name);

    return if ($advanced_find->{in_cb});
    local $advanced_find->{in_cb} = 1;

    return;

    # Get the manifest entry details for the item that was double-clicked.

    $widget->get_selection()->selected_foreach
	(sub
	 {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a directory then change to it, otherwise if it is a file
    # then just ignore it.

    if ($manifest_entry->{type} eq "directory")
    {
	$advanced_find->{directory_combo_details}->{value} = $manifest_entry->{name};
	$advanced_find->{directory_combo_details}->{completed} = 1;
	$advanced_find->{directory_combo}->child()->
	    set_text($manifest_entry->{name});
	$advanced_find->{appbar}->clear_stack();
	&{$advanced_find->{update_handler}}($advanced_find, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - delete_event_cb
#
#   Description  - Callback routine called when the used has attempted to
#                  close the main window.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub delete_event_cb($$$)
{

    my($widget, $event, $browser) = @_;

    if ($browser->{in_cb})
    {
	return TRUE;
    }
    else
    {
	return FALSE;
    }

}
#
##############################################################################
#
#   Routine      - destroy_event_cb
#
#   Description  - Callback routine called when the main window is about to be
#                  destroyed.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $client_data : The client data associated with this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub destroy_event_cb($$;$)
{

    my($widget, $event, $client_data) = @_;

    my $browser = defined($client_data) ? $client_data : $event;

    Gtk2->main_quit();

    return FALSE;

}
#
##############################################################################
#
#   Routine      - advanced_find
#
#   Description  - This routine, if necessary, contructs  the advanced find
#                  dialog window and then gets the user to select the revision
#                  they want.
#
#   Data         - $browser     : The browser instance that started the
#                                 advanced find.
#                  Return Value : A reference to the newly created browser
#                                 instance record.
#
##############################################################################



sub advanced_find($)
{

    my($browser) = @_;

    $advanced_find = create_advanced_find_window()
	unless (defined($advanced_find));

    $advanced_find->{mtn} = $browser->{mtn};

    # Update the window's internal state.

    {
	local $advanced_find->{in_cb} = 1;
	$advanced_find->{branch_combo_details}->{preset} = 1;
	$advanced_find->{branch_combo_details}->{completed} =
	    $browser->{branch_combo_details}->{completed};
	$advanced_find->{branch_combo_details}->{value} =
	    $browser->{branch_combo_details}->{value};
	$advanced_find->{revision_combo_details}->{preset} = 1;
	$advanced_find->{revision_combo_details}->{completed} =
	    $browser->{revision_combo_details}->{completed};
	$advanced_find->{revision_combo_details}->{value} =
	    $browser->{revision_combo_details}->{value};
	$advanced_find->{tagged_tick}->
	    set_active($browser->{tagged_tick}->get_active());
	$advanced_find->{window}->set_transient_for($browser->{window});
	$advanced_find->{simple_query_radiobutton}->set_active(TRUE);
	$advanced_find->{simple_frame}->set_sensitive(TRUE);
	$advanced_find->{advanced_frame}->set_sensitive(FALSE);
	$advanced_find->{ok_button}->set_sensitive(FALSE);
	$advanced_find->{window}->show();
	&{$advanced_find->{update_handler}}($advanced_find, NEW_FIND);
    }

    # Handle all events until the dialog is dismissed.

    $advanced_find->{done} = 0;
    while (! $advanced_find->{done})
    {
	Gtk2->main_iteration();
    }

    # Deal with the result.

    $advanced_find->{window}->hide();

}
#
##############################################################################
#
#   Routine      - create_advanced_find_window
#
#   Description  - This routine simply creates an advanced find dialog window.
#
#   Data         - Return Value : A reference to the newly created advanced
#                                 find instance record.
#
##############################################################################



sub create_advanced_find_window()
{

    my(@branch_list,
       $font,
       $instance,
       $renderer,
       $tv_column);

    $instance = {};
    $instance->{glade} =
	Gtk2::GladeXML->new("../mtn-browse.glade", "advanced_find_window");

    # Flag to stop recursive calling of callbacks.

    $instance->{in_cb} = 0;

    # Connect Glade registered signal handlers.

    $instance->{glade}->signal_autoconnect
	(sub
	 {
	     my($callback_name, $widget, $signal_name, $signal_data,
		$connect_object, $after, $user_data) = @_;
	     my $func = $after ? "signal_connect_after" : "signal_connect";
	     $widget->$func($signal_name,
			    $callback_name,
			    $connect_object ? $connect_object : $user_data);
	 },
	 $instance);

    # Link in the update handler for the advanced find window.

    $instance->{update_handler} = \&update_advanced_find_state;

    # Get the widgets that we are interested in.

    $instance->{window} =
	$instance->{glade}->get_widget("advanced_find_window");
    $instance->{window}->set_icon($app_icon);
    $instance->{appbar} = $instance->{glade}->get_widget("appbar");
    $instance->{simple_query_radiobutton} =
	$instance->{glade}->get_widget("simple_query_radiobutton");
    $instance->{simple_frame} = $instance->{glade}->get_widget("simple_frame");
    $instance->{advanced_frame} =
	$instance->{glade}->get_widget("advanced_frame");
    $instance->{branch_combo} =
	$instance->{glade}->get_widget("branch_comboboxentry");
    $instance->{revision_combo} =
	$instance->{glade}->get_widget("revision_comboboxentry");
    $instance->{tagged_tick} =
	$instance->{glade}->get_widget("tagged_checkbutton");
    $instance->{term_combo} = $instance->{glade}->get_widget("term_combobox");
    $instance->{date_dateedit} =
	$instance->{glade}->get_widget("date_dateedit");
    $instance->{revisions_treeview} =
	$instance->{glade}->get_widget("revisions_treeview");
    $instance->{details_textview} =
	$instance->{glade}->get_widget("details_textview");
    $instance->{details_scrolledwindow} =
	$instance->{glade}->get_widget("details_scrolledwindow");
    $instance->{selected_branch_label} =
	$instance->{glade}->get_widget("selected_branch_value_label");
    $instance->{selected_revision_label} =
	$instance->{glade}->get_widget("selected_revision_value_label");
    $instance->{ok_button} = $instance->{glade}->get_widget("ok_button");

    # Setup the advanced find window deletion handlers.

    $instance->{window}->signal_connect
	("delete_event",
	 sub { $_[2]->{done} = 1 unless ($_[2]->{in_cb}); return TRUE; },
         $instance);
    $instance->{glade}->get_widget("cancel_button")->signal_connect
	("clicked", sub { $_[1]->{done} = 1; }, $instance);

    # Setup the comboboxentry key release signal handlers.

    $instance->{branch_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $instance);
    $instance->{revision_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $instance);

    # Setup the comboboxes.

    $instance->{branch_combo}->set_model(Gtk2::ListStore->new("Glib::String"));
    $instance->{branch_combo}->set_text_column(0);
    $instance->{branch_combo}->set_wrap_width(2);
    $instance->{revision_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $instance->{revision_combo}->set_text_column(0);
    $instance->{revision_combo}->set_wrap_width(2);
    $instance->{term_combo}->set_active(0);

    # Setup the revisions list browser.

    $instance->{revisions_liststore} = Gtk2::ListStore->new("Glib::String");
    $instance->{revisions_treeview}->
	set_model($instance->{revisions_liststore});
    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(0);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => 0);
    $instance->{revisions_treeview}->append_column($tv_column);
    $instance->{revisions_treeview}->set_search_column(0);

    # Setup the revision details viewer.

    $instance->{details_buffer} = $instance->{details_textview}->get_buffer();
    $instance->{details_buffer}->create_tag("bold",
					    weight => PANGO_WEIGHT_BOLD);
    $instance->{details_buffer}->create_tag("italics", style => "italic");
    $instance->{details_buffer}->create_tag("bold-italics",
					    weight => PANGO_WEIGHT_BOLD,
					    style => "italic");
    $font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $instance->{details_textview}->modify_font($font) if (defined($font));

    return $instance;

}
#
##############################################################################
#
#   Routine      - update_browser_state
#
#   Description  - Given a value and a list, work out the largest unique
#                  match. Used for auto completion.
#
#   Data         - $browser : The browser instance that is to have its state
#                             updated.
#                  $changed : What the user has changed.
#
##############################################################################



sub update_browser_state($$)
{

    my($browser, $changed) = @_;

    make_busy($browser, 1);
    $browser->{appbar}->push("");
    gtk2_update();

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the branch selection.

	$browser->{branch_combo_details}->{completion_cache} = {};
	$browser->{branch_combo_details}->{completed} = 0;
	$browser->{branch_combo_details}->{value} = "";
	set_label_value($browser->{database_name_label}, "<WorkSpace>");

	# Get the new list of branches.

	$browser->{appbar}->set_status("Fetching branch list");
	gtk2_update();
	$browser->{mtn}->branches(\@branch_list) if (defined($browser->{mtn}));
	$browser->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$browser->{appbar}->set_status("Populating branch list");
	gtk2_update();
	my $counter = 1;
	$browser->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $browser->{branch_combo}->append_text($branch);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@branch_list));
	    gtk2_update();
	}
	$browser->{branch_combo}->child()->set_text("");
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$browser->{revision_combo_details}->{completion_cache} = {};
	$browser->{revision_combo_details}->{completed} = 0;
	$browser->{revision_combo_details}->{value} = "";

	# Get the new list of revisions.

	if ($browser->{branch_combo_details}->{completed})
	{
	    $browser->{appbar}->set_status("Fetching revision list");
	    gtk2_update();

	    # Get either a list of tags or revision ids depending upon what the
	    # user has chosen.

	    if ($browser->{tagged_tick}->get_active())
	    {
		my(%dup_list,
		   @list);
		$browser->{mtn}->
		    tags(\@list, $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.5);
		gtk2_update();
		foreach my $item (@list)
		{
		    if (! exists($dup_list{$item->{tag}}))
		    {
			push(@revision_list, $item->{tag});
			$dup_list{$item->{tag}} = 1;
		    }
		}
	    }
	    else
	    {
		$browser->{mtn}->
		    select(\@revision_list,
			   "b:" . $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.33);
		gtk2_update();
		$browser->{mtn}->toposort(\@revision_list, @revision_list);
		$browser->{appbar}->set_progress_percentage(0.66);
		gtk2_update();
		splice(@revision_list, 0, scalar(@revision_list) - 100);
		@revision_list = reverse(@revision_list);
	    }
	    $browser->{appbar}->set_progress_percentage(1);
	    gtk2_update();
	}
	$browser->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating revision list");
	gtk2_update();
	my $counter = 1;
	$browser->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $browser->{revision_combo}->append_text($revision);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_list));
	    gtk2_update();
	}
	$browser->{revision_combo}->child()->set_text("");
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available files and directories has changed.

    if ($changed & DIRECTORY)
    {

	my(@directory_list,
	   @manifest_list);

	# Reset the directory combo.

	$browser->{directory_combo_details}->{completion_cache} = {};
	$browser->{directory_combo_details}->{completed} = 0;
	$browser->{directory_combo_details}->{last_typed_len} = 0;
	$browser->{directory_combo_details}->{value} = "";
	set_label_value($browser->{revision_id_label}, "");
	set_label_value($browser->{author_label}, "");
	set_label_value($browser->{change_log_label}, "");

	# Reset the name of the file being viewed.

	$browser->{file_being_viewed} = {};

	# Get the new manifest.

	$browser->{appbar}->set_status("Fetching manifest");
	gtk2_update();
	if ($browser->{revision_combo_details}->{completed})
	{
	    my @revision_ids;
	    get_revision_ids($browser, \@revision_ids);
	    if (scalar(@revision_ids) > 1)
	    {
		my $message;
		$message =
		    sprintf("The `%s' tag is not unique on this branch.\n"
			        . "Please either select the revision by its "
			            . "id\n"
			        . "or use the <i>Advanced Find</i> feature.\n"
			        . "The matching revision ids are:",
			    $browser->{revision_combo_details}->{value});
		foreach my $item (@revision_ids)
		{
		    $message .= "\n" . Glib::Markup::escape_text($item);
		}
		my $dialog = Gtk2::MessageDialog->new_with_markup
		    ($browser->{window}, ["modal"], "info", "close", $message);
		$dialog->run();
		$dialog->destroy();
		$browser->{revision_combo_details}->{completed} = 0;
		$browser->{revision_combo_details}->{value} = "";
		$browser->{revision_combo}->child()->set_text("");
	    }
	    else
	    {
		my($author,
		   @certs_list,
		   $change_log);
		$browser->{mtn}->get_manifest_of(\@manifest_list,
						 $revision_ids[0]);
		$browser->{mtn}->certs(\@certs_list, $revision_ids[0]);
		$author = $change_log = "";
		foreach my $cert (@certs_list)
		{
		    $author = $cert->{value}
		        if ($cert->{name} eq "author");
		    if ($cert->{name} eq "changelog")
		    {
			$change_log = $cert->{value};
			$change_log =~ s/\s+$//os;
		    }
		}
		set_label_value($browser->{revision_id_label},
				$revision_ids[0]);
		set_label_value($browser->{author_label}, $author);
		set_label_value($browser->{change_log_label}, $change_log);
	    }
	}
	$browser->{manifest} = \@manifest_list;

	# Generate a simple list of directories for auto completion.

	$browser->{appbar}->set_progress_percentage(0.5);
	gtk2_update();
	foreach my $item (@manifest_list)
	{
	    push(@directory_list, $item->{name})
		if ($item->{type} eq "directory");
	}
	$browser->{directory_combo_details}->{list} = \@directory_list;
	$browser->{appbar}->set_progress_percentage(1);
	gtk2_update();

	# Update the directory list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating directory list");
	gtk2_update();
	my $counter = 1;
	$browser->{directory_combo}->get_model()->clear();
	foreach my $item (@directory_list)
	{
	    $browser->{directory_combo}->append_text($item);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@directory_list));
	    gtk2_update();
	}
	$browser->{directory_combo}->child()->set_text("");
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	foreach my $widget (@{$browser->{revision_sensitive_group}})
	{
	    $widget->
		set_sensitive($browser->{revision_combo_details}->{completed});
	}
	gtk2_update();

    }

    # The list of displayed files and directories has changed.

    if ($changed & DIRECTORY_VIEW)
    {

	my($author,
	   @certs_list,
	   $counter,
	   @directory_entry_list,
	   $last_update,
	   @revision_ids,
	   @revision_list,
	   $taking_our_time);

	# Reset the manifest tree view.

	$browser->{manifest_liststore}->clear();

	# Get the contents of the new directory.

	if ($browser->{directory_combo_details}->{completed}
	    || $browser->{directory_combo_details}->{value} eq "")
	{
	    get_dir_contents($browser->{directory_combo_details}->{value},
			     $browser->{manifest},
			     \@directory_entry_list);
	}

	# Disable the directory up button if we are already at the top level,
	# otherwise make sure it is enabled.

	$browser->{directory_up_button}->set_sensitive
	    (($browser->{directory_combo_details}->{value} eq "")
	     ? FALSE : TRUE);

	# Update the directory tree view.

	$browser->{appbar}->set_status("Populating file details");
	$counter = 1;
	$taking_our_time = 0;
	get_revision_ids($browser, \@revision_ids);
	foreach my $item (@directory_entry_list)
	{

	    # Get the latest modification time and the author if the entry is a
	    # file (caching the result in the manifest for future reference if
	    # we have to work it out).

	    if ($item->{manifest_entry}->{type} eq "file")
	    {
		if (! exists($item->{manifest_entry}->{author}))
		{
		    $taking_our_time = 1;
		    $browser->{mtn}->get_content_changed
			(\@revision_list,
			 $revision_ids[0],
			 $item->{manifest_entry}->{name});
		    $item->{manifest_entry}->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    $author = $last_update = "";
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "author")
			{
			    $author = $cert->{value};
			    $item->{manifest_entry}->{author} = $author;
			}
			if ($cert->{name} eq "date")
			{
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $item->{manifest_entry}->{last_update} =
				$last_update;
			}
			last if ($author ne "" && $last_update ne "");
		    }
		}
		else
		{
		    $author = $item->{manifest_entry}->{author};
		    $last_update = $item->{manifest_entry}->{last_update};
		}
	    }
	    else
	    {
		$author = "";
		$last_update = "";
	    }

	    # Put the entry into the liststore.

	    $browser->{manifest_liststore}->
		set($browser->{manifest_liststore}->append(),
		    MLS_ICON_COLUMN,
		        ($item->{manifest_entry}->{type} eq "directory")
		        ? "gtk-open" : "gtk-file",
		    MLS_NAME_COLUMN, $item->{name},
		    MLS_DATE_COLUMN, $last_update,
		    MLS_AUTHOR_COLUMN, $author,
		    MLS_MANIFEST_ENTRY_COLUMN, $item->{manifest_entry});

	    if ($taking_our_time)
	    {
		$browser->{appbar}->set_progress_percentage
		    ($counter / scalar(@directory_entry_list));
		gtk2_update();
	    }
	    ++ $counter;

	}

	$browser->{manifest_treeview}->scroll_to_point(0, 0)
	    if ($browser->{manifest_treeview}->realized());

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The displayed file contents has changed.

    if ($changed & DISPLAY_OF_FILE)
    {

	# Load up the selected file's contents into the file viewer.

	if (exists($browser->{file_being_viewed}->{manifest_entry}))
	{
	    my $manifest_entry;
	    $manifest_entry =
		$browser->{file_being_viewed}->{manifest_entry};
	    if ($browser->{file_id_label}->get_text()
		ne $manifest_entry->{file_id})
	    {

		my($contents,
		   $lang,
		   $mime_type,
		   $scrolled_window);

		# Reset the file view buffer.

		$browser->{file_button_vbox}->set_sensitive(TRUE);
		foreach my $widget (@{$browser->{text_file_sensitive_group}})
		{
		    $widget->set_sensitive(FALSE);
		}
		$browser->{file_view_svbuffer}->set_text("");
		$browser->{file_view_svbuffer}->set("highlight", FALSE);

		# Get contents.

		$manifest_entry =
		    $browser->{file_being_viewed}->{manifest_entry};
		$browser->{mtn}->get_file(\$contents,
					  $manifest_entry->{file_id});

		# Try and work out the mime type, first based on contents and
		# then based on the file name extension.

		if (! defined($mime_type =
			       Gnome2::VFS->get_mime_type_for_data($contents))
		    || $mime_type eq "text/plain")
		{
		    my $name = $browser->{file_being_viewed}->{short_name};
		    foreach my $item (@text_mime_types)
		    {
			if ($name =~ m/$item->{pattern}/)
			{
			    $mime_type = $item->{type};
			    last;
			}
		    }
		}

		# Override some mis-identified types.

		$mime_type = "image/svg+xml"
		    if ($mime_type eq "text/xml"
			&& $browser->{file_being_viewed}->{short_name}
			    =~ m/.*\.svg$/o);

		# If it's image data then attempt to render it.

		if ($mime_type =~ m/^image\/.+$/o)
		{
		    eval
		    {
			my $loader = Gtk2::Gdk::PixbufLoader->new();
			$loader->write($contents);
			$loader->close();
			$browser->{file_view_svbuffer}->insert_pixbuf
			    ($browser->{file_view_svbuffer}->get_start_iter(),
			     $loader->get_pixbuf());
		    };
		    $browser->{file_view_svbuffer}->
			set_text("<" . $mime_type . ">\n") if ($@ ne "");
		}
		else
		{

		    my $ok_to_render = 0;

		    # Attempt to syntax highlight the file if it looks safe.

		    if ($mime_type =~ m/^application\/.+$/o)
		    {
			my $part;
			($part) = ($mime_type =~ m/^application\/(.+)$/o);
			foreach my $item (@text_viewable_app_mime_types)
			{
			    if ($part eq $item)
			    {
				$ok_to_render = 1;
				last;
			    }
			}
		    }

		    if ($mime_type =~ m/^text\/.+$/o || $ok_to_render)
		    {
			if (defined($lang = $browser->{file_view_svlangmgr}->
				    get_language_from_mime_type($mime_type)))
			{
			    $browser->{file_view_svbuffer}->
				set("highlight", TRUE);
			    $browser->{file_view_svbuffer}->
				set_language($lang);
			}

			# Load in the contents.

			$browser->{file_view_svbuffer}->set_text($contents);
			foreach my $widget
			    (@{$browser->{text_file_sensitive_group}})
			{
			    $widget->set_sensitive(TRUE);
			}
		    }
		    else
		    {
			$browser->{file_view_svbuffer}->
			    set("highlight", FALSE);
			$browser->{file_view_svbuffer}->
			    set_text("<" . $mime_type . ">\n");
		    }

		}

		# Scroll back up to the top left.

		if ($browser->{file_view_scrolledwindow}->realized())
		{
		    $browser->{file_view_scrolledwindow}->
			get_vadjustment()->set_value(0);
		    $browser->{file_view_scrolledwindow}->
			get_hadjustment()->set_value(0);
		}

		# Update the file details labels.

		if (! exists($manifest_entry->{last_changed_revision}))
		{
		    my(@certs_list,
		       @revision_ids,
		       @revision_list);
		    get_revision_ids($browser, \@revision_ids);
		    $browser->{mtn}->
			get_content_changed(\@revision_list,
					    $revision_ids[0],
					    $manifest_entry->{name});
		    $manifest_entry->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "date")
			{
			    my $last_update;
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $manifest_entry->{last_update} = $last_update;
			    last;
			}
		    }
		}
		set_label_value($browser->{file_name_label},
				$manifest_entry->{name});
		set_label_value($browser->{file_id_label},
				$manifest_entry->{file_id});
		set_label_value($browser->{last_update_label},
				$manifest_entry->{last_update});
		set_label_value($browser->{file_revision_id_label},
				$manifest_entry->{last_changed_revision});
	    }
	}
	else
	{

	    # Reset the file view buffer.

	    $browser->{file_button_vbox}->set_sensitive(FALSE);
	    $browser->{file_view_svbuffer}->set_text("");
	    $browser->{file_view_svbuffer}->set("highlight", FALSE);
	    set_label_value($browser->{file_name_label}, "");
	    set_label_value($browser->{file_id_label}, "");
	    set_label_value($browser->{last_update_label}, "");
	    set_label_value($browser->{file_revision_id_label}, "");

	}

    }

    if ($changed & FILE)
    {
    }

    $browser->{appbar}->pop();
    make_busy($browser, 0);

}
#
##############################################################################
#
#   Routine      - update_advanced_find_state
#
#   Description  - Given a value and a list, work out the largest unique
#                  match. Used for auto completion.
#
#   Data         - $advanced_find : The advanced find dialog window instance
#                                   that is to have its state updated.
#                  $changed       : What the user has changed.
#
##############################################################################



sub update_advanced_find_state($$)
{

    my($advanced_find, $changed) = @_;

    make_busy($advanced_find, 1);
    $advanced_find->{appbar}->push("");
    gtk2_update();

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the branch selection.

	$advanced_find->{branch_combo_details}->{completion_cache} = {};
	if (! $advanced_find->{branch_combo_details}->{preset})
	{
	    $advanced_find->{branch_combo_details}->{completed} = 0;
	    $advanced_find->{branch_combo_details}->{value} = "";
	}
	$advanced_find->{branch_combo_details}->{preset} = 0;

	# Get the new list of branches.

	$advanced_find->{appbar}->set_status("Fetching branch list");
	gtk2_update();
	$advanced_find->{mtn}->branches(\@branch_list)
	    if (defined($advanced_find->{mtn}));
	$advanced_find->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$advanced_find->{appbar}->set_status("Populating branch list");
	gtk2_update();
	my $counter = 1;
	$advanced_find->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $advanced_find->{branch_combo}->append_text($branch);
	    $advanced_find->{appbar}->set_progress_percentage
		($counter ++ / scalar(@branch_list));
	    gtk2_update();
	}
	$advanced_find->{branch_combo}->child()->
	    set_text($advanced_find->{branch_combo_details}->{value});
	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$advanced_find->{revision_combo_details}->{completion_cache} = {};
	if (! $advanced_find->{revision_combo_details}->{preset})
	{
	    $advanced_find->{revision_combo_details}->{completed} = 0;
	    $advanced_find->{revision_combo_details}->{value} = "";
	}
	$advanced_find->{revision_combo_details}->{preset} = 0;
	set_label_value($advanced_find->{selected_branch_label}, "");

	# Get the new list of revisions.

	if ($advanced_find->{branch_combo_details}->{completed})
	{
	    $advanced_find->{appbar}->set_status("Fetching revision list");
	    gtk2_update();

	    # Get either a list of tags or revision ids depending upon what the
	    # user has chosen.

	    if ($advanced_find->{tagged_tick}->get_active())
	    {
		my(%dup_list,
		   @list);
		$advanced_find->{mtn}->
		    tags(\@list,
			 $advanced_find->{branch_combo_details}->{value});
		$advanced_find->{appbar}->set_progress_percentage(0.5);
		gtk2_update();
		foreach my $item (@list)
		{
		    if (! exists($dup_list{$item->{tag}}))
		    {
			push(@revision_list, $item->{tag});
			$dup_list{$item->{tag}} = 1;
		    }
		}
	    }
	    else
	    {
		$advanced_find->{mtn}->
		    select(\@revision_list,
			   "b:" . $advanced_find->{branch_combo_details}->
			       {value});
		$advanced_find->{appbar}->set_progress_percentage(0.33);
		gtk2_update();
		$advanced_find->{mtn}->toposort(\@revision_list,
						@revision_list);
		$advanced_find->{appbar}->set_progress_percentage(0.66);
		gtk2_update();
		splice(@revision_list, 0, scalar(@revision_list) - 100);
		@revision_list = reverse(@revision_list);
	    }
	    set_label_value($advanced_find->{selected_branch_label},
			    $advanced_find->{branch_combo_details}->{value});
	    $advanced_find->{appbar}->set_progress_percentage(1);
	    gtk2_update();
	}
	$advanced_find->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("Populating revision list");
	gtk2_update();
	my $counter = 1;
	$advanced_find->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $advanced_find->{revision_combo}->append_text($revision);
	    $advanced_find->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_list));
	    gtk2_update();
	}
	$advanced_find->{revision_combo}->child()->
	    set_text($advanced_find->{revision_combo_details}->{value});
	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of displayed revisions has changed.

    if ($changed & REVISION_LIST)
    {

	my($counter,
	   @revision_ids);

	# Reset the revisions tree view.

	$advanced_find->{revisions_liststore}->clear();
	$advanced_find->{revisions_treeview_details}->{value} = "";

	# Get the list of matching revisions.

	$advanced_find->{appbar}->set_status("Finding revisions");
	gtk2_update();
	if ($advanced_find->{revision_combo_details}->{completed})
	{
	    get_revision_ids($advanced_find, \@revision_ids);
	}

	# Update the revisions tree view.

	$advanced_find->{appbar}->set_status("Populating revision details");
	$counter = 1;
	foreach my $item (@revision_ids)
	{
	    $advanced_find->{revisions_liststore}->
		set($advanced_find->{revisions_liststore}->append(),
		    0, $item);
	    $advanced_find->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_ids));
	    gtk2_update();
	}
	$advanced_find->{revisions_treeview}->scroll_to_point(0, 0)
	    if ($advanced_find->{revisions_treeview}->realized());

	$advanced_find->{appbar}->set_progress_percentage(0);
	$advanced_find->{appbar}->set_status("");
	gtk2_update();

    }

    # The selected revision has changed.

    if ($changed & REVISION_DETAILS)
    {

	$advanced_find->{details_buffer}->set_text("");
	if ($advanced_find->{revisions_treeview_details}->{value} ne "")
	{

	    my($buf,
	       @certs_list,
	       $change_log,
	       $manifest_id,
	       @parent_revision_ids,
	       %revision_data,
	       @revision_details,
	       %seen,
	       @unique);
	    my @types =
		("Added", "Removed", "Changed", "Renamed", "Attributes");

	    # Get all the information about the selected revision.

	    $advanced_find->{mtn}->certs
		(\@certs_list,
		 $advanced_find->{revisions_treeview_details}->{value});
	    $advanced_find->{mtn}->get_revision
		(\@revision_details,
		 $advanced_find->{revisions_treeview_details}->{value});

	    # Pretty print it into the details buffer.

	    $buf = $advanced_find->{details_buffer};
	    foreach my $cert (@certs_list)
	    {
		if ($cert->{name} eq "changelog")
		{
		    $change_log = $cert->{value};
		    $change_log =~ s/\s+$//os;
		}
		else
		{
		    $cert->{value} =~ s/T/ /o if ($cert->{name} eq "date");
		    $buf->insert_with_tags_by_name
			($buf->get_end_iter(),
			 sprintf("%s:\t", ucfirst($cert->{name})),
			 "bold");
		    $buf->insert($buf->get_end_iter(),
				 sprintf("%s\n", $cert->{value}));
		}
	    }
	    $buf->insert_with_tags_by_name
		($buf->get_end_iter(), "\nChange Log:\n", "bold");
	    $buf->insert($buf->get_end_iter(), sprintf("%s\n", $change_log));
	    $buf->insert_with_tags_by_name
		($buf->get_end_iter(), "\nChanges Made:\n", "bold");
	    foreach my $type (@types)
	    {
		$revision_data{$type} = [];
	    }
	    foreach my $change (@revision_details)
	    {
		if ($change->{type} eq "add_dir")
		{
		    push(@{$revision_data{"Added"}}, $change->{name} . "/");
		}
		elsif ($change->{type} eq "add_file")
		{
		    push(@{$revision_data{"Added"}}, $change->{name});
		}
		elsif ($change->{type} eq "delete")
		{
		    push(@{$revision_data{"Removed"}}, $change->{name});
		}
		elsif ($change->{type} eq "patch")
		{
		    push(@{$revision_data{"Changed"}}, $change->{name});
		}
		elsif ($change->{type} eq "rename")
		{
		    push(@{$revision_data{"Renamed"}},
			 $change->{from_name} . " -> " . $change->{to_name});
		}
		elsif ($change->{type} eq "clear")
		{
		    push(@{$revision_data{"Attributes"}},
			 sprintf("%s: %s was cleared",
				 $change->{name},
				 $change->{attribute}));
		}
		elsif ($change->{type} eq "clear" || $change->{type} eq "set")
		{
		    push(@{$revision_data{"Attributes"}},
			 sprintf("%s: %s = %s",
				 $change->{name},
				 $change->{attribute},
				 $change->{value}));
		}
		elsif ($change->{type} eq "old_revision")
		{
		    push(@parent_revision_ids, $change->{revision_id});
		}
		elsif ($change->{type} eq "new_manifest")
		{
		    $manifest_id = $change->{manifest_id};
		}
	    }
	    foreach my $type (@types)
	    {
		if (scalar(@{$revision_data{$type}}) > 0)
		{
		    $buf->insert_with_tags_by_name
			($buf->get_end_iter(),
			 "    " . $type . ":\n", "italics");
		    %seen = ();
		    @unique = sort(grep { ! $seen{$_} ++ }
				   @{$revision_data{$type}});
		    foreach my $line (@unique)
		    {
			$buf->insert($buf->get_end_iter(),
				     "\t" . $line . "\n");
		    }
		}
	    }
	    $buf->insert_with_tags_by_name
		($buf->get_end_iter(), "\nParent revision id(s):\t", "bold");
	    $buf->insert($buf->get_end_iter(),
			 join(" ", @parent_revision_ids) . "\n");
	    $buf->insert_with_tags_by_name
		($buf->get_end_iter(), "Manifest id:\t\t", "bold");
	    $buf->insert($buf->get_end_iter(), $manifest_id);

	    # Scroll back up to the top left.

	    if ($advanced_find->{details_scrolledwindow}->realized())
	    {
		$advanced_find->{details_scrolledwindow}->get_vadjustment()->
		    set_value(0);
		$advanced_find->{details_scrolledwindow}->get_hadjustment()->
		    set_value(0);
	    }

	    set_label_value($advanced_find->{selected_revision_label},
			    $advanced_find->{revisions_treeview_details}->
			        {value});
	}
	else
	{
	    set_label_value($advanced_find->{selected_revision_label}, "");
	}

    }

    $advanced_find->{appbar}->pop();
    make_busy($advanced_find, 0);

}
#
##############################################################################
#
#   Routine      - get_completion
#
#   Description  - Given a value and a list, work out the largest unique
#                  match. Used for auto completion.
#
#   Data         - $value       : The value to be completed.
#                  $list        : A reference to a list containing all
#                                 possible completions.
#                  $result      : A reference to a buffer that is to contain
#                                 the result.
#                  $complete    : A reference to a boolean that is to contain
#                                 a `result is complete' indicator.
#                  $cache       : An optional reference to a hash that will be
#                                 used to cache the hash tree (saved
#                                 recomputation).
#                  Return Value : True if $value was expanded, otherwise false
#                                 if $value had to be truncated due to no
#                                 match (the maximum valid completion is still
#                                 returned in $result).
#
##############################################################################



sub get_completion($$$$;$)
{

    my($value, $list, $result, $complete, $cache) = @_;

    my($char,
       $item,
       $level,
       %local_cache,
       $tree);

    # Work out what cache we are to use.

    $tree = (defined($cache)) ? $cache : \%local_cache;

    # Unless we are given an already built hash tree, build one up for the list
    # of possible items.

    if (scalar(keys(%$tree)) == 0)
    {
	foreach $item (@$list)
	{

	    # Build up nodes for an item.

	    $level = $tree;
	    foreach $char (split(//o, $item))
	    {
		if (! exists($level->{$char}))
		{
		    $level->{$char} = {};
		}
		$level = $level->{$char};
	    }

	    # By adding this dummy node here it stops the auto-complete moving
	    # too far should another item extend beyond this point. I.e. auto
	    # completion stops at `net.venge.monotone.contrib' and not
	    # `net.venge.monotone.contrib.'. You could simply think of this
	    # node as an `end of string' token if you prefer.

	    $level->{""} = "";

	}
    }

    # Lookup value, stopping when it becomes ambiguous or we get to the end of
    # $value.

    $level = $tree;
    $$result = "";
    foreach $char (split(//o, $value))
    {
	last unless (exists($level->{$char}));
	$level = $level->{$char};
	$$result .= $char;
    }

    # Detect truncations.

    return if (length($value) > length($$result));

    # Now try and expand it further.

    while (defined(%$level) && keys(%$level) == 1)
    {
	($char) = keys(%$level);
	$$result .= $char;
	$level = $level->{$char};
    }

    # Detect complete completions (doesn't mean to say that it can't be
    # extended, just that as it stands at the moment $$result does contain a
    # valid unique value).

    if (! defined(%$level) || exists($level->{""}))
    {
	$$complete = 1;
    }
    else
    {
	$$complete = 0;
    }

    return 1;

}
#
##############################################################################
#
#   Routine      - get_dir_contents
#
#   Description  - Given a path and a Monotone manifest, return a subset of
#                  the manifest that represents the contents of just that
#                  directory along with the directory entry names.
#
#   Data         - $path     : The path to the directory from the top level of
#                              the manifest.
#                  $manifest : A reference to a Monotone manifest.
#                  $result   : A reference to a list that is to contain the
#                              result (a list of records containing the short
#                              directory entry name and a reference to the
#                              related manifest entry).
#
##############################################################################



sub get_dir_contents($$$)
{

    my($path, $manifest, $result) = @_;

    my($entry,
       $extract_re,
       $i,
       $match_re,
       $name);

    $i = 0;
    if ($path eq "")
    {
	$match_re = qr/^[^\/]+$/;
	$extract_re = qr/^([^\/]+)$/;
    }
    else
    {
	$match_re = qr/^${path}\/[^\/]+$/;
	$extract_re = qr/^${path}\/([^\/]+)$/;
    }
    @$result = ();
    foreach $entry (@$manifest)
    {
	if ($entry->{name} =~ m/$match_re/)
	{
	    ($name) = ($entry->{name} =~ m/$extract_re/);
	    $$result[$i ++] = {manifest_entry => $entry,
			       name           => $name};
	}
    }

}
#
##############################################################################
#
#   Routine      - mtn_error_handler
#
#   Description  - This routine is called when ever there is a problem with
#                  Monotone.
#
#   Data         - $severity : The severity of the error.
#                  $message  : The error message.
#
##############################################################################



sub mtn_error_handler($$)
{

    my($severity, $message) = @_;

    my $dialog;

    if ($severity eq "warning")
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "warning",
	     "close",
	     sprintf("Problem with monotone request, got:\n<b><i>%s</i></b>\n"
		         . "This should not be happening!",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	die($message);
    }
    else
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "error",
	     "close",
	     sprintf("Monotone process unexpectedly exiting with:\n"
		         . "<b><i>%s</i></b>\n"
		         . "This is fatal, I am going to exit.",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	Gtk2->main_quit() unless (Gtk2->main_level() == 0);
	die($message);
    }

}
#
##############################################################################
#
#   Routine      - sigchld_handler
#
#   Description  - This routine is called when ever a subprocess exits.
#
#   Data         - None.
#
##############################################################################



sub sigchld_handler()
{

    my($pid,
       $status);

    while (($pid = waitpid(-1, WNOHANG)) > 0)
    {
	$status = $?;
	if (WIFEXITED($status) || WIFSIGNALED($status))
	{

	    # If it is an mtn process then close down the relevant object so
	    # that it will automatically restart.

	    foreach my $browser (@browsers)
	    {
		if (exists($browser->{mtn})
		    && $browser->{mtn}->get_pid() == $pid)

		{
		    $browser->{mtn}->closedown();
		    my $dialog = Gtk2::MessageDialog->new
			(undef,
			 ["modal"],
			 "warning",
			 "close",
			 sprintf("The mtn subprocess just unexpectedly\n"
				     . "exited (%s).\n"
				     . "This shouldn't happen.\n"
				     . "It will be restarted when needed.",
				 WIFSIGNALED($status) ?
				     sprintf("terminated by signal %d",
					     WTERMSIG($status)) :
				     sprintf("exited with status %d",
					     WEXITSTATUS($status))));
		    $dialog->run();
		    $dialog->destroy();
		    last;
		}
	    }

	    if (WIFSIGNALED($status))
	    {
	    }
	}
    }
    warn("waitpid failed: $!") if ($pid < 0 && $! != ECHILD);

}
#
##############################################################################
#
#   Routine      - setup_sigchld_handler
#
#   Description  - This routine sets up the handler for SIGCHLD signals.
#
#   Data         - $handler - A reference to the SIGCHLD handler routine.
#
##############################################################################



sub setup_sigchld_handler($)
{

    my $handler = $_[0];

    my($reader,
       $writer);

    # Basically set up a SIGCHLD handler that simply writes a character down an
    # anonymous pipe in order to wake up the actual handler that is registered
    # with Gtk2 as a file activity handler. This is efficient and safer than
    # some alternatives.

    pipe($reader, $writer) or die("pipe failed: $!");
    $SIG{CHLD} = sub { syswrite($writer, "\n", 1); };
    Gtk2::Helper->add_watch(fileno($reader), "in",
			    sub
			    {
				my $buffer;
				sysread($reader, $buffer, 1);
				&$handler();
				return 1;
			    });

}
#
##############################################################################
#
#   Routine      - get_revision_ids
#
#   Description  - This routine returns the currently selected revision id,
#                  whether this is specified via a tag or as a revision id.
#
#   Data         - $instance     : The window instance.
#                  $revision_ids : The list of selected revision ids. Normally
#                                  the list will have at most one element but
#                                  may contain more if the tag isn't unique on
#                                  the current branch.
#
##############################################################################



sub get_revision_ids($$)
{

    my($instance, $revision_ids) = @_;

    @$revision_ids=();
    return unless ($instance->{revision_combo_details}->{completed});
    if ($instance->{tagged_tick}->get_active())
    {
	$instance->{mtn}->
	    select($revision_ids,
		   "t:" . $instance->{revision_combo_details}->{value});
    }
    else
    {
	push(@$revision_ids, $instance->{revision_combo_details}->{value});
    }

}
#
##############################################################################
#
#   Routine      - make_busy
#
#   Description  - This routine simply makes the main window busy or active.
#
#   Data         - $instance : The window instance.
#                  $busy     : True if the window is to be made busy,
#                              otherwise false if the window is to be made
#                              active.
#
##############################################################################



sub make_busy($$)
{

    my($instance, $busy) = @_;

    # Create and store the cursors if we haven't done so already.

    if (! exists($instance->{busy_cursor}))
    {
	$instance->{normal_cursor} = Gtk2::Gdk::Cursor->new("left-ptr");
	$instance->{busy_cursor} = Gtk2::Gdk::Cursor->new("watch");
    }

    # Do it. Make the application bar grab the input when the window is busy,
    # that way we gobble up keyboard and mouse events that could muck up the
    # application state.

    if ($busy)
    {
	$instance->{window}->window()->set_cursor($instance->{busy_cursor});
	Gtk2->grab_add($instance->{appbar});
    }
    else
    {
	$instance->{window}->window()->
	    set_cursor($instance->{normal_cursor});
	Gtk2->grab_remove($instance->{appbar});
    }

}
#
##############################################################################
#
#   Routine      - gtk2_update
#
#   Description  - This routine simply processes all outstanding Gtk2 toolkit
#                  events. This is used to update the GUI whilst the
#                  application is busy doing something.
#
#   Data         - None.
#
##############################################################################



sub gtk2_update()
{

    return if (Gtk2->main_level() == 0);
    while (Gtk2->events_pending())
    {
	Gtk2->main_iteration();
    }

}
#
##############################################################################
#
#   Routine      - set_label_value
#
#   Description  - This routine simply sets the text for the given label and
#                  the tooltip for the parent widget, assumed to be an event
#                  box, to the specified text.
#
#   Data         - $widget : The label widget that has an event box as its
#                            parent.
#                  $value  : The text that the label and tooltip are to be set
#                            to.
#
##############################################################################



sub set_label_value($$)
{

    my($widget, $value) = @_;

    $widget->set_text($value);
    $tooltips->set_tip($widget->parent(), $value);

}
