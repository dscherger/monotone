#!/usr/bin/perl -W
##!/usr/bin/perl -w
##############################################################################
#
#   File Name    - mtn-browse
#
#   Description  - Perl GUI utility for browsing a Monotone database without a
#                  workspace.
#
#   Author       - A.E.Cooper.
#
#   Legal Stuff  - Copyright (c) 2007 Anthony Edward Cooper
#                  <aecooper@coosoft.plus.com>.
#
#                  This library is free software; you can redistribute it
#                  and/or modify it under the terms of the GNU General Public
#                  License as published by the Free Software Foundation;
#                  either version 3 of the License, or (at your option) any
#                  later version.
#
#                  This library is distributed in the hope that it will be
#                  useful, but WITHOUT ANY WARRANTY; without even the implied
#                  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#                  PURPOSE.  See the GNU General Public License for more
#                  details.
#
#                  You should have received a copy of the GNU General Public
#                  License along with this library; if not, write to the Free
#                  Software Foundation, Inc., 59 Temple Place - Suite 330,
#                  Boston, MA  02111-1307  USA.
#
##############################################################################
#
##############################################################################
#
#   GLOBAL DATA FOR THIS MODULE
#
##############################################################################



# ***** REQUIRED VERSION OF PERL *****

require 5.008;

# ***** REQUIRED PACKAGES *****

use lib "/home/aecoope/perl";

use strict;
use integer;
use Glib qw(FALSE TRUE);
use Gnome2;
use Gnome2::VFS -init;
use Gtk2 -init;
set_locale Gtk2;
init Gtk2;
use Gtk2::GladeXML;
use Gtk2::SourceView;
use IPC::Open3;
use Monotone::AutomateStdio;

# Temporary debug stuff.

use Data::Dumper;

# ***** GLOBAL DATA DECLARATIONS *****

# Constants used to represent the different groups of widgets.

use constant BRANCH          => 0x01;
use constant DIRECTORY       => 0x02;
use constant DIRECTORY_VIEW  => 0x04;
use constant DISPLAY_OF_FILE => 0x08;
use constant FILE            => 0x10;
use constant REVISION        => 0x20;

# Constants used to represent the different state changes. Read this as
# `what has just been changed' => `what needs to be updated'.

use constant BRANCH_CHANGED          => (REVISION | DIRECTORY | DIRECTORY_VIEW
					 | FILE | DISPLAY_OF_FILE);
use constant DATABASE_CHANGED        => 0xff;
use constant DIRECTORY_CHANGED       => (DIRECTORY_VIEW | FILE
					 | DISPLAY_OF_FILE);
use constant DISPLAY_OF_FILE_CHANGED => 0x00;
use constant FILE_CHANGED            => (DISPLAY_OF_FILE);
use constant REVISION_CHANGED        => (DIRECTORY | DIRECTORY_VIEW | FILE
					 | DISPLAY_OF_FILE);

# Constants for the columns within the manifest ListStore widget.

use constant RLS_ICON_COLUMN           => 0;
use constant RLS_NAME_COLUMN           => 1;
use constant RLS_DATE_COLUMN           => 2;
use constant RLS_AUTHOR_COLUMN         => 3;
use constant RLS_MANIFEST_ENTRY_COLUMN => 4;

# Text viewable application mime types.

my @text_viewable_app_mime_types =
    qw(postscript
       rtf
       x-awk
       x-cgi
       x-csh
       x-glade
       x-java
       x-javascript
       x-jbuilder-project
       x-perl
       x-php
       x-python
       x-shellscript
       x-troff-man
       x-troff
       xhtml+xml);

# Supported text mime types (used for syntax highlighting.

my @text_mime_types =
    (
     {
	 pattern => qr/.*\.c$/o,
	 type    => "text/x-csrc"
     },
     {
	 pattern => qr/.*\.(C)|(cc)|(cp)|(cpp)|(CPP)|(cxx)|(c\+\+)$/o,
	 type    => "text/x-c++src"
     },
     {
	 pattern => qr/.*\.(h)|(hh)|(H)$/o,
	 type    => "text/x-c++hdr"
     },
     {
	 pattern => qr/.*\.h$/o,
	 type    => "text/x-chdr"
     },
     {
	 pattern => qr/(^[Mm]akefile(\.[^.]+)?)|(.*\.mk)$/o,
	 type    => "text/x-makefile"
     },
     {
	 pattern => qr/.*/o,
	 type    => "text/plain"
     }
    );

# ***** FUNCTIONAL PROTOTYPES FOR THIS FILE *****

# Private routines.

sub combo_changed_cb($$);
sub combo_key_release_event_cb($$$);
sub delete_event_cb($$$);
sub destroy_event_cb($$;$);
sub get_completion($\@\$\$;\%);
sub get_dir_contents($\@\@);
sub manifest_treeview_cursor_changed_cb($$);
sub manifest_treeview_row_activated_cb($$$$);
sub new_browser_instance();
sub update_browser_state($$);
#
##############################################################################
#
#   Routine      - Main Body Of Code
#
#   Description  - This is the main body of code for the mtn-browse script.
#
#   Data         - @_           : The command line arguments.
#                  Return Value : Unix exit code.
#
##############################################################################



{

    my $instance;

    # Initialise the GUI libraries and generate the interface.

    Gnome2::Program->init("mtn-browse", 0.1);

    # Create a browser instance.

    $instance = new_browser_instance();

    Gtk2->main();

    Gnome2::VFS->shutdown();

    exit 0;

}
#
##############################################################################
#
#   Routine      - new_browser_instance
#
#   Description  - Construct a new browser instance record. This creates a new
#                  main window, a new connection to Monotone and initialising
#                  sensible defaults.
#
#   Data         - Return Value : A reference to the newly created browser
#                                 instance record.
#
##############################################################################



sub new_browser_instance()
{

    my(@branch_list,
       $browser,
       $font,
       $renderer,
       $tv_column,
       $div);

    $browser = {};
    $browser->{mtn} = Monotone::AutomateStdio->new();
    $browser->{glade} = Gtk2::GladeXML->new("../mtn-browse.glade");

    # Flag to stop recursive calling of callbacks.

    $browser->{in_cb} = 0;

    # Connect Glade registered signal handlers.

    $browser->{glade}->signal_autoconnect
	(sub
	 {
	     my($callback_name, $widget, $signal_name, $signal_data,
		$connect_object, $after, $user_data) = @_;
	     my $func = $after ? "signal_connect_after" : "signal_connect";
	     $widget->$func($signal_name,
			    $callback_name,
			    $connect_object ? $connect_object : $user_data);
	 },
	 $browser);

    # Get the widgets that we are interested in.

    $browser->{main_window} = $browser->{glade}->get_widget("main_window");
    $browser->{main_appbar} = $browser->{glade}->get_widget("main_appbar");
    $browser->{branch_combo} =
	$browser->{glade}->get_widget("branch_comboboxentry");
    $browser->{revision_combo} =
	$browser->{glade}->get_widget("revision_comboboxentry");
    $browser->{tagged_tick} =
	$browser->{glade}->get_widget("tagged_checkbutton");
    $browser->{directory_combo} =
	$browser->{glade}->get_widget("directory_comboboxentry");
    $browser->{directory_up_button} =
	$browser->{glade}->get_widget("directory_up_button");
    $browser->{manifest_treeview} =
	$browser->{glade}->get_widget("manifest_browser_treeview");
    $browser->{file_view_scrolledwindow} =
	$browser->{glade}->get_widget("file_view_scrolledwindow");

    # Setup the comboboxentry key release signal handlers.

    $browser->{branch_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{directory_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{revision_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);

    # Move the pane separator to a sensible position.

    $div = $browser->{glade}->get_widget("browser_hpaned");
    $div->set_position(300);

    # Setup the comboboxes.

    $browser->{branch_combo}->set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{branch_combo}->set_text_column(0);
    $browser->{branch_combo}->set_wrap_width(2);
    $browser->{directory_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{directory_combo}->set_text_column(0);
    $browser->{directory_combo}->set_wrap_width(2);
    $browser->{revision_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{revision_combo}->set_text_column(0);
    $browser->{revision_combo}->set_wrap_width(2);

    # Setup the tree view file browser.

    $browser->{manifest_liststore} = Gtk2::ListStore->new("Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::Scalar");
    $browser->{manifest_treeview}->set_model($browser->{manifest_liststore});

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_resizable(FALSE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(25);
    $tv_column->set_sort_column_id(RLS_ICON_COLUMN);
    $renderer = Gtk2::CellRendererPixbuf->new();
    $tv_column->pack_start($renderer, TRUE);
    $tv_column->set_attributes($renderer, "stock-id" => RLS_ICON_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("File Name");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(180);
    $tv_column->set_sort_column_id(RLS_NAME_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => RLS_NAME_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Last Update");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(RLS_DATE_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => RLS_DATE_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Author");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(RLS_AUTHOR_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => RLS_AUTHOR_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $browser->{manifest_treeview}->set_search_column(RLS_NAME_COLUMN);

    # $tv_column = $browser->{manifest_treeview}->get_column(RLS_DATE_COLUMN);
    # $browser->{manifest_treeview}->remove_column($tv_column);

    # Setup the file file viewer (with syntax highlighting).

    $browser->{file_view_svbuffer} = Gtk2::SourceView::Buffer->new(undef);
    $browser->{file_view_svbuffer}->set_max_undo_levels(0);
    $browser->{file_view_svbuffer}->begin_not_undoable_action();
    $browser->{file_view_svlangmgr} =
	Gtk2::SourceView::LanguagesManager->new();
    $browser->{file_view_sv} = Gtk2::SourceView::View->
	new_with_buffer($browser->{file_view_svbuffer});
    $font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $browser->{file_view_sv}->modify_font($font) if (defined($font));
    $browser->{file_view_sv}->set_cursor_visible(FALSE);
    $browser->{file_view_sv}->set_editable(FALSE);
    $browser->{glade}->get_widget("file_view_scrolledwindow")->
	add($browser->{file_view_sv});
    $browser->{file_view_sv}->show_all();

    # Update the browser'a internal state.

    update_browser_state($browser, DATABASE_CHANGED);

    return $browser;

}
#
##############################################################################
#
#   Routine      - combo_changed_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by selecting an entry from its pulldown
#                  list.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub combo_changed_cb($$)
{

    my($widget, $browser) = @_;

    my ($change_state,
	$combo_details,
	$item,
	$value);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    if ($widget == $browser->{branch_combo})
    {
	$change_state = BRANCH_CHANGED;
	$combo_details = $browser->{branch_combo_details};
    }
    elsif ($widget == $browser->{revision_combo})
    {
	$change_state = REVISION_CHANGED;
	$combo_details = $browser->{revision_combo_details};
    }
    elsif ($widget == $browser->{directory_combo})
    {
	$change_state = DIRECTORY_CHANGED;
	$combo_details = $browser->{directory_combo_details};
    }
    else
    {
	return;
    }

    # For some reason best known to itself, Gtk+ calls this callback when the
    # user presses a key for the first time (but not subsequently) after a
    # value is selected via the pulldown menu. So we have to guard against
    # this. Under these circumstances the key release callback is also called.
    # So, put simply, only do something inside this callback if the value is a
    # direct match to one in our list.

    $value = $widget->child()->get_text();
    foreach $item (@{$combo_details->{list}})
    {
	if ($value eq $item)
	{
	    $combo_details->{value} = $value;
	    $combo_details->{completed} = 1;
	    $browser->{main_appbar}->set_status("");
	    update_browser_state($browser, $change_state);
	    last;
	}
    }

}
#
##############################################################################
#
#   Routine      - combo_key_release_event_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by entering a character (key release
#                  event).
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub combo_key_release_event_cb($$$)
{

    my($widget, $event, $browser) = @_;

    my ($change_state,
	$combo,
	$combo_details,
	$completed,
	$completion,
	$item,
	$len,
	$name,
	$old_completed,
	$old_value,
	$value);

    return FALSE if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    if ($widget == $browser->{branch_combo}->child())
    {
	$combo = $browser->{branch_combo};
	$change_state = BRANCH_CHANGED;
	$combo_details = $browser->{branch_combo_details};
	$name = "branch";
    }
    elsif ($widget == $browser->{revision_combo}->child())
    {
	$combo = $browser->{revision_combo};
	$change_state = REVISION_CHANGED;
	$combo_details = $browser->{revision_combo_details};
	$name = "revision";
    }
    elsif ($widget == $browser->{directory_combo}->child())
    {
	$combo = $browser->{directory_combo};
	$change_state = DIRECTORY_CHANGED;
	$combo_details = $browser->{directory_combo_details};
	$name = "directory";
    }
    else
    {
	return FALSE;
    }

    # The user has typed something in then validate it and auto-complete it if
    # necessary.

    $completed = 0;
    $old_completed = $combo_details->{completed};
    $old_value = $combo_details->{value};
    $value = $widget->get_text();
    if ($value ne $combo_details->{value})
    {

	# Don't auto-complete if the user is simply deleting from the extreme
	# right.

	$len = length($value);
	if ($value ne substr($combo_details->{value}, 0, $len))
	{

	    # So that the spacebar triggers auto-complete.

	    $value =~ s/\s+$//o;
	    $old_value = $value;
	    $len = length($value);

	    if (get_completion($value,
			       @{$combo_details->{list}},
			       $completion,
			       $completed,
			       %{$combo_details->{completion_cache}}))
	    {
		$browser->{main_appbar}->set_status("");
	    }
	    else
	    {
		$browser->{main_appbar}->set_status
		    ("Invalid " . $name . " name`" . $value . "'");
	    }
	    $value = $completion;
	    $len = length($value);
	    $widget->set_text($value);
	    $widget->set_position(-1);

	}
	$combo_details->{value} = $value;
	$combo_details->{last_typed_len} = length($value);
	$combo_details->{completed} = $completed;

	# Update the pulldown choices.

	$combo->get_model()->clear();
	foreach $item (@{$combo_details->{list}})
	{
	    $combo->append_text($item) if ($value eq substr($item, 0, $len));
	    $combo_details->{completed} = 1
		if (! $completed && $value eq $item);
	}

	# Update the browser state on a significant change.

	update_browser_state($browser, $change_state)
	    if ($combo_details->{completed} != $old_completed
		|| $combo_details->{value} ne $old_value);

    }

    return FALSE;

}
#
##############################################################################
#
#   Routine      - directory_up_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the up
#                  directory button.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub directory_up_button_clicked_cb
{

    my($widget, $browser) = @_;

    my($len,
       $value);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Simply go up one directory level in the manifest if we aren't already at
    # the top.

    $value = $browser->{directory_combo_details}->{value};
    if ($value ne "")
    {
	if ($value =~ m/^.+\/.+/o)
	{
	    if ($value =~ m/^(.+)\/[^\/]+$/o)
	    {
		($value) = ($value =~ m/^(.+)\/[^\/]+$/o);
	    }
	    else
	    {
		($value) = ($value =~ m/^(.+)\/$/o)
	    }
	}
	else
	{
	    $value = "";
	}
	$browser->{directory_combo_details}->{value} = $value;
	$browser->{directory_combo_details}->{completed} = 1;
	$len = length($value);
	if ($len < $browser->{directory_combo_details}->{last_typed_len})
	{
	    $browser->{directory_combo}->get_model()->clear();
	    foreach my $item (@{$browser->{directory_combo_details}->{list}})
	    {
		$browser->{directory_combo}->append_text($item)
		    if ($value eq substr($item, 0, $len));
	    }
	    $browser->{directory_combo_details}->{last_typed_len} = $len;
	}
	$browser->{directory_combo}->child()->set_text($value);
	$browser->{main_appbar}->set_status("");
	update_browser_state($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - manifest_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by entering a character (key release
#                  event).
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub manifest_treeview_cursor_changed_cb($$)
{

    return;

    my($widget, $browser) = @_;

    my $iter;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    $iter = $browser->{manifest_liststore}->append();
    $browser->{manifest_liststore}->set($iter,
					RLS_ICON_COLUMN, "gtk-open",
					RLS_NAME_COLUMN, "the-main-dir",
					RLS_DATE_COLUMN, "2005-01-01");
    $iter = $browser->{manifest_liststore}->append();
    $browser->{manifest_liststore}->set($iter,
					RLS_ICON_COLUMN, "gtk-open",
					RLS_NAME_COLUMN, "another-main-dir",
					RLS_DATE_COLUMN, "2005-02-01");
    foreach (1..5)
    {
	$iter = $browser->{manifest_liststore}->append();
	$browser->{manifest_liststore}->set($iter,
					    RLS_ICON_COLUMN, "gtk-file",
					    RLS_NAME_COLUMN, "filexxxxxxxxxxxxxxxxxxddddddddskjhdkshskjhdjshdjshdkshdkshdskjd",
					    RLS_DATE_COLUMN, "2005-02-01");
    }



    print "CC " . scalar(@_) . "\n";
    return FALSE;
    print "CC : " . Dumper \@_;
    return FALSE;


}
#
##############################################################################
#
#   Routine      - manifest_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  a ComboBoxEntry by entering a character (key release
#                  event).
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#
##############################################################################



sub manifest_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $browser) = @_;

    my(@list,
       $manifest_entry,
       $short_name);

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    # Get the manifest entry details for the item that was double-clicked.

    $widget->get_selection()->selected_foreach
	(sub
	 {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, RLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, RLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a directory then change to it, if it is a file then
    # display its contents.

    if ($manifest_entry->{type} eq "directory")
    {
	$browser->{directory_combo_details}->{value} = $manifest_entry->{name};
	$browser->{directory_combo_details}->{completed} = 1;
	$browser->{directory_combo}->child()->
	    set_text($manifest_entry->{name});
	$browser->{main_appbar}->set_status("");
	update_browser_state($browser, DIRECTORY_CHANGED);
    }
    else
    {
	$browser->{file_being_viewed} = {short_name     => $short_name,
					 manifest_entry => $manifest_entry};
	$browser->{main_appbar}->set_status("");
	update_browser_state($browser, FILE_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - delete_event_cb
#
#   Description  - Callback routine called when the used has attempted to
#                  close the main window.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub delete_event_cb($$$)
{

    my($widget, $event, $browser) = @_;

    return FALSE;

}
#
##############################################################################
#
#   Routine      - destroy_event_cb
#
#   Description  - Callback routine called when the main window is about to be
#                  destroyed.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $client_data : The client data associated with this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub destroy_event_cb($$;$)
{

    my($widget, $event, $client_data) = @_;

    my $browser = defined($client_data) ? $client_data : $event;

    Gtk2->main_quit();

    return FALSE;

}
#
##############################################################################
#
#   Routine      - update_browser_state
#
#   Description  - Given a value and a list, work out the largest unique
#                  match. Used for auto completion.
#
#   Data         - $browser : The browser instance that is to have its state
#                             updated.
#                  $changed : What the user has changed.
#
##############################################################################



sub update_browser_state($$)
{

    my($browser, $changed) = @_;

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the branch selection.

	$browser->{branch_combo_details}->{completion_cache} = {};
	$browser->{branch_combo_details}->{completed} = 0;
	$browser->{branch_combo_details}->{value} = "";

	# Get the new list of branches.

	$browser->{mtn}->branches(\@branch_list) if (defined($browser->{mtn}));
	$browser->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$browser->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $browser->{branch_combo}->append_text($branch);
	}
	$browser->{branch_combo}->child()->set_text("");

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$browser->{revision_combo_details}->{completion_cache} = {};
	$browser->{revision_combo_details}->{completed} = 0;
	$browser->{revision_combo_details}->{value} = "";

	# Get the new list of revisions.

	if ($browser->{branch_combo_details}->{completed})
	{
	    $browser->{mtn}->select(\@revision_list,
				    "b:" .
				    $browser->{branch_combo_details}->{value});
	    $browser->{mtn}->toposort(\@revision_list, @revision_list);
	    splice(@revision_list, 0, scalar(@revision_list) - 100);
	    @revision_list = reverse(@revision_list);
	}
	$browser->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$browser->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $revision = "i:" . $revision;
	    $browser->{revision_combo}->append_text($revision);
	}
	$browser->{revision_combo}->child()->set_text("");

    }

    # The list of available files and directories has changed.

    if ($changed & DIRECTORY)
    {

	my(@directory_list,
	   @manifest_list,
	   $revision);

	# Reset the directory combo.

	$browser->{directory_combo_details}->{completion_cache} = {};
	$browser->{directory_combo_details}->{completed} = 0;
	$browser->{directory_combo_details}->{last_typed_len} = 0;
	$browser->{directory_combo_details}->{value} = "";

	# Reset the name of the file being viewed.

	$browser->{file_being_viewed} = {};

	# Get the new manifest.

	if ($browser->{revision_combo_details}->{completed})
	{
	    $revision = $browser->{revision_combo_details}->{value};
	    $revision =~ s/^i://o;
	    $browser->{mtn}->get_manifest_of(\@manifest_list, $revision);
	}
	$browser->{manifest} = \@manifest_list;

	# Generate a simple list of directories for auto completion.

	foreach my $item (@manifest_list)
	{
	    push(@directory_list, $item->{name})
		if ($item->{type} eq "directory");
	}
	$browser->{directory_combo_details}->{list} = \@directory_list;

	# Update the directory list combobox.

	$browser->{directory_combo}->get_model()->clear();
	foreach my $item (@directory_list)
	{
	    $browser->{directory_combo}->append_text($item);
	}
	$browser->{directory_combo}->child()->set_text("");

    }

    # The list of displayed files and directories has changed.

    if ($changed & DIRECTORY_VIEW)
    {

	my($author,
	   @certs_list,
	   @directory_entry_list,
	   $last_update,
	   @revision_list,
	   $revision);

	# Reset the manifest tree view.

	$browser->{manifest_liststore}->clear();

	# Get the contents of the new directory.

	if ($browser->{directory_combo_details}->{completed}
	    || $browser->{directory_combo_details}->{value} eq "")
	{
	    get_dir_contents($browser->{directory_combo_details}->{value},
			     @{$browser->{manifest}},
			     @directory_entry_list);
	}

	# Disable the directory up button if we are already at the top level,
	# otherwise make sure it is enabled.

	$browser->{directory_up_button}->set_sensitive
	    (($browser->{directory_combo_details}->{value} eq "")
	     ? FALSE : TRUE);

	# Update the directory tree view.

	$revision = $browser->{revision_combo_details}->{value};
	$revision =~ s/^i://o;
	foreach my $item (@directory_entry_list)
	{

	    # Get the latest modification time if the entry is a file (caching
	    # the result in the manifest for future reference if we have to
	    # work it out).

	    if ($item->{manifest_entry}->{type} eq "file")
	    {
		if (! exists($item->{manifest_entry}->{author}))
		{
		    $browser->{mtn}->get_content_changed
			(\@revision_list,
			 $revision,
			 $item->{manifest_entry}->{name});
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    $author = $last_update = "";
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "author")
			{
			    $author = $cert->{value};
			    $item->{manifest_entry}->{author} = $author;
			}
			if ($cert->{name} eq "date")
			{
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $item->{manifest_entry}->{last_update} =
				$last_update;
			}
			last if ($author ne "" && $last_update ne "");
		    }
		}
		else
		{
		    $author = $item->{manifest_entry}->{author};
		    $last_update = $item->{manifest_entry}->{last_update};
		}
	    }
	    else
	    {
		$author = "";
		$last_update = "";
	    }

	    # Put the entry into the liststore.

	    $browser->{manifest_liststore}->
		set($browser->{manifest_liststore}->append(),
		    RLS_ICON_COLUMN,
		        ($item->{manifest_entry}->{type} eq "directory")
		        ? "gtk-open" : "gtk-file",
		    RLS_NAME_COLUMN, $item->{name},
		    RLS_DATE_COLUMN, $last_update,
		    RLS_AUTHOR_COLUMN, $author,
		    RLS_MANIFEST_ENTRY_COLUMN, $item->{manifest_entry});

	}

	$browser->{manifest_treeview}->scroll_to_point(0, 0)
	    if ($browser->{manifest_treeview}->realized());

    }

    # The displayed file contents has changed.

    if ($changed & DISPLAY_OF_FILE)
    {

	my($contents,
	   $lang,
	   $mime_type,
	   $scrolled_window);

	# Reset the file view buffer.

	$browser->{file_view_svbuffer}->set_text("");
	$browser->{file_view_svbuffer}->set("highlight", FALSE);

	# Load up the selected file's contents into the file viewer.

	if (exists($browser->{file_being_viewed}->{short_name}))
	{

	    # Get contents.

	    $browser->{mtn}->get_file
		(\$contents,
		 $browser->{file_being_viewed}->{manifest_entry}->{file_id});

	    # Try and work out the mime type, first based on contents and then
	    # based on the file name extension.

	    if (! defined($mime_type =
			   Gnome2::VFS->get_mime_type_for_data($contents))
		|| $mime_type eq "text/plain")
	    {
		my $name = $browser->{file_being_viewed}->{short_name};
		foreach my $item (@text_mime_types)
		{
		    if ($name =~ m/$item->{pattern}/)
		    {
			$mime_type = $item->{type};
			last;
		    }
		}
	    }

	    # Override some mis-identified types.

	    $mime_type = "image/svg+xml"
		if ($mime_type eq "text/xml"
		    && $browser->{file_being_viewed}->{short_name}
		        =~ m/.*\.svg$/o);

	    # If it's image data then attempt to render it.

	    if ($mime_type =~ m/^image\/.+$/o)
	    {
		eval
		{
		    my $loader = Gtk2::Gdk::PixbufLoader->new();
		    $loader->write($contents);
		    $loader->close();
		    $browser->{file_view_svbuffer}->insert_pixbuf
			($browser->{file_view_svbuffer}->get_start_iter(),
			 $loader->get_pixbuf());
		};
		$browser->{file_view_svbuffer}->
		    set_text("<" . $mime_type . ">\n") if ($@ ne "");
	    }
	    else
	    {

		my $ok_to_render = 0;

		# Attempt to syntax highlight the file if it looks safe.

		if ($mime_type =~ m/^application\/.+$/o)
		{
		    my $part;
		    ($part) = ($mime_type =~ m/^application\/(.+)$/o);
		    foreach my $item (@text_viewable_app_mime_types)
		    {
			if ($part eq $item)
			{
			    $ok_to_render = 1;
			    last;
			}
		    }
		}

		if ($mime_type =~ m/^text\/.+$/o || $ok_to_render)
		{
		    if (defined($lang = $browser->{file_view_svlangmgr}->
				get_language_from_mime_type($mime_type)))
		    {
			$browser->{file_view_svbuffer}->set("highlight", TRUE);
			$browser->{file_view_svbuffer}->set_language($lang);
		    }

		    # Load in the contents.

		    $browser->{file_view_svbuffer}->set_text($contents);
		}
		else
		{
		    $browser->{file_view_svbuffer}->set("highlight", FALSE);
		    $browser->{file_view_svbuffer}->
			set_text("<" . $mime_type . ">\n");
		}

	    }

	    # Scroll back up to the top left.

	    if ($browser->{file_view_scrolledwindow}->realized())
	    {
		$browser->{file_view_scrolledwindow}->
		    get_vadjustment()->set_value(0);
		$browser->{file_view_scrolledwindow}->
		    get_hadjustment()->set_value(0);
	    }

	}

    }

    if ($changed & FILE)
    {
    }

}
#
##############################################################################
#
#   Routine      - get_completion
#
#   Description  - Given a value and a list, work out the largest unique
#                  match. Used for auto completion.
#
#   Data         - $value       : The value to be completed.
#                  $list        : A reference to a list containing all
#                                 possible completions.
#                  $result      : A reference to a buffer that is to contain
#                                 the result.
#                  $complete    : A reference to a buffer that is to contain a
#                                 boolean `result is complete' indicator.
#                  $cache       : An optional reference to a hash that will be
#                                 used to cache the hash tree (saved
#                                 recomputation).
#                  Return Value : True if $value was expanded, otherwise false
#                                 if $value had to be truncated due to no
#                                 match (the maximum valid completion is still
#                                 returned in $result).
#
##############################################################################



sub get_completion($\@\$\$;\%)
{

    my($value, $list, $result, $complete, $cache) = @_;

    my($char,
       $item,
       $level,
       %local_cache,
       $tree);

    # Work out what cache we are to use.

    $tree = (defined($cache)) ? $cache : \%local_cache;

    # Unless we are given an already built hash tree, build one up for the list
    # of possible items.

    if (scalar(keys(%$tree)) == 0)
    {
	foreach $item (@$list)
	{

	    # Build up nodes for an item.

	    $level = $tree;
	    foreach $char (split(//o, $item))
	    {
		if (! exists($level->{$char}))
		{
		    $level->{$char} = {};
		}
		$level = $level->{$char};
	    }

	    # By adding this dummy node here it stops the auto-complete moving
	    # too far should another item extend beyond this point. I.e. auto
	    # completion stops at `net.venge.monotone.contrib' and not
	    # `net.venge.monotone.contrib.'. You could simply think of this
	    # node as an `end of string' token if you prefer.

	    $level->{""} = "";

	}
    }

    # Lookup value, stopping when it becomes ambiguous or we get to the end of
    # $value.

    $level = $tree;
    $$result = "";
    foreach $char (split(//o, $value))
    {
	last unless (exists($level->{$char}));
	$level = $level->{$char};
	$$result .= $char;
    }

    # Detect truncations.

    return if (length($value) > length($$result));

    # Now try and expand it further.

    while (defined(%$level) && keys(%$level) == 1)
    {
	($char) = keys(%$level);
	$$result .= $char;
	$level = $level->{$char};
    }

    # Detect complete completions (doesn't mean to say that it can't be
    # extended, just that as it stands at the moment $$result does contain a
    # valid unique value).

    if (! defined(%$level) || exists($level->{""}))
    {
	$$complete = 1;
    }
    else
    {
	$$complete = 0;
    }

    return 1;

}
#
##############################################################################
#
#   Routine      - get_dir_contents
#
#   Description  - Given a path and a Monotone manifest, return a subset of
#                  the manifest that represents the contents of just that
#                  directory along with the directory entry names.
#
#   Data         - $path     : The path to the directory from the top level of
#                              the manifest.
#                  $manifest : A reference to a Monotone manifest.
#                  $result   : A reference to a list that is to contain the
#                              result (a list of records containing the short
#                              directory entry name and a reference to the
#                              related manifest entry).
#
##############################################################################



sub get_dir_contents($\@\@)
{

    my($path, $manifest, $result) = @_;

    my($entry,
       $extract_re,
       $i,
       $match_re,
       $name);

    $i = 0;
    if ($path eq "")
    {
	$match_re = qr/^[^\/]+$/;
	$extract_re = qr/^([^\/]+)$/;
    }
    else
    {
	$match_re = qr/^${path}\/[^\/]+$/;
	$extract_re = qr/^${path}\/([^\/]+)$/;
    }
    @$result = ();
    foreach $entry (@$manifest)
    {
	if ($entry->{name} =~ m/$match_re/)
	{
	    ($name) = ($entry->{name} =~ m/$extract_re/);
	    $$result[$i ++] = {manifest_entry => $entry,
			       name           => $name};
	}
    }

}
