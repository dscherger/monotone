#!/usr/bin/perl -W
##!/usr/bin/perl -w
##############################################################################
#
#   File Name    - mtn-browse
#
#   Description  - Perl GUI utility for browsing a Monotone database without a
#                  workspace.
#
#   Author       - A.E.Cooper.
#
#   Legal Stuff  - Copyright (c) 2007 Anthony Edward Cooper
#                  <aecooper@coosoft.plus.com>.
#
#                  This program is free software; you can redistribute it
#                  and/or modify it under the terms of the GNU General Public
#                  License as published by the Free Software Foundation;
#                  either version 3 of the License, or (at your option) any
#                  later version.
#
#                  This program is distributed in the hope that it will be
#                  useful, but WITHOUT ANY WARRANTY; without even the implied
#                  warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
#                  PURPOSE. See the GNU General Public License for more
#                  details.
#
#                  You should have received a copy of the GNU General Public
#                  License along with this software; if not, write to the Free
#                  Software Foundation, Inc., 59 Temple Place - Suite 330,
#                  Boston, MA 02111-1307 USA.
#
##############################################################################
#
##############################################################################
#
#   Global Data For This Module
#
##############################################################################



# ***** DIRECTIVES *****

require 5.008;

use lib "/home/aecoope/perl";
use strict;

# ***** REQUIRED PACKAGES *****

# Standard Perl and CPAN modules.

use Glib qw(FALSE TRUE);
use Gnome2;
use Gnome2::VFS -init;
use Gtk2 -init;
set_locale Gtk2;
init Gtk2;
use Gtk2::GladeXML;
use Gtk2::Helper;
use Gtk2::Pango;
use Gtk2::SourceView;
use IPC::Open3;
use Monotone::AutomateStdio;
use POSIX qw(:errno_h :sys_wait_h);
use POSIX qw(strftime);
use Symbol qw(gensym);
use Text::Tabs;

# Temporary debug stuff.

use Data::Dumper;

# Modules specific to this application.

use Globals qw(:constants :variables);
use AdvancedFind;
use Annotate;
use ChangeLog;
use ComboAutoCompletion;
use Completion;
use History;
use Utilities;

# ***** GLOBAL DATA DECLARATIONS *****

# Constants for the columns within the manifest ListStore widget.

use constant MLS_ICON_COLUMN           => 0;
use constant MLS_NAME_COLUMN           => 1;
use constant MLS_DATE_COLUMN           => 2;
use constant MLS_AUTHOR_COLUMN         => 3;
use constant MLS_MANIFEST_ENTRY_COLUMN => 4;

# ***** FUNCTIONAL PROTOTYPES FOR THIS FILE *****

# Private routines.

sub advanced_find_button_clicked_cb($$);
sub annotate_button_clicked_cb($$);
sub delete_event_cb($$$);
sub destroy_event_cb($$;$);
sub directory_up_button_clicked_cb($$);
sub file_change_history_button_clicked_cb($$);
sub manifest_browser_treeview_cursor_changed_cb($$);
sub manifest_browser_treeview_row_activated_cb($$$$);
sub mtn_error_handler($$);
sub new_browser_instance();
sub revision_change_history_button_clicked_cb($$);
sub revision_change_log_button_clicked_cb($$);
sub setup_sigchld_handler($);
sub sigchld_handler();
sub update_browser_state($$);
#
##############################################################################
#
#   Routine      - Main Body Of Code
#
#   Description  - This is the main body of code for the mtn-browse script.
#
#   Data         - @_           : The command line arguments.
#                  Return Value : Unix exit code.
#
##############################################################################



{

    # Initialise the libraries and generate the interface.

    Gnome2::Program->init("mtn-browse", 0.1);
    Monotone::AutomateStdio->register_error_handler("both",
						    \&mtn_error_handler);
    setup_sigchld_handler(\&sigchld_handler);
    $tooltips = Gtk2::Tooltips->new();
    $app_icon = Gtk2::Gdk::Pixbuf->new_from_file("../mtn-browse.png");
    $line_image = Gtk2::Gdk::Pixbuf->new_from_file("../line.png");
    new_browser_instance();

    # Hand control over to Gtk2.

    Gtk2->main();

    # Cleanup.

    foreach my $window (@windows)
    {
	$window->{window}->destroy();
    }
    @windows = ();
    Gnome2::VFS->shutdown();
    $SIG{CHLD} = "IGNORE";

    exit(0);

}
#
##############################################################################
#
#   Routine      - tagged_checkbutton_toggled_cb
#
#   Description  - Callback routine called when the user changes the value of
#                  the tagged check button.
#
#   Data         - $widget   : The widget object that received the signal.
#                  $instance : The window instance that is associated with
#                              this widget.
#
##############################################################################



sub tagged_checkbutton_toggled_cb($$)
{

    my($widget, $instance) = @_;

    return if ($instance->{in_cb});
    local $instance->{in_cb} = 1;

    $instance->{appbar}->clear_stack();
    &{$instance->{update_handler}}($instance, BRANCH_CHANGED);

}
#
##############################################################################
#
#   Routine      - advanced_find_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  advanced find button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub advanced_find_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my(@branches,
       $preset_branch,
       $revision_id,
       $state);

    if (advanced_find($browser, \$revision_id, \@branches))
    {

	# Preset branch name. If we already have a selected branch then try and
	# match branch names, if that fails then just pick the first name.

	$preset_branch = 1;
	$state = BRANCH_CHANGED;
	if ($browser->{branch_combo_details}->{completed})
	{
	    foreach my $name (@branches)
	    {
		if ($name eq $browser->{branch_combo_details}->{value})
		{
		    $preset_branch = 0;
		    last;
		}
	    }
	}
	if ($preset_branch)
	{
	    $browser->{branch_combo_details}->{preset} = 1;
	    $browser->{branch_combo_details}->{completed} = 1;
	    $browser->{branch_combo_details}->{value} = $branches[0];
	    $state = DATABASE_CHANGED;
	}

	# Preset revision id.

	$browser->{revision_combo_details}->{preset} = 1;
	$browser->{revision_combo_details}->{completed} = 1;
	$browser->{revision_combo_details}->{value} = $revision_id;

	# A revision id is what is returned so switch off the listing of tag
	# names.

	$browser->{tagged_tick}->set_active(FALSE);

	&{$browser->{update_handler}}($browser, $state);

    }

}
#
##############################################################################
#
#   Routine      - revision_change_history_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  revision change history button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub revision_change_history_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    get_revision_ids($browser, \@revision_ids);
    display_revision_change_history($browser->{mtn}, $revision_ids[0]);

}
#
##############################################################################
#
#   Routine      - revision_change_log_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  revision change log button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub revision_change_log_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    # Get the currently selected revision id and then display its change log.

    get_revision_ids($browser, \@revision_ids);
    display_change_log($browser->{mtn},
		       $revision_ids[0],
		       "",
		       $browser->{revision_combo_details}->{value});

}
#
##############################################################################
#
#   Routine      - directory_up_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the up
#                  directory button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub directory_up_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($len,
       $value);

    # Simply go up one directory level in the manifest if we aren't already at
    # the top.

    $value = $browser->{directory_combo_details}->{value};
    if ($value ne "")
    {
	if ($value =~ m/^.+\/.+/o)
	{
	    if ($value =~ m/^(.+)\/[^\/]+$/o)
	    {
		($value) = ($value =~ m/^(.+)\/[^\/]+$/o);
	    }
	    else
	    {
		($value) = ($value =~ m/^(.+)\/$/o)
	    }
	}
	else
	{
	    $value = "";
	}
	$browser->{directory_combo_details}->{value} = $value;
	$browser->{directory_combo_details}->{completed} = 1;
	$len = length($value);
	if ($len < $browser->{directory_combo_details}->{last_typed_len})
	{
	    $browser->{directory_combo}->get_model()->clear();
	    foreach my $item (@{$browser->{directory_combo_details}->{list}})
	    {
		$browser->{directory_combo}->append_text($item)
		    if ($value eq substr($item, 0, $len));
	    }
	    $browser->{directory_combo_details}->{last_typed_len} = $len;
	}
	$browser->{directory_combo}->child()->set_text($value);
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - annotate_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the
#                  annotate button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub annotate_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    get_revision_ids($browser, \@revision_ids);
    display_annotation($browser->{mtn},
		       $revision_ids[0],
		       $browser->{file_being_viewed}->{manifest_entry}->
		           {name});

}
#
##############################################################################
#
#   Routine      - file_change_history_button_clicked_cb
#
#   Description  - Callback routine called when the user clicks on the file
#                  change history button in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub file_change_history_button_clicked_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my @revision_ids;

    get_revision_ids($browser, \@revision_ids);
    display_file_change_history($browser->{mtn},
				$revision_ids[0],
				$browser->{file_being_viewed}->
				    {manifest_entry}->{name});

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_cursor_changed_cb
#
#   Description  - Callback routine called when the user selects an entry in
#                  the manifest treeview in a main browser window.
#
#   Data         - $widget  : The widget object that received the signal.
#                  $browser : The browser instance that is associated with
#                             this widget.
#
##############################################################################



sub manifest_browser_treeview_cursor_changed_cb($$)
{

    my($widget, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($manifest_entry,
       $short_name);

    # Get the manifest entry details for the item that was selected.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a file then display its contents, otherwise if it is a
    # directory then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "file")
    {
	$browser->{file_being_viewed} = {short_name     => $short_name,
					 manifest_entry => $manifest_entry};
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, FILE_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - manifest_browser_treeview_row_activated_cb
#
#   Description  - Callback routine called when the user double clicks on an
#                  entry in the manifest treeview in a main browser window.
#
#   Data         - $widget           : The widget object that received the
#                                      signal.
#                  $tree_path        : A Gtk2::TreePath object for the
#                                      selected item.
#                  $tree_view_column : A Gtk2::TreeViewColumn object for the
#                                      selected item.
#                  $browser          : The browser instance that is associated
#                                      with this widget.
#
##############################################################################



sub manifest_browser_treeview_row_activated_cb($$$$)
{

    my($widget, $tree_path, $tree_view_column, $browser) = @_;

    return if ($browser->{in_cb});
    local $browser->{in_cb} = 1;

    my($manifest_entry,
       $short_name);

    # Get the manifest entry details for the item that was double-clicked.

    $widget->get_selection()->selected_foreach
	(sub {
	     my($model, $path, $iter) = @_;
	     $short_name = $model->get($iter, MLS_NAME_COLUMN);
	     $manifest_entry = $model->get($iter, MLS_MANIFEST_ENTRY_COLUMN);
	 });

    # If the item is a directory then change to it, otherwise if it is a file
    # then just ignore it.

    if (defined($manifest_entry) && $manifest_entry->{type} eq "directory")
    {
	$browser->{directory_combo_details}->{value} = $manifest_entry->{name};
	$browser->{directory_combo_details}->{completed} = 1;
	$browser->{directory_combo}->child()->
	    set_text($manifest_entry->{name});
	$browser->{appbar}->clear_stack();
	&{$browser->{update_handler}}($browser, DIRECTORY_CHANGED);
    }

}
#
##############################################################################
#
#   Routine      - delete_event_cb
#
#   Description  - Callback routine called when the used has attempted to
#                  close the main window.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $browser     : The browser instance that is associated with
#                                 this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub delete_event_cb($$$)
{

    my($widget, $event, $browser) = @_;

    if ($browser->{in_cb})
    {
	return TRUE;
    }
    else
    {
	return FALSE;
    }

}
#
##############################################################################
#
#   Routine      - destroy_event_cb
#
#   Description  - Callback routine called when the main window is about to be
#                  destroyed.
#
#   Data         - $widget      : The widget object that received the signal.
#                  $event       : A Gtk2::Gdk::Event object describing the
#                                 event that has occurred.
#                  $client_data : The client data associated with this widget.
#                  Return Value : TRUE if the event has been handled and needs
#                                 no further handling, otherwise false if the
#                                 event should carry on through the remaining
#                                 event handling.
#
##############################################################################



sub destroy_event_cb($$;$)
{

    my($widget, $event, $client_data) = @_;

    my $browser = defined($client_data) ? $client_data : $event;

    Gtk2->main_quit();

    return FALSE;

}
#
##############################################################################
#
#   Routine      - new_browser_instance
#
#   Description  - Construct a new browser instance record. This creates a new
#                  main window, a new connection to Monotone and initialising
#                  sensible defaults.
#
#   Data         - Return Value : A reference to the newly created browser
#                                 instance record.
#
##############################################################################



sub new_browser_instance()
{

    my($browser,
       $font,
       $image,
       $renderer,
       $tv_column,
       $div);

    $browser = {};
    $browser->{type} = "browser_window";
    $browser->{mtn} = Monotone::AutomateStdio->new();
    $browser->{glade} =
	Gtk2::GladeXML->new("../mtn-browse.glade", "main_window");

    # Flag to stop recursive calling of callbacks.

    $browser->{in_cb} = 0;

    # Connect Glade registered signal handlers.

    glade_signal_autoconnect($browser->{glade}, $browser);

    # Link in the update handler for the browser.

    $browser->{update_handler} = \&update_browser_state;

    # Get the widgets that we are interested in.

    $browser->{window} = $browser->{glade}->get_widget("main_window");
    $browser->{window}->set_icon($app_icon);
    $browser->{appbar} = $browser->{glade}->get_widget("appbar");
    $browser->{branch_combo} =
	$browser->{glade}->get_widget("branch_comboboxentry");
    $browser->{revision_combo} =
	$browser->{glade}->get_widget("revision_comboboxentry");
    $browser->{tagged_tick} =
	$browser->{glade}->get_widget("tagged_checkbutton");
    $browser->{directory_combo} =
	$browser->{glade}->get_widget("directory_comboboxentry");
    $browser->{directory_up_button} =
	$browser->{glade}->get_widget("directory_up_button");
    $browser->{manifest_treeview} =
	$browser->{glade}->get_widget("manifest_browser_treeview");
    $browser->{file_view_scrolledwindow} =
	$browser->{glade}->get_widget("file_view_scrolledwindow");
    $browser->{file_name_label} =
	$browser->{glade}->get_widget("file_name_value_label");
    $browser->{file_id_label} =
	$browser->{glade}->get_widget("file_id_value_label");
    $browser->{last_update_label} =
	$browser->{glade}->get_widget("last_update_value_label");
    $browser->{file_revision_id_label} =
	$browser->{glade}->get_widget("file_revision_id_value_label");
    $browser->{file_button_vbox} =
	$browser->{glade}->get_widget("file_button_vbox");
    $browser->{database_name_label} =
	$browser->{glade}->get_widget("database_name_value_label");
    $browser->{revision_id_label} =
	$browser->{glade}->get_widget("revision_id_value_label");
    $browser->{author_label} =
	$browser->{glade}->get_widget("author_value_label");
    $browser->{change_log_label} =
	$browser->{glade}->get_widget("change_log_value_label");

    # Setup button sensitivity groups.

    $browser->{text_file_sensitive_group} = ();
    foreach my $item ("search_text", "annotate")
    {
	push(@{$browser->{text_file_sensitive_group}},
	     $browser->{glade}->get_widget($item . "_button"));
    }
    $browser->{revision_sensitive_group} = ();
    foreach my $item ("revision_change_history", "revision_change_log")
    {
	push(@{$browser->{revision_sensitive_group}},
	     $browser->{glade}->get_widget($item . "_button"));
    }

    # Setup the comboboxentry key release signal handlers.

    $browser->{branch_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{directory_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);
    $browser->{revision_combo}->child()->
	signal_connect("key_release_event",
		       \&combo_key_release_event_cb,
		       $browser);

    # Move the pane separator to a sensible position.

    # $div = $browser->{glade}->get_widget("browser_hpaned");
    # $div->set_position(300);

    # Setup the comboboxes.

    $browser->{branch_combo}->set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{branch_combo}->set_text_column(0);
    $browser->{branch_combo}->set_wrap_width(2);
    $browser->{directory_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{directory_combo}->set_text_column(0);
    $browser->{directory_combo}->set_wrap_width(2);
    $browser->{revision_combo}->
	set_model(Gtk2::ListStore->new("Glib::String"));
    $browser->{revision_combo}->set_text_column(0);
    $browser->{revision_combo}->set_wrap_width(2);

    # Setup the tree view manifest file browser.

    $browser->{manifest_liststore} = Gtk2::ListStore->new("Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::String",
							  "Glib::Scalar");
    $browser->{manifest_treeview}->set_model($browser->{manifest_liststore});

    $tv_column = Gtk2::TreeViewColumn->new();
    $image = Gtk2::Image->new_from_stock("gtk-file", "menu");
    $image->show_all();
    $tv_column->set_widget($image);
    $tv_column->set_resizable(FALSE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(25);
    $tv_column->set_sort_column_id(MLS_ICON_COLUMN);
    $renderer = Gtk2::CellRendererPixbuf->new();
    $tv_column->pack_start($renderer, TRUE);
    $tv_column->set_attributes($renderer, "stock-id" => MLS_ICON_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("File Name");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("fixed");
    $tv_column->set_fixed_width(180);
    $tv_column->set_sort_column_id(MLS_NAME_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_NAME_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Last Update");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(MLS_DATE_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_DATE_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $tv_column = Gtk2::TreeViewColumn->new();
    $tv_column->set_title("Author");
    $tv_column->set_resizable(TRUE);
    $tv_column->set_sizing("grow-only");
    $tv_column->set_sort_column_id(MLS_AUTHOR_COLUMN);
    $renderer = Gtk2::CellRendererText->new();
    $tv_column->pack_start($renderer, FALSE);
    $tv_column->set_attributes($renderer, "text" => MLS_AUTHOR_COLUMN);
    $browser->{manifest_treeview}->append_column($tv_column);

    $browser->{manifest_treeview}->set_search_column(MLS_NAME_COLUMN);

    # $tv_column = $browser->{manifest_treeview}->get_column(MLS_DATE_COLUMN);
    # $browser->{manifest_treeview}->remove_column($tv_column);

    # Setup the file file viewer (with syntax highlighting).

    $browser->{file_view_svbuffer} = Gtk2::SourceView::Buffer->new(undef);
    $browser->{file_view_svbuffer}->set_max_undo_levels(0);
    $browser->{file_view_svbuffer}->begin_not_undoable_action();
    $browser->{file_view_svlangmgr} =
	Gtk2::SourceView::LanguagesManager->new();
    $browser->{file_view_sv} = Gtk2::SourceView::View->
	new_with_buffer($browser->{file_view_svbuffer});
    $font = Gtk2::Pango::FontDescription->from_string("monospace 10");
    $browser->{file_view_sv}->modify_font($font) if (defined($font));
    $browser->{file_view_sv}->set_cursor_visible(FALSE);
    $browser->{file_view_sv}->set_editable(FALSE);
    $browser->{glade}->get_widget("file_view_scrolledwindow")->
	add($browser->{file_view_sv});
    $browser->{file_view_sv}->show_all();

    $browser->{window}->show_all();

    # Update the browser's internal state.

    $browser->{branch_combo_details}->{preset} = 0;
    $browser->{revision_combo_details}->{preset} = 0;
    &{$browser->{update_handler}}($browser, DATABASE_CHANGED);

    # Setup the list of windows that can be made busy for this application
    # window.

    $browser->{busy_windows} = [];
    push(@{$browser->{busy_windows}}, $browser->{window}->window());
    push(@{$browser->{busy_windows}},
	 $browser->{file_view_sv}->get_window("text"));

    push(@windows, $browser);

    return $browser;

}
#
##############################################################################
#
#   Routine      - update_browser_state
#
#   Description  - Update the display of the specified browser instance
#                  according to the specified state.
#
#   Data         - $browser : The browser instance that is to have its state
#                             updated.
#                  $changed : What the user has changed.
#
##############################################################################



sub update_browser_state($$)
{

    my($browser, $changed) = @_;

    make_busy($browser, 1);
    $browser->{appbar}->push("");
    gtk2_update();

    # The list of available branches has changed.

    if ($changed & BRANCH)
    {

	my @branch_list;

	# Reset the branch selection.

	$browser->{branch_combo_details}->{completion} = undef;
	if (! $browser->{branch_combo_details}->{preset})
	{
	    $browser->{branch_combo_details}->{completed} = 0;
	    $browser->{branch_combo_details}->{value} = "";
	}
	$browser->{branch_combo_details}->{preset} = 0;
	set_label_value($browser->{database_name_label}, "<WorkSpace>");

	# Get the new list of branches.

	$browser->{appbar}->set_status("Fetching branch list");
	gtk2_update();
	$browser->{mtn}->branches(\@branch_list) if (defined($browser->{mtn}));
	$browser->{branch_combo_details}->{list} = \@branch_list;

	# Update the branch list combobox.

	$browser->{appbar}->set_status("Populating branch list");
	gtk2_update();
	my $counter = 1;
	$browser->{branch_combo}->get_model()->clear();
	foreach my $branch (@branch_list)
	{
	    $browser->{branch_combo}->append_text($branch);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@branch_list));
	    gtk2_update();
	}
	$browser->{branch_combo}->child()->
	    set_text($browser->{branch_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available revisions has changed.

    if ($changed & REVISION)
    {

	my @revision_list;

	# Reset the revision selection.

	$browser->{revision_combo_details}->{completion} = undef;
	if (! $browser->{revision_combo_details}->{preset})
	{
	    $browser->{revision_combo_details}->{completed} = 0;
	    $browser->{revision_combo_details}->{value} = "";
	}
	$browser->{revision_combo_details}->{preset} = 0;

	# Get the new list of revisions.

	if ($browser->{branch_combo_details}->{completed})
	{
	    $browser->{appbar}->set_status("Fetching revision list");
	    gtk2_update();

	    # Get either a list of tags or revision ids depending upon what the
	    # user has chosen.

	    if ($browser->{tagged_tick}->get_active())
	    {
		my(%dup_list,
		   @list);
		$browser->{mtn}->
		    tags(\@list, $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.5);
		gtk2_update();
		foreach my $item (@list)
		{
		    if (! exists($dup_list{$item->{tag}}))
		    {
			push(@revision_list, $item->{tag});
			$dup_list{$item->{tag}} = 1;
		    }
		}
	    }
	    else
	    {
		$browser->{mtn}->
		    select(\@revision_list,
			   "b:" . $browser->{branch_combo_details}->{value});
		$browser->{appbar}->set_progress_percentage(0.33);
		gtk2_update();
		$browser->{mtn}->toposort(\@revision_list, @revision_list);
		$browser->{appbar}->set_progress_percentage(0.66);
		gtk2_update();
		splice(@revision_list, 0, scalar(@revision_list) - 100);
		@revision_list = reverse(@revision_list);
	    }
	    $browser->{appbar}->set_progress_percentage(1);
	    gtk2_update();
	}
	$browser->{revision_combo_details}->{list} = \@revision_list;

	# Update the revision list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating revision list");
	gtk2_update();
	my $counter = 1;
	$browser->{revision_combo}->get_model()->clear();
	foreach my $revision (@revision_list)
	{
	    $browser->{revision_combo}->append_text($revision);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@revision_list));
	    gtk2_update();
	}
	$browser->{revision_combo}->child()->
	    set_text($browser->{revision_combo_details}->{value});
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The list of available files and directories has changed.

    if ($changed & DIRECTORY)
    {

	my(@directory_list,
	   @manifest_list);

	# Reset the directory combo.

	$browser->{directory_combo_details}->{completion} = undef;
	$browser->{directory_combo_details}->{completed} = 0;
	$browser->{directory_combo_details}->{last_typed_len} = 0;
	$browser->{directory_combo_details}->{value} = "";
	set_label_value($browser->{revision_id_label}, "");
	set_label_value($browser->{author_label}, "");
	set_label_value($browser->{change_log_label}, "");

	# Reset the name of the file being viewed.

	$browser->{file_being_viewed} = {};

	# Get the new manifest.

	$browser->{appbar}->set_status("Fetching manifest");
	gtk2_update();
	if ($browser->{revision_combo_details}->{completed})
	{
	    my @revision_ids;
	    get_revision_ids($browser, \@revision_ids);
	    if (scalar(@revision_ids) > 1)
	    {
		my $message;
		$message =
		    sprintf("The `%s' tag is not unique on this branch.\n"
			        . "Please either select the revision by its "
			            . "id\n"
			        . "or use the <i>Advanced Find</i> feature.\n"
			        . "The matching revision ids are:",
			    $browser->{revision_combo_details}->{value});
		foreach my $item (@revision_ids)
		{
		    $message .= "\n" . Glib::Markup::escape_text($item);
		}
		my $dialog = Gtk2::MessageDialog->new_with_markup
		    ($browser->{window}, ["modal"], "info", "close", $message);
		$dialog->run();
		$dialog->destroy();
		$browser->{revision_combo_details}->{completed} = 0;
		$browser->{revision_combo_details}->{value} = "";
		$browser->{revision_combo}->child()->set_text("");
	    }
	    else
	    {
		my($author,
		   @certs_list,
		   $change_log);
		$browser->{mtn}->get_manifest_of(\@manifest_list,
						 $revision_ids[0]);
		$browser->{mtn}->certs(\@certs_list, $revision_ids[0]);
		$author = $change_log = "";
		foreach my $cert (@certs_list)
		{
		    $author = $cert->{value}
		        if ($cert->{name} eq "author");
		    if ($cert->{name} eq "changelog")
		    {
			$change_log = $cert->{value};
			$change_log =~ s/\s+$//os;
		    }
		}
		set_label_value($browser->{revision_id_label},
				$revision_ids[0]);
		set_label_value($browser->{author_label}, $author);
		set_label_value($browser->{change_log_label}, $change_log);
	    }
	}
	$browser->{manifest} = \@manifest_list;

	# Generate a simple list of directories for auto completion.

	$browser->{appbar}->set_progress_percentage(0.5);
	gtk2_update();
	foreach my $item (@manifest_list)
	{
	    push(@directory_list, $item->{name})
		if ($item->{type} eq "directory");
	}
	$browser->{directory_combo_details}->{list} = \@directory_list;
	$browser->{appbar}->set_progress_percentage(1);
	gtk2_update();

	# Update the directory list combobox.

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("Populating directory list");
	gtk2_update();
	my $counter = 1;
	$browser->{directory_combo}->get_model()->clear();
	foreach my $item (@directory_list)
	{
	    $browser->{directory_combo}->append_text($item);
	    $browser->{appbar}->set_progress_percentage
		($counter ++ / scalar(@directory_list));
	    gtk2_update();
	}
	$browser->{directory_combo}->child()->set_text("");
	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	foreach my $widget (@{$browser->{revision_sensitive_group}})
	{
	    $widget->
		set_sensitive($browser->{revision_combo_details}->{completed});
	}
	gtk2_update();

    }

    # The list of displayed files and directories has changed.

    if ($changed & DIRECTORY_VIEW)
    {

	my($author,
	   @certs_list,
	   $counter,
	   @directory_entry_list,
	   $last_update,
	   @revision_ids,
	   @revision_list,
	   $taking_our_time);

	# Reset the manifest tree view.

	$browser->{manifest_liststore}->clear();

	# Get the contents of the new directory.

	if ($browser->{directory_combo_details}->{completed}
	    || $browser->{directory_combo_details}->{value} eq "")
	{
	    get_dir_contents($browser->{directory_combo_details}->{value},
			     $browser->{manifest},
			     \@directory_entry_list);
	}

	# Disable the directory up button if we are already at the top level,
	# otherwise make sure it is enabled.

	$browser->{directory_up_button}->set_sensitive
	    (($browser->{directory_combo_details}->{value} eq "")
	     ? FALSE : TRUE);

	# Update the directory tree view.

	$browser->{appbar}->set_status("Populating file details");
	$counter = 1;
	$taking_our_time = 0;
	get_revision_ids($browser, \@revision_ids);
	foreach my $item (@directory_entry_list)
	{

	    # Get the latest modification time and the author if the entry is a
	    # file (caching the result in the manifest for future reference if
	    # we have to work it out).

	    if ($item->{manifest_entry}->{type} eq "file")
	    {
		if (! exists($item->{manifest_entry}->{author}))
		{
		    $taking_our_time = 1;
		    $browser->{mtn}->get_content_changed
			(\@revision_list,
			 $revision_ids[0],
			 $item->{manifest_entry}->{name});
		    $item->{manifest_entry}->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    $author = $last_update = "";
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "author")
			{
			    $author = $cert->{value};
			    $item->{manifest_entry}->{author} = $author;
			}
			if ($cert->{name} eq "date")
			{
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $item->{manifest_entry}->{last_update} =
				$last_update;
			}
			last if ($author ne "" && $last_update ne "");
		    }
		}
		else
		{
		    $author = $item->{manifest_entry}->{author};
		    $last_update = $item->{manifest_entry}->{last_update};
		}
	    }
	    else
	    {
		$author = "";
		$last_update = "";
	    }

	    # Put the entry into the liststore.

	    $browser->{manifest_liststore}->
		set($browser->{manifest_liststore}->append(),
		    MLS_ICON_COLUMN,
		        ($item->{manifest_entry}->{type} eq "directory")
		        ? "gtk-open" : "gtk-file",
		    MLS_NAME_COLUMN, $item->{name},
		    MLS_DATE_COLUMN, $last_update,
		    MLS_AUTHOR_COLUMN, $author,
		    MLS_MANIFEST_ENTRY_COLUMN, $item->{manifest_entry});

	    if ($taking_our_time)
	    {
		$browser->{appbar}->set_progress_percentage
		    ($counter / scalar(@directory_entry_list));
		gtk2_update();
	    }
	    ++ $counter;

	}

	$browser->{manifest_treeview}->scroll_to_point(0, 0)
	    if ($browser->{manifest_treeview}->realized());

	$browser->{appbar}->set_progress_percentage(0);
	$browser->{appbar}->set_status("");
	gtk2_update();

    }

    # The displayed file contents has changed.

    if ($changed & DISPLAY_OF_FILE)
    {

	# Load up the selected file's contents into the file viewer.

	if (exists($browser->{file_being_viewed}->{manifest_entry}))
	{
	    my $manifest_entry;
	    $manifest_entry =
		$browser->{file_being_viewed}->{manifest_entry};
	    if ($browser->{file_id_label}->get_text()
		ne $manifest_entry->{file_id})
	    {

		my($contents,
		   $lang,
		   $mime_type,
		   $scrolled_window);

		# Reset the file view buffer.

		$browser->{file_button_vbox}->set_sensitive(TRUE);
		foreach my $widget (@{$browser->{text_file_sensitive_group}})
		{
		    $widget->set_sensitive(FALSE);
		}
		$browser->{file_view_svbuffer}->set_text("");
		$browser->{file_view_svbuffer}->set("highlight", FALSE);

		# Get contents.

		$manifest_entry =
		    $browser->{file_being_viewed}->{manifest_entry};
		$browser->{mtn}->get_file(\$contents,
					  $manifest_entry->{file_id});

		# Try and work out the mime type, first based on contents and
		# then based on the file name extension.

		if (! defined($mime_type =
			       Gnome2::VFS->get_mime_type_for_data($contents))
		    || $mime_type eq "text/plain")
		{
		    my $name = $browser->{file_being_viewed}->{short_name};
		    foreach my $item (@text_mime_types)
		    {
			if ($name =~ m/$item->{pattern}/)
			{
			    $mime_type = $item->{type};
			    last;
			}
		    }
		}

		# Override some mis-identified types.

		$mime_type = "image/svg+xml"
		    if ($mime_type eq "text/xml"
			&& $browser->{file_being_viewed}->{short_name}
			    =~ m/.*\.svg$/o);

		# If it's image data then attempt to render it.

		if ($mime_type =~ m/^image\/.+$/o)
		{
		    eval
		    {
			my $loader = Gtk2::Gdk::PixbufLoader->new();
			$loader->write($contents);
			$loader->close();
			$browser->{file_view_svbuffer}->insert_pixbuf
			    ($browser->{file_view_svbuffer}->get_start_iter(),
			     $loader->get_pixbuf());
		    };
		    $browser->{file_view_svbuffer}->
			set_text("<" . $mime_type . ">\n") if ($@ ne "");
		}
		else
		{

		    my $ok_to_render = 0;

		    # Attempt to syntax highlight the file if it looks safe.

		    if ($mime_type =~ m/^application\/.+$/o)
		    {
			my $part;
			($part) = ($mime_type =~ m/^application\/(.+)$/o);
			foreach my $item (@text_viewable_app_mime_types)
			{
			    if ($part eq $item)
			    {
				$ok_to_render = 1;
				last;
			    }
			}
		    }

		    if ($mime_type =~ m/^text\/.+$/o || $ok_to_render)
		    {
			if (defined($lang = $browser->{file_view_svlangmgr}->
				    get_language_from_mime_type($mime_type)))
			{
			    $browser->{file_view_svbuffer}->
				set("highlight", TRUE);
			    $browser->{file_view_svbuffer}->
				set_language($lang);
			}

			# Load in the contents.

			$browser->{file_view_svbuffer}->set_text($contents);
			foreach my $widget
			    (@{$browser->{text_file_sensitive_group}})
			{
			    $widget->set_sensitive(TRUE);
			}
		    }
		    else
		    {
			$browser->{file_view_svbuffer}->
			    set("highlight", FALSE);
			$browser->{file_view_svbuffer}->
			    set_text("<" . $mime_type . ">\n");
		    }

		}

		# Scroll back up to the top left.

		if ($browser->{file_view_scrolledwindow}->realized())
		{
		    $browser->{file_view_scrolledwindow}->
			get_vadjustment()->set_value(0);
		    $browser->{file_view_scrolledwindow}->
			get_hadjustment()->set_value(0);
		}

		# Update the file details labels.

		if (! exists($manifest_entry->{last_changed_revision}))
		{
		    my(@certs_list,
		       @revision_ids,
		       @revision_list);
		    get_revision_ids($browser, \@revision_ids);
		    $browser->{mtn}->
			get_content_changed(\@revision_list,
					    $revision_ids[0],
					    $manifest_entry->{name});
		    $manifest_entry->{last_changed_revision} =
			$revision_list[0];
		    $browser->{mtn}->certs(\@certs_list, $revision_list[0]);
		    foreach my $cert (@certs_list)
		    {
			if ($cert->{name} eq "date")
			{
			    my $last_update;
			    $last_update = $cert->{value};
			    $last_update =~ s/T/ /o;
			    $manifest_entry->{last_update} = $last_update;
			    last;
			}
		    }
		}
		set_label_value($browser->{file_name_label},
				$manifest_entry->{name});
		set_label_value($browser->{file_id_label},
				$manifest_entry->{file_id});
		set_label_value($browser->{last_update_label},
				$manifest_entry->{last_update});
		set_label_value($browser->{file_revision_id_label},
				$manifest_entry->{last_changed_revision});
	    }
	}
	else
	{

	    # Reset the file view buffer.

	    $browser->{file_button_vbox}->set_sensitive(FALSE);
	    $browser->{file_view_svbuffer}->set_text("");
	    $browser->{file_view_svbuffer}->set("highlight", FALSE);
	    set_label_value($browser->{file_name_label}, "");
	    set_label_value($browser->{file_id_label}, "");
	    set_label_value($browser->{last_update_label}, "");
	    set_label_value($browser->{file_revision_id_label}, "");

	}

    }

    if ($changed & FILE)
    {
    }

    $browser->{appbar}->pop();
    make_busy($browser, 0);

}
#
##############################################################################
#
#   Routine      - mtn_error_handler
#
#   Description  - This routine is called when ever there is a problem with
#                  Monotone.
#
#   Data         - $severity : The severity of the error.
#                  $message  : The error message.
#
##############################################################################



sub mtn_error_handler($$)
{

    my($severity, $message) = @_;

    my $dialog;

    if ($severity eq "warning")
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "warning",
	     "close",
	     sprintf("Problem with monotone request, got:\n<b><i>%s</i></b>\n"
		         . "This should not be happening!",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	die($message);
    }
    else
    {
	$dialog = Gtk2::MessageDialog->new_with_markup
	    (undef,
	     ["modal"],
	     "error",
	     "close",
	     sprintf("Monotone process unexpectedly exiting with:\n"
		         . "<b><i>%s</i></b>\n"
		         . "This is fatal, I am going to exit.",
		     Glib::Markup::escape_text($message)));
	$dialog->run();
	$dialog->destroy();
	Gtk2->main_quit() unless (Gtk2->main_level() == 0);
	die($message);
    }

}
#
##############################################################################
#
#   Routine      - sigchld_handler
#
#   Description  - This routine is called when ever a subprocess exits.
#
#   Data         - None.
#
##############################################################################



sub sigchld_handler()
{

    my($pid,
       $status);

    while (($pid = waitpid(-1, WNOHANG)) > 0)
    {
	$status = $?;
	if (WIFEXITED($status) || WIFSIGNALED($status))
	{

	    # If it is an mtn process then close down the relevant object so
	    # that it will automatically restart when needed.

	    foreach my $window (@windows)
	    {
		if (exists($window->{mtn})
		    && $window->{mtn}->get_pid() == $pid)
		{
		    $window->{mtn}->closedown();
		    my $dialog = Gtk2::MessageDialog->new
			(undef,
			 ["modal"],
			 "warning",
			 "close",
			 sprintf("The mtn subprocess just unexpectedly\n"
				     . "exited (%s).\n"
				     . "This shouldn't happen.\n"
				     . "It will be restarted when needed.",
				 WIFSIGNALED($status) ?
				     sprintf("terminated by signal %d",
					     WTERMSIG($status)) :
				     sprintf("exited with status %d",
					     WEXITSTATUS($status))));
		    $dialog->run();
		    $dialog->destroy();
		    last;
		}
	    }

	    if (WIFSIGNALED($status))
	    {
	    }
	}
    }
    warn("waitpid failed: $!") if ($pid < 0 && $! != ECHILD);

}
#
##############################################################################
#
#   Routine      - setup_sigchld_handler
#
#   Description  - This routine sets up the handler for SIGCHLD signals.
#
#   Data         - $handler - A reference to the SIGCHLD handler routine.
#
##############################################################################



sub setup_sigchld_handler($)
{

    my $handler = $_[0];

    my($reader,
       $writer);

    # Basically set up a SIGCHLD handler that simply writes a character down an
    # anonymous pipe in order to wake up the actual handler that is registered
    # with Gtk2 as a file activity handler. This is efficient and safer than
    # some alternatives.

    pipe($reader, $writer) or die("pipe failed: $!");
    $SIG{CHLD} = sub { syswrite($writer, "\n", 1); };
    Gtk2::Helper->add_watch(fileno($reader), "in",
			    sub {
				my $buffer;
				sysread($reader, $buffer, 1);
				&$handler();
				return 1; });

}
