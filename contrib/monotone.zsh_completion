#compdef mtn # -*-sh-*-
#
# Installing into /etc/zsh/:
#
# 1) if not present, add the line "fpath=(/etc/zsh $fpath)" to either 
#    your system wide zshrc, or user ~/.zshrc 
# 2) cp $MONOTONE/contrib/monotone.zsh_completion /etc/zsh/_mtn
#

# redefine _mtn.

_mtn() {
  local extra

  _arguments -s : \
    '--debug[print debug log to stderr while running]'\
    '--dump=[file to dump debugging log to, on failure]:file:_files'\
    '--log=[file to write the log to]:file:_files'\
    '--quiet[suppress log and progress messages]'\
    {'-h','--help'}'[display help message]'\
    '(- *)--version[print version number, then exit]'\
    '(- *)--full-version[print detailed version number, then exit]'\
    {'-@+','--xargs='}'[insert command line arguments taken from the given file]:file:_files'\
    '--ticker=[set ticker style]:style:(count dot none)'\
    '--nostd[do not load standard lua hooks]'\
    '--norc[do not load ~/.monotone/monotonerc or _MTN/monotonerc lua files]'\
    '--rcfile=[load extra rc file]:file:_files'\
    {'-k+','--key='}'[set key for signatures]:keys keys:_mtn_keys'\
    {'-d+','--db='}'[set name of database]:file:_files'\
    '--root=[limit search for working copy to specified root]:dir:_files -/'\
    '--verbose[verbose completion output]'\
    '--keydir=[set location of key store]'\
    '--confdir=[set location of configuration directory]'\
    '*::monotone command:_mtn_command'
}

# define monotone command dispatch function.

(( $+functions[_mtn_command] )) ||
_mtn_command() {
  (( $+_mtn_cmds )) || _mtn_cmds=(add annotate approve attr automate cat cert checkout chkeypass ci co comment commit complete cvs_import db diff disapprove drop dropkey explicit_merge fload fmerge genkey get_roster heads help identify list log ls merge merge_into_dir mv pivot_root privkey propagate pubkey pull push rcs_import read refresh_inodeprints rename revert rm serve set setup show_conflicts status sync tag testresult trusted unset update)

  local cmd="$words[1]"
  if (( CURRENT == 1 )); then
    _describe -t commands 'monotone command' _mtn_cmds
  else
    local curcontext="$curcontext"

    if (( $#cmd )); then
      curcontext="${curcontext%:*:*}:monotone-${cmd}:"
      _call_function ret _mtn_$cmd || _message 'no more arguments'
    else
      _message "unknown monotone command: $cmd"
    fi
    return ret
  fi
}

# define completion functions for each monotone command

(( $+functions[_mtn_add] )) ||
_mtn_add() {
    _arguments -s \
	'(-)--unknown[add unknown files from workspace]'\
	'*:file to add:_mtn_files_unmaintained'
}

(( $+functions[_mtn_annotate] )) ||
_mtn_annotate() {
    _arguments -s \
	{'(-)-r+','(-)--revision='}'[select revision id for operation]:revision:_mtn_revisions'\
	'--brief[print a brief version of the normal output]'\
	'*:file to annotate:_mtn_existing_entries'
}

(( $+functions[_mtn_approve] )) ||
_mtn_approve() {
    _arguments -s \
	{'(-)-b+','(-)--branch='}'[select branch cert for operation]:branch:_mtn_branches'\
	'(*)*:revision:_mtn_revisions'
}

(( $+functions[_mtn_attr] )) ||
_mtn_attr() {
	if (( CURRENT == 2 )); then	
		compadd -- set get drop
	elif (( CURRENT == 3 )); then	
		compadd -- $(mtn automate attributes)
	else
	  local fname="$words[3]";
		compadd -- $(mtn automate attributes $fname)
	fi
}

(( $+functions[_mtn_automate] )) ||
_mtn_automate() {
	compadd -- \
	    ancestors ancestry_difference attributes certs children \
	    descendents erase_ancestors get_file get_manifest_of \
	    get_revision graph heads interface_version inventory keys \
	    leaves packet_for_certs packet_for_fdelta packet_for_rdata \
	    parents select toposort 
}

(( $+functions[_mtn_cat] )) ||
_mtn_cat() {
	if (( CURRENT == 2 )); then	
		compadd -- file manifest revision
	else
	  local mtype="$words[2]"
		if [[ "$mtype" == "revision" ]]; then
			_mtn_revisions
		else
			local id="$words[3]"
			if (( $#id )); then
  			compadd -- $(mtn complete $mtype $id 2> /dev/null)
			fi
	  fi
	fi
}

(( $+functions[_mtn_cert] )) ||
_mtn_cert() {
	_mtn_revisions
}

(( $+functions[_mtn_checkout] )) ||
_mtn_checkout() {
  _arguments \
    '--branch=-[branch name]:branch:_mtn_branches' \
		':revision:_mtn_revisions'
}

(( $+functions[_mtn_chkeypass] )) ||
_mtn_chkeypass() {
	_mtn_keys
}

(( $+functions[_mtn_ci] )) ||
_mtn_ci() {
  _mtn_commit
}

(( $+functions[_mtn_co] )) ||
_mtn_ci() {
  _mtn_checkout
}

(( $+functions[_mtn_comment] )) ||
_mtn_comment() {
	_mtn_revisions
}

(( $+functions[_mtn_commit] )) ||
_mtn_commit() {
  _arguments -s \
    '(-)--message=[logmsg]' \
    '*:modified file:_mtn_existing_entries'
}

(( $+functions[_mtn_complete] )) ||
_mtn_complete() {
	compadd -- file key manifest revision 
}

(( $+functions[_mtn_cvs_import] )) ||
_mtn_cvs_import() {
  _arguments \
	  '*:file:_files'
}

(( $+functions[_mtn_db] )) ||
_mtn_db() {
	compadd -- init info version dump load migrate check rebuild execute kill_rev_locally
}

(( $+functions[_mtn_diff] )) ||
_mtn_diff() {
  _arguments -s \
		'*--revision=:revision:_mtn_revisions' \
	  '*:added file:_mtn_existing_entries'
}

(( $+functions[_mtn_disapprove] )) ||
_mtn_disapprove() {
	_mtn_revisions
}

(( $+functions[_mtn_drop] )) ||
_mtn_drop() {
	_mtn_existing_entries
}

(( $+functions[_mtn_dropkey] )) ||
_mtn_dropkey() {
	_mtn_keys
}

(( $+functions[_mtn_explicit_merge] )) ||
_mtn_explicit_merge() {
  if (( CURRENT == 2 || CURRENT == 3)); then
		_mtn_revisions
	else
	  _mtn_branches
	fi
}

(( $+functions[_mtn_heads] )) ||
_mtn_heads() {
  _arguments -s \
    '--branch=[branch name]:branch:_mtn_branches'
}

(( $+functions[_mtn_log] )) ||
_mtn_log() {
  _arguments -s \
    '--last=[n]' \
		'--revision=:revision:_mtn_revisions' \
	  '*:added file:_mtn_existing_entries'
}

(( $+functions[_mtn_list] )) ||
_mtn_list() {
  _arguments \
		':op:_mtn_list_ops'
}

(( $+functions[_mtn_ls] )) ||
_mtn_ls() {
  _mtn_list
}

(( $+functions[_mtn_merge] )) ||
_mtn_merge() {
  _arguments -s \
    '--branch=[branch name]:branch:_mtn_branches'
}

(( $+functions[_mtn_propagate] )) ||
_mtn_propagate() {
  _mtn_branches
}

(( $+functions[_mtn_pull] )) ||
_mtn_pull() {
  _arguments -s \
		'*:branch:_mtn_branches' 
}

(( $+functions[_mtn_push] )) ||
_mtn_push() {
  _arguments -s \
		'*:branch:_mtn_branches' 
}

(( $+functions[_mtn_rcs_import] )) ||
_mtn_rcs_import() {
  _arguments \
	  '*:file:_files'
}

(( $+functions[_mtn_rename] )) ||
_mtn_rename() {
	_mtn_existing_entries
}

(( $+functions[_mtn_revert] )) ||
_mtn_revert() {
	_mtn_existing_entries
}

(( $+functions[_mtn_serve] )) ||
_mtn_serve() {
  _arguments -s \
		'*:branch:_mtn_branches' 
}

(( $+functions[_mtn_status] )) ||
_mtn_status() {
	_mtn_existing_entries
}

(( $+functions[_mtn_sync] )) ||
_mtn_sync() {
  _arguments -s \
		'*:branch:_mtn_branches' 
}

(( $+functions[_mtn_tag] )) ||
_mtn_tag() {
	_mtn_revisions
}

(( $+functions[_mtn_result] )) ||
_mtn_testresult() {
	_mtn_revisions
}

(( $+functions[_mtn_update] )) ||
_mtn_update() {
	_mtn_revisions
}

# define completion functions for files maintained by monotone.

(( $+functions[_mtn_files_unmaintained] )) ||
_mtn_files_unmaintained() {
	compadd -- $(mtn ls unknown)
}

(( $+functions[_mtn_existing_entries] )) ||
_mtn_existing_entries() {
	for i in $(mtn ls known --depth=0 .); do compadd -- $i:t; done
}

(( $+functions[_mtn_branches] )) ||
_mtn_branches() {
	compadd -- $(mtn ls branches)
}

(( $+functions[_mtn_keys] )) ||
_mtn_keys() {
	local id="$words[CURRENT]:gs/-//"
	if (( $#id )); then
		compadd -X "$(mtn complete key --verbose $id 2>/dev/null)" -n -- $(mtn complete key $id 2>/dev/null)
	fi
}

(( $+functions[_mtn_revisions] )) ||
_mtn_revisions() {
    compadd -X "(prefix of a) revision" -n \
	-- $(mtn complete revision $PREFIX 2>/dev/null)
}

(( $+functions[_mtn_list_ops] )) ||
_mtn_list_ops() {
	compadd -- certs keys branches epochs tags vars known unknown ignored missing
}

_mtn "$@"
