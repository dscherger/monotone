<%

import datetime
import monotone
import common
import config
import urllib
import time
from html import get_icon, TableWriter
from common import get_branch_links

# 
# manifest.psp
# display all information we can about a particular manifest
#

psp.set_error_page("error.psp")

if not form.has_key('id'):
    raise Exception("No revision ID specified.")

id = form['id']
if not monotone.is_valid_id(id):
    raise Exception("Specified revision ID is not valid.")

if not form.has_key('path'):
    path = ''
else:
    path = form['path']
if path.startswith('/'): path = path[1:]
if path.endswith('/'): path = path[-1:]

certs = mt.certs(id)
revision = mt.revision(id)
if not revision.has_key('new_manifest'):
    raise Exception("There is no manifest in this revision ID.")
manifest_id = revision['new_manifest'][0][1]
manifest = mt.manifest(manifest_id)

link_components = ""
components = ['']
components += path.split('/')
for idx, component in enumerate(components[:-1]):
    link_components += link("manifest", [id, '/'.join(components[:idx+1])], component + '/')
link_components += components[-1]
branches = common.extract_cert_from_certs(certs, "branch", as_list=True)
branch_links = get_branch_links(mt, branches)

info = {
    'title' : "Dir '%s' in revision %s of %s" % (link_components,
						  link("revision", id),
						  branch_links)
    }
req.write(template.header(info))
%>

<p>
This page shows files contained within a particular revision; for more information 
about that revision see its page: <%= link("revision", id) %>.
</p>

<p>
All <%=len(manifest)%> files in this manifest can be downloaded together in a <%=link("tar", manifest_id, "tar archive")%>.
</p>

<%

# filter this list of files into two lists;
#   subdirectories of 'path'
#   files in 'path'
# each will contain entries relative to 'path'
#
# NB: the following code will break (perhaps) if monotone ever supports 
# empty subdirectories.
subdirs, files, last_dir = [], [], None
# root dir is depth 0, subdir of that 1, ..
if path == '':
    sp = []
else:
    sp = path.split('/')
depth = len(sp)

for file_id, filename in manifest:
    parts = filename.split('/')

    if len(parts) < depth or parts[:depth] != sp[:depth]:
        continue
    
    if len(parts) > depth + 1 and parts[depth] != last_dir:
        subdirs.append((parts[depth], '/'.join(parts[:depth+1])))
        last_dir = parts[depth]
    elif len(parts) == depth + 1:
        files.append((parts[-1], file_id, filename))

# hopefully this will eventually be less ugly
# 
# we need to find out the revision in which each of the objects in 
# 'files' was last touched. so iterate; get the certs for each ancestor 
# of the current revision, until we have that information for every 
# file in 'files'

ancestors = mt.toposort(mt.ancestors([id]))
ancestors.append(id)
ancestors.reverse() # so we can iterate back through time..
file_to_rev = {}

for name, file_id, file in files:
    file_to_rev[file] = None

found = 0
for ancestor in ancestors:
    rev = mt.revision(ancestor)
    if rev.has_key('old_revision') and len(rev['old_revision']) > 1:
	# this is a merge, exclude from our search
	continue
    for type in rev.keys():
        for stanza in rev[type]:
            affected = None
            if type == "patch" or type == "add_file" or type == "delete_file" or type == "delete_dir":
		affected = stanza[1]
            elif type == "rename_file" or type == "rename_dir": affected = stanza[3]
            if affected != None and file_to_rev.has_key(affected) and file_to_rev[affected] == None:
                file_to_rev[affected] = ancestor
                found += 1
    if found >= len(files): break

revinfo = {}
now = datetime.datetime.utcnow()
for filename in file_to_rev.keys():
    rev = file_to_rev[filename]

    if rev == None:
	certs = []
    else:
	certs = mt.certs(rev)

    ago, author, certdate, quicklog = None, None, None, None
    for cert in certs:
        name, value = None, None
        for k, v in cert:
            if k == "name": name = v
            elif k == "value": value = v
        if name == None or value == None: continue
        if name == "date":
            certdate = apply(datetime.datetime, time.strptime(value, "%Y-%m-%dT%H:%M:%S")[:6])
        elif name == "changelog":
            quicklog = value.strip().split('\n')[0]
            if quicklog.startswith('*'): quicklog = quicklog[1:].strip()
        elif name == "author":
            author = value
    if certdate:
        ago = now - certdate
        if ago.days > 0:
            ago = "%d days" % (ago.days)
        elif ago.seconds > 3600:
            hours = ago.seconds / 3600
            minutes = (ago.seconds - (hours * 3600)) / 60
            ago = "%d hours" % (hours)
        else:
            minutes = ago.seconds / 60
            seconds = (ago.seconds - (minutes * 60))
            ago = "%d minutes" % (minutes)
    revinfo[rev] = (ago, author, quicklog)

if depth != 0:
    subdirs = [('..', '/'.join(sp[:-1]))] + subdirs

tr = TableWriter(req)
tr.start()
tr.write('<th><!-- icon --></th><th>Name</th><th>Age</th><th>Author</th><th>Last log entry</th>', is_header=True)
icon_uri = get_icon('', is_directory=True)
for name, subdir in subdirs:
    tr.write('<td><img border="0" src="%s" /></td><td>%s</a><td></td><td></td><td></td>' % (icon_uri, 
											    link("manifest", 
												 [id, subdir], name)))
for name, file_id, file in files:
    icon_uri = get_icon(file)
    if icon_uri != None:
	icon_code = '<img border="0" src="%s">' % (icon_uri)
    else:
	icon_code = ''
    rev = file_to_rev.get(file, None)
    if not rev:
        tr.write('<td>%s</td><td>&nbsp;%s</td><td></td><td></td><td></td>' % (icon_code, link("file", [id, file], name)))
    else:
        age, author, quicklog = revinfo[rev]
        author = hq(author or "").replace(' ', '&nbsp;')
        quicklog = hq(quicklog or "")
        tr.write('<td>%s</td><td>&nbsp;%s</td><td>&nbsp;%s</td><td>%s</td><td>%s</td>' % (icon_code, \
                link("file", [id, file], name), \
                link("revision", rev, (age or "").replace(' ', '&nbsp;'), no_quote=True),
                author, \
                quicklog))
tr.stop()

%>

</div>

<%

req.write(template.footer(info))

%>

