doc current die-die-die-merge for existence
    http://revctrl.org/DieDieDieMerge

    implemented in roster_merge.cc roster_merge

In a given revision, a node either exists or does not exist. In
addition, a scalar for the node may have different values in different
revisions.

Notation:

    A1a     exists, with node id '1', scalar value 'a'
    A       does not exist

In a child revision with two parents, there are nominally eight cases
depending on where the node exists. We group them into five cases; the
scalar value matters only in the case where the node is dropped on one
side, since changing the scalar value expresses a user intent that the
node exist, which conflicts with the user intent expressed by the
drop.

        A1  B1
i)       \ /
          C1

    The node is merged in the child


        A1  B2
ii)      \ /
          C3

    The node is sutured in the child


        A1  B3
iiia)    \ /
          C3

    Node 3 was born in a suture or split in an uncommon ancestor of B,
    with node 1 as a parent

        A3  B1
iiib)    \ /
          C3

    Node 3 was born in a suture or split in an uncommon ancestor of A,
    with node 1 as a parent


        A1  B
iv)      \ /
          C1

    The node was born in a user add in A's uncommon ancestors

        A   B1
         \ /
          C1

    The node was born in a user add in B's uncommon ancestors


        A1  B
va)      \ /
          C

    The node was deleted in B's uncommon ancestors

        A   B1
vb)      \ /
          C

    The node was deleted in A's uncommon ancestors

       D1a  E1b
        |   |
vc)     A   B1b
         \ /
          C?

    The node was deleted in A's uncommon ancestors, and modified in B's.

       D1b  E1a
        |   |
vd)    A1b  B
         \ /
          C?

    The node was deleted in B's uncommon ancestors, and modified in A's.


In monotone 0.4 and earlier, cases ii, iii, vc and vd did not exist.

Case ii can only happen if we support sutures as user operations; not
yet.

In cases vc and vd, two users have expressed different intent, so we
declare a conflict.

To process all nodes, we loop thru the union of the parent node ids,
deciding which case each node belongs in. We create nodes in the
result roster for cases i thru iv and vc, vd; we don't create a node
for cases va, vb. The mark-merge step only considers nodes that are in
the result roster.

To distinguish cases iii and iv, we need to store information about
how a node was born. This can be done in the marking map, by adding
birth_cause, a pair containing an enumeral and a pair of node_ids. The
enumeral indicates add, suture, or split; if suture, the node_ids
indicate the ancestors. If split, the first node_id indicates the
ancestor.

To distinguish case iiia from va and vc, we search B_uncommon for a
node that is a suture or split and has 1 as an ancestor. If found, it
is case iii. Similarly for iiib and vb; search A_uncommon.

To distinguish case va from vc, we search B_uncommon for the scalar
marks; if found, it is case vc. Similarly for vb, vd; search
A_uncommon.

case iii will show up twice, once for node id 1 and once for node id
3. We want to create only one node in the result roster, with node id
3 (the sutured node id). Since we handle both nodes when we encounter
either, we maintain a set 'already_handled' of already handled nodes;
if a node is in already_handled, we simply ignore it. We also record
ids 1 and 3 as the ancestors of the result node, so we can check for
conflicts in the subsequent mark-merge step.

To handle node 1 in case iii, we search A_uncommon for a node that is
born in a suture or split with node 1 as a parent, create a node in
the result roster for the found node, and add it to already_handled.

To handle node 3 in case iii, we check birth_cause for node 3 in the
marking map. If it is a suture, we create a node for it in the result
map. Then we add both ancestors to already_handled. This is more
efficient than the detection for node 1.

If we process the nodes in decreasing numerical order, the sutured
node will always occur before the non-sutured node. That means we find
case iii more efficiently.

That also simplifies checking for case v; if a node is only in A or B,
was not born in a suture, and is not in already_handled, it is case v.

(end of file)
