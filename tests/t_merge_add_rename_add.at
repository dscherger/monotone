#  -*- Autoconf -*-

AT_SETUP([merging <add a, rename a b> with <add b>])


MONOTONE_SETUP

#              A
#            /   \
#           B     C
#            \   /
#              D
#
# A is the common ancestor, containing 'add foo'.  B contains 'rename foo
# bar'.  C contains 'add bar'.
# Merging B and C gives a tree conflict. If this isn't resolved, it leads
# to a suture. But since both files being sutured exist in C, the suture will
# trigger an I .
# Expect the merge to fail, but check that the tree resolution hook is told
# about the conflict.

AT_DATA(foo, [extra blah blah foo
])
AT_DATA(bar, [extra blah blah bar
])
AT_DATA(dumpconf.lua, [function resolve_path_conflicts(conflicts)
local x = io.open("conf", "w")
x:write(conflicts)
io.close(x)
return nil
end
])

# produce state A
AT_CHECK(MONOTONE add foo, [], [ignore], [ignore])
AT_CHECK(MONOTONE --branch=branch.main commit --message 'state A - add foo', [], [ignore], [ignore])
A_REVISION_SHA=`BASE_REVISION`

# produce state B
AT_CHECK(MONOTONE rename foo bar, [], [ignore], [ignore])
AT_CHECK(mv foo bar, [], [ignore], [ignore])
AT_CHECK(MONOTONE --branch=branch.main commit --message 'state B - rename foo bar', [], [ignore], [ignore])
B_REVISION_SHA=`BASE_REVISION`

# produce state C
REVERT_TO($A_REVISION_SHA)
AT_CHECK(MONOTONE add bar, [], [ignore], [ignore])
AT_CHECK(MONOTONE --branch=branch.main commit --message 'state C - add bar', [], [ignore], [ignore])
C_REVISION_SHA=`BASE_REVISION`

# merge heads to make D
AT_CHECK(MONOTONE --branch=branch.main --rcfile=dumpconf.lua merge, [3], [ignore], [stderr])

AT_CHECK(grep "This may cause crashes." stderr, [], [ignore], [ignore])

AT_CHECK(grep "Type: Collision" conf, [], [ignore], [ignore])

AT_CLEANUP
