AT_SETUP([restricted commands are consistent])
MONOTONE_SETUP

# the following commands accept file arguments and --exclude and --depth
# options used to define a restriction on the files that will be processed:
# 
# ls unknown
# ls ignored
# ls missing
# ls known
# status
# diff
# commit
# revert
#

# this test ensures that these commands operate on the same set of files given
# the same restriction specification.  maintaining consistency across these
# commands allows for destructive commands (commit and revert) to be "tested"
# first with non-destructive commands (ls unknown/ignored/missing/known, status,
# diff)

# macros for running and verifying tests

m4_define([PATCH_FILES], [
AT_DATA(file1, [file1 $1
])
AT_DATA(file2, [file2 $1
])
AT_DATA(foo/foo1, [foo1 $1
])
AT_DATA(foo/foo2, [foo2 $1
])
AT_DATA(foo/bar/bar1, [bar1 $1
])
AT_DATA(foo/bar/bar2, [bar2 $1
])
])

# $1 the monotone command and associated arguments to run
m4_define([RUN], [
AT_CHECK(MONOTONE $1, [], [stdout], [stderr])
])

# $1 0 or 1 to indicate whether grep should find find words in the output or not
# $2 list of words to grep output for
m4_define([GREP], [
for i in $2 
do
AT_CHECK(grep $i output, [$1], [ignore], [ignore])
done
])

# $1 stdout or stderr to be copied to output for grep
# $2 list of words that must exist in output
# $3 list of words that must not exist in output
m4_define([CHECK], [
AT_CHECK(cp $1 output)
GREP(0, $2)
GREP(1, $3)
])

# $1 the monotone command and arguments to run
# $2 stderr or stdout to grep against
# $3 list of words that must exist in output
# $4 list of words that must not exist in output
m4_define([TEST], [
RUN($1)
CHECK($2, $3, $4)
])

# test restrictions and associated lists of included/excluded files

ROOT_ARGS="."
ROOT_INCLUDED="file1 file2 foo/foo1 foo/foo2 foo/bar/bar1 foo/bar/bar2"
ROOT_EXCLUDED=""

INCLUDE_ARGS="file1 foo/foo1 foo/bar/bar1"
INCLUDE_INCLUDED="file1 foo/foo1 foo/bar/bar1"
INCLUDE_EXCLUDED="file2 foo/foo2 foo/bar/bar2"

EXCLUDE_ARGS=". --exclude file1 --exclude foo/foo1 --exclude foo/bar/bar1"
EXCLUDE_INCLUDED="file2 foo/foo2 foo/bar/bar2"
EXCLUDE_EXCLUDED="file1 foo/foo1 foo/bar/bar1"

BOTH_ARGS="foo --exclude foo/foo1 --exclude foo/bar/bar1"
BOTH_INCLUDED="foo/foo2 foo/bar/bar2"
BOTH_EXCLUDED="file1 file2 foo/foo1 foo/bar/bar1"

DEPTH_ARGS=". --depth 1"
DEPTH_INCLUDED="file1 file2 foo/foo1 foo/foo2"
DEPTH_EXCLUDED="foo/bar/bar1 foo/bar/bar2"

# setup working copy

AT_CHECK(mkdir foo)
AT_CHECK(mkdir foo/bar)

PATCH_FILES(initial addition of files)
AT_CHECK(MONOTONE add file1 file2 foo, [], [ignore], [ignore])
COMMIT(testbranch)

# check that ls unknown/ignored/missing/known, status, diff, revert and commit
# all agree on what is included/excluded by various restrictions

# ls unknown 

# dropped files are valid for restriction but are unknown in the post-state
AT_CHECK(MONOTONE drop file1 file2 foo/foo1 foo/foo2 foo/bar/bar1 foo/bar/bar2, [], [ignore], [ignore])
TEST(ls unknown $ROOT_ARGS, stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)
TEST(ls unknown $INCLUDE_ARGS, stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
TEST(ls unknown $EXCLUDE_ARGS, stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)
TEST(ls unknown $BOTH_ARGS, stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)
TEST(ls unknown $DEPTH_ARGS, stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)
AT_CHECK(MONOTONE revert ., [], [ignore], [ignore])

# ls ignored

AT_DATA(ignore.lua, [
function ignore_file(name)
   if (string.find(name, "1$")) then return true end
   if (string.find(name, "2$")) then return true end
   return false
end
])

# only unknown files are considered by ls ignored
AT_CHECK(MONOTONE drop file1 file2 foo/foo1 foo/foo2 foo/bar/bar1 foo/bar/bar2, [], [ignore], [ignore])
TEST(ls ignored --rcfile ignore.lua $ROOT_ARGS, stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)
TEST(ls ignored --rcfile ignore.lua $INCLUDE_ARGS, stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
TEST(ls ignored --rcfile ignore.lua $EXCLUDE_ARGS, stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)
TEST(ls ignored --rcfile ignore.lua $BOTH_ARGS, stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)
TEST(ls ignored --rcfile ignore.lua $DEPTH_ARGS, stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)
AT_CHECK(MONOTONE revert ., [], [ignore], [ignore])

# ls missing

AT_CHECK(rm file1 file2 foo/foo1 foo/foo2 foo/bar/bar1 foo/bar/bar2, [], [ignore], [ignore]) 
TEST(ls missing $ROOT_ARGS, stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)
TEST(ls missing $INCLUDE_ARGS, stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
TEST(ls missing $EXCLUDE_ARGS, stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)
TEST(ls missing $BOTH_ARGS, stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)
TEST(ls missing $DEPTH_ARGS, stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)
AT_CHECK(MONOTONE revert ., [], [ignore], [ignore])

PATCH_FILES(changes for testing ls known, status, diff)

# ls known

TEST(ls known $ROOT_ARGS, stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)
TEST(ls known $INCLUDE_ARGS, stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
TEST(ls known $EXCLUDE_ARGS, stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)
TEST(ls known $BOTH_ARGS, stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)
TEST(ls known $DEPTH_ARGS, stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)

# status

TEST(status $ROOT_ARGS, stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)
TEST(status $INCLUDE_ARGS, stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
TEST(status $EXCLUDE_ARGS, stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)
TEST(status $BOTH_ARGS, stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)
TEST(status $DEPTH_ARGS, stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)

# diff

TEST(diff $ROOT_ARGS, stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)
TEST(diff $INCLUDE_ARGS, stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
TEST(diff $EXCLUDE_ARGS, stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)
TEST(diff $BOTH_ARGS, stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)
TEST(diff $DEPTH_ARGS, stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)

# revert

PATCH_FILES(revert root)
TEST(revert $ROOT_ARGS, stderr, $ROOT_INCLUDED, $ROOT_EXCLUDED)

PATCH_FILES(revert include)
TEST(revert $INCLUDE_ARGS, stderr, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)

PATCH_FILES(revert exclude)
TEST(revert $EXCLUDE_ARGS, stderr, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)

PATCH_FILES(revert both)
TEST(revert $BOTH_ARGS, stderr, $BOTH_INCLUDED, $BOTH_EXCLUDED)

PATCH_FILES(revert depth)
TEST(revert $DEPTH_ARGS, stderr, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)

# commit

OLD=`BASE_REVISION`
PATCH_FILES(commit root)
RUN(commit -m root $ROOT_ARGS)
NEW=`BASE_REVISION`

AT_CHECK(MONOTONE status, [], [stdout], [stderr])
CHECK(stdout, $ROOT_EXCLUDED, $ROOT_INCLUDED)
AT_CHECK(MONOTONE diff -r $OLD -r $NEW, [], [stdout], [ignore])
CHECK(stdout, $ROOT_INCLUDED, $ROOT_EXCLUDED)

OLD=`BASE_REVISION`
PATCH_FILES(commit includes)
RUN(commit -m includes $INCLUDE_ARGS)
NEW=`BASE_REVISION`

AT_CHECK(MONOTONE diff -r $OLD -r $NEW, [], [stdout], [ignore])
CHECK(stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)
AT_CHECK(MONOTONE diff -r $OLD -r $NEW, [], [stdout], [ignore])
CHECK(stdout, $INCLUDE_INCLUDED, $INCLUDE_EXCLUDED)

OLD=`BASE_REVISION`
PATCH_FILES(commit excludes)
RUN(commit -m excludes $EXCLUDE_ARGS)
NEW=`BASE_REVISION`

AT_CHECK(MONOTONE status, [], [stdout], [ignore])
CHECK(stdout, $EXCLUDE_EXCLUDED, $EXCLUDE_INCLUDED)
AT_CHECK(MONOTONE diff -r $OLD -r $NEW, [], [stdout], [ignore])
CHECK(stdout, $EXCLUDE_INCLUDED, $EXCLUDE_EXCLUDED)

OLD=`BASE_REVISION`
PATCH_FILES(commit both)
RUN(commit -m both $BOTH_ARGS)
NEW=`BASE_REVISION`

AT_CHECK(MONOTONE status, [], [stdout], [ignore])
CHECK(stdout, $BOTH_EXCLUDED, $BOTH_INCLUDED)
AT_CHECK(MONOTONE diff -r $OLD -r $NEW, [], [stdout], [ignore])
CHECK(stdout, $BOTH_INCLUDED, $BOTH_EXCLUDED)

OLD=`BASE_REVISION`
PATCH_FILES(commit depth)
RUN(commit -m depth $DEPTH_ARGS)
NEW=`BASE_REVISION`

AT_CHECK(MONOTONE status, [], [stdout], [ignore])
CHECK(stdout, $DEPTH_EXCLUDED, $DEPTH_INCLUDED)
AT_CHECK(MONOTONE diff -r $OLD -r $NEW, [], [stdout], [ignore])
CHECK(stdout, $DEPTH_INCLUDED, $DEPTH_EXCLUDED)

AT_CLEANUP
