annotate.cc:

  annotate_context::build_revisions_to_annotations():

    # Why does this go via the project? It only calls
    # db.get_revision_certs()...
    app.get_project().get_revision_certs(*i, certs);
    app.db..

revision.cc:

 only a CMD(rev_height is left using the app_state

cert.cc:

  guess_branch():
    app.opts.branch_given + app.opts.branchname
    app.get_project().get_revision_branches()


database.cc:

  __app is a member variable of class database, it's needed for the
  following functions:

  migrate_sql_schema()
  test_migration_step()

  database::complete()
    needs: __app->get_project().get_branch_list()
    needs: __app->require_workspace()
    needs: __app->get_project().get_branch_heads()
    needs: __app->opts.branchname


schema_migration.cc:

  migrate_to_external_privkeys():
    needs the key_store

  the migrator func (migrator_cb) also needs the app_state.


netsync.cc:

  struct session:
    app.db...
    app.opts.use_transport_auth
    needs: rev_enumerator()
    app.lua.hook_note_netsync_{pubkey,revision,cert}_received
    app.lua.hook_note_netsync_end

  session::set_session_key():
    app.opts.use_transport_auth
    app.opts.signing_key
    needs: decrypt_rsa()

  session::queue_anonymous_cmd():
    needs: encript_rsa()

  session::queue_auth_cmd():
    needs: encript_rsa()

  session::process_hello_cmd():
    app.db...
    app.opts.use_transport_auth
    app.opts.signing_key
    app.get_project().get_branch_list()
    app.lua.hook_note_netsync_start

  session::process_anonymous_cmd():
    app.db...
    app.opts.use_transport_auth
    app.opts.signing_key
    app.get_project().get_branch_list()
    app.lua.hook_get_netsync_read_permitted
    needs: rebuild_merkle_trees()

  session::process_auth_cmd():
    app.db...
    app.keys...
    app.lua.hook_note_netsync_start()
    app.lua.hook_get_netsync_read_permitted()
    app.lua.hook_get_netsync_write_permitted()
    app.get_project().get_branch_list()
    needs: rebuild_merkle_trees()

  session::begin_service():
    app.opts.use_transport_auth
    app.opts.signing_key
    app.keys.get_key_pair()

  build_stream_to_server():
    app.lua.hook_get_netsync_connect_command()
    app.lua.hook_use_transport_auth
      (saving that to "app.opts.use_transport_auth")

  call_server():
    needs: build_stream_to_server()
    needs: session()

  serve_connections():
    app.opts.bind_port()
    app.opts.bind_address()

  session::rebuild_merkle_trees()
    (huh? takes another app_state, even if the session already has one?)
    app.get_project().get_branch_certs()
    app.db...
    app.opts.keys_to_push()
    app.keys.key_pair_exists()
    app.keys.ensure_in_database()_netsync_protocol():
    app.opts.bind_stdio


keys.cc:
  Only a unit test left, which uses app_state. This should be cleaned
  up as soon as we remove the hackish hooks in the key_store.


cmd_diff_log.cc:

  CMD(diff:
    app.db (read-only?)
    app.opts.external_diff_args_given
    app.opts.diff_format
    app.opts.no_show_encloser
    app.opts.revision_selectors
    app.opts.exclude_patterns
    app.opts.depth
    app.lua.hook_get_encloser_pattern

    needs: app.require_workspace()
    needs: app.work.get_parent_rosters()
    needs: app.work.get_current_roster_shape()
    needs: app.work.update_current_roster_from_filesystem()
    needs: node_restriction()

    needs: complete()

