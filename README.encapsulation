annotate.cc:

  annotate_context::build_revisions_to_annotations():

    # Why does this go via the project? It only calls
    # db.get_revision_certs()...
    app.get_project().get_revision_certs(*i, certs);

    needs: erase_bogus_certs()


revision.cc:

  struct anc_graph still uses app_state, while most methods only need the
  database, these functions are exceptions:

    anc_graph::write_certs():
      needs: make_simple_cert()

    anc_graph::add_node_for_old_manifest
      needs: erase_bogus_cert()

    anc_graph::construct_revisions_from_ancestry()
      app.opts.attrs_to_drop


  build_roster_style_revs_from_manifest_style_revs()
    app.db....
    needs: anc_graph()
    needs: get_user_key()
    needs: require_password()


  build_changesets_from_manifest_ancestry()
    app.db...
    needs: anc_graph()
    needs: get_user_key()
    needs: require_password()
    needs: erase_bogus_certs()


cert.cc:

  bogus_cert_p::is_bogus_cert():
    needs: check_cert()

  erase_bogus_certs():
    app.db...
    app.lua.hook_get_manifest_cert_trust

  load_key_pair():
    app.keys...
    app.loa.hook

  calculate_cert():
    app.db...
    needs: load_key_pair()  (i.e. keys, lua.hook_persist_phrase_ok)
    needs: make_signature()

  check_cert()
    app.db...
    app.lua.hook_persist_phrase_ok
    needs: check_signature()

  get_user_key():
    app.keys...
    app.opts.signing_key
    app.lua.hook_get_branch_key
    app.opts.branchname

  guess_branch():
    app.opts.branch_given + app.opts.branchname
    app.get_project().get_revision_branches()

  make_simple_cert():
    needs: get_user_key()  (i.e. keys + some opts and hooks)
    needs: calculate_cert()

  cert_revision_author_default():
    needs (thought other calls): make_simple_cert()
    app.lua.hook_get_author
    app.opts.branchname
    

database.cc:

  __app is a member variable of class database, it's needed for the
  following functions:

  migrate_sql_schema()
  test_migration_step()

  database::complete()
    needs: __app->get_project().get_branch_list()
    needs: __app->require_workspace()
    needs: __app->get_project().get_branch_heads()
    needs: __app->opts.branchname


schema_migration.cc:

  migrate_to_external_privkeys():
    needs the key_store

  the migrator func (migrator_cb) also needs the app_state.


netsync.cc:

  struct session:
    app.db...
    app.opts.use_transport_auth
    needs: rev_enumerator()
    app.lua.hook_note_netsync_{pubkey,revision,cert}_received
    app.lua.hook_note_netsync_end

  session::set_session_key():
    app.opts.use_transport_auth
    app.opts.signing_key
    needs: load_key_pair()
    needs: decrypt_rsa()

  session::queue_anonymous_cmd():
    needs: encript_rsa()

  session::queue_auth_cmd():
    needs: encript_rsa()

  session::process_hello_cmd():
    app.db...
    app.opts.use_transport_auth
    app.opts.signing_key
    app.get_project().get_branch_list()
    needs: make_signature()
    app.lua.hook_note_netsync_start

  session::process_anonymous_cmd():
    app.db...
    app.opts.use_transport_auth
    app.opts.signing_key
    app.get_project().get_branch_list()
    app.lua.hook_get_netsync_read_permitted
    needs: rebuild_merkle_trees()

  session::process_auth_cmd():
    app.db...
    app.keys.try_ensure_in_db()
    app.lua.hook_note_netsync_start()
    app.lua.hook_get_netsync_read_permitted()
    app.lua.hook_get_netsync_write_permitted()
    app.get_project().get_branch_list()
    needs: rebuild_merkle_trees()
    needs: check_signature()

  session::begin_service():
    app.opts.use_transport_auth
    app.opts.signing_key
    app.keys.get_key_pair()

  build_stream_to_server():
    app.lua.hook_get_netsync_connect_command()
    app.lua.hook_use_transport_auth
      (saving that to "app.opts.use_transport_auth")

  call_server():
    needs: build_stream_to_server()
    needs: session()

  serve_connections():
    app.opts.bind_port()
    app.opts.bind_address()

  session::rebuild_merkle_trees()
    (huh? takes another app_state, even if the session already has one?)
    app.get_project().get_branch_certs()
    app.db...
    app.opts.keys_to_push()
    app.keys.key_pair_exists()
    app.keys.ensure_in_database()

  run_netsync_protocol():
    app.opts.bind_stdio


packet.cc:
  feed_packet_consumer:
    needs: migrate_private_key()


keys.cc:
  migrate_private_key():
    needs: get_passphrase()

  get_passphrase():
    lua.hook_get_passphrase

  make_signature():
    needs: get_passphrase()
    app.opts.ssh_sign
    app.keys...
    app.agent
    app.signers
    app.lua.hook_persist_phrase_ok()
    needs: check_signature()

  check_signature():
    app.verifiers
    app.lua.hook_persist_phrase_ok

  encrypt_rsa():
    (takes 'lua' argument, but doesn't use it??)

  decrypt_rsa():
    needs: get_private_key()

  require_password():
    needs: priv_key_exists()
    app.keys.get_key_dir()
    needs: load_key_pair()
    app.lua.hook_persist_phrase_ok()
    needs: make_signature()
    needs: check_signature()

