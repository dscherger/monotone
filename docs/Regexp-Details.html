<html lang="en">
<head><link type="text/css" rel="stylesheet" href="texinfo.css" />
<title>Regexp Details - monotone documentation</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="monotone documentation">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Regexps.html#Regexps" title="Regexps">
<link rel="prev" href="Regexp-Summary.html#Regexp-Summary" title="Regexp Summary">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Regexp-Details"></a>
voriges:&nbsp;<a rel="previous" accesskey="p" href="Regexp-Summary.html#Regexp-Summary">Regexp Summary</a>,
aufw&auml;rts:&nbsp;<a rel="up" accesskey="u" href="Regexps.html#Regexps">Regexps</a>
<hr>
</div>

<h4 class="subsection">7.5.2 Regexp Details</h4>

<p>The syntax and semantics of PCRE regular expressions, as used in
Monotone, are described in detail below.  Regular expressions in
general are covered in a number of books, some of which have copious
examples. Jeffrey Friedl's &ldquo;Mastering Regular Expressions,&rdquo;
published by O'Reilly, covers regular expressions in great detail. 
This description is intended as reference material.

<h5 class="subsubheading">Characters and Metacharacters</h5>

<p>A regular expression is a pattern that is matched against a subject
string from left to right. Most characters stand for themselves in a
pattern, and match the corresponding characters in the subject. As a
trivial example, the pattern

<pre class="verbatim">
         The quick brown fox
</pre>

<p class="noindent">matches a portion of a subject string that is identical to
itself. When caseless matching is specified, letters are matched
independently of case.

   <p>The power of regular expressions comes from the ability to include
alternatives and repetitions in the pattern. These are encoded in the
pattern by the use of <dfn>metacharacters</dfn>, which do not stand for
themselves but instead are interpreted in some special way.

   <p>There are two different sets of metacharacters: those that are
recognized anywhere in the pattern except within square brackets, and
those that are recognized within square brackets. Outside square
brackets, the metacharacters are as follows:

     <dl>
<dt><code>\</code><dd>general escape character with several uses
<dt><code>^</code><dd>assert start of string (or line, in multiline mode)
<dt><code>$</code><dd>assert end of string (or line, in multiline mode)
<dt><code>.</code><dd>match any character except newline (by default)
<dt><code>[</code><dd>start character class definition
<dt><code>|</code><dd>start of alternative branch
<dt><code>(</code><dd>start subpattern
<dt><code>)</code><dd>end subpattern
<dt><code>?</code><dd>extends the meaning of `<samp><span class="samp">(</span></samp>'
         also 0 or 1 quantifier
         also quantifier minimizer
<dt><code>*</code><dd>0 or more quantifier
<dt><code>+</code><dd>1 or more quantifier
         also &ldquo;possessive quantifier&rdquo;
<dt><code>{</code><dd>start min/max quantifier
</dl>

<p class="noindent">Part of a pattern that is in square brackets is called a "character
class". In a character class the only metacharacters are:

     <dl>
<dt><code>\</code><dd>general escape character
<dt><code>^</code><dd>negate the class, but only if the first character
<dt><code>-</code><dd>indicates character range
<dt><code>[</code><dd>POSIX character class (only if followed by POSIX
           syntax)
<dt><code>]</code><dd>terminates the character class
</dl>

<p class="noindent">The following sections describe the use of each of the metacharacters.

<h5 class="subsubheading">Backslash</h5>

<p>The backslash character has several uses. Firstly, if it is followed
by a non-alphanumeric character, it takes away any special meaning
that character may have. This use of backslash as an escape character
applies both inside and outside character classes.

   <p>For example, if you want to match a `<samp><span class="samp">*</span></samp>' character, you write
`<samp><span class="samp">\*</span></samp>' in the pattern.  This escaping action applies whether or not
the following character would otherwise be interpreted as a
metacharacter, so it is always safe to precede a non-alphanumeric with
backslash to specify that it stands for itself. In particular, if you
want to match a backslash, you write `<samp><span class="samp">\\</span></samp>'.

   <p>If a pattern is compiled with the `<samp><span class="samp">(?x)</span></samp>' option, whitespace in
the pattern (other than in a character class) and characters between a
`<samp><span class="samp">#</span></samp>' outside a character class and the next newline are
ignored. An escaping backslash can be used to include a whitespace or
`<samp><span class="samp">#</span></samp>' character as part of the pattern.

   <p>If you want to remove the special meaning from a sequence of
characters, you can do so by putting them between `<samp><span class="samp">\Q</span></samp>' and
`<samp><span class="samp">\E</span></samp>'.  The `<samp><span class="samp">\Q...\E</span></samp>' sequence is recognized both inside and
outside character classes.

<h5 class="subsubheading">Non-printing Characters</h5>

<p>A second use of backslash provides a way of encoding non-printing characters
in patterns in a visible manner. There is no restriction on the appearance of
non-printing characters, apart from the binary zero that terminates a pattern,
but when a pattern is being prepared by text editing, it is usually easier to
use one of the following escape sequences than the binary character it
represents:

     <dl>
<dt><code>\a</code><dd>alarm, that is, the BEL character (hex 07)
<dt><code>\c</code><var>x</var><dd>"control-<var>x</var>", where <var>x</var> is any character
<dt><code>\e</code><dd>escape (hex 1B)
<dt><code>\f</code><dd>formfeed (hex 0C)
<dt><code>\n</code><dd>linefeed (hex 0A)
<dt><code>\r</code><dd>carriage return (hex 0D)
<dt><code>\t</code><dd>tab (hex 09)
<dt><code>\</code><var>ddd</var><dd>character with octal code <var>ddd</var>, or backreference
<dt><code>\x</code><var>hh</var><dd>character with hex code <var>hh</var>
<dt><code>\x{</code><var>hhh...</var><code>}</code><dd>character with hex code <var>hhh...</var>
</dl>

   <p>The precise effect of `<samp><span class="samp">\c</span><var>x</var></samp>' is as follows: if <var>x</var> is a lower
case letter, it is converted to upper case. Then bit 6 of the
character (hex 40) is inverted.  Thus `<samp><span class="samp">\cz</span></samp>' becomes hex 1A (the
&lt;SUB&gt; control character, in ASCII), but `<samp><span class="samp">\c{</span></samp>' becomes hex 3B
(`<samp><span class="samp">;</span></samp>'), and `<samp><span class="samp">\c;</span></samp>' becomes hex 7B (`<samp><span class="samp">{</span></samp>').

<!-- the math in the next paragraph is not done with @math because -->
<!-- ``2**31'' is a much nicer thing to have in the Info file than ``2^{31}''. -->
<p>After `<samp><span class="samp">\x</span></samp>', from zero to two hexadecimal digits are read (letters
can be in upper or lower case). Any number of hexadecimal digits may
appear between `<samp><span class="samp">\x{</span></samp>' and `<samp><span class="samp">}</span></samp>', but the value of the
character code must be less than 256 in non-UTF-8 mode, and less than
2<sup>31</sup>in UTF-8 mode. That is, the maximum value in hexadecimal is
7FFFFFFF. Note that this is bigger than the largest Unicode code
point, which is 10FFFF.

   <p>If characters other than hexadecimal digits appear between `<samp><span class="samp">\x{</span></samp>'
and `<samp><span class="samp">}</span></samp>', or if there is no terminating `<samp><span class="samp">}</span></samp>', this form of
escape is not recognized. Instead, the initial `<samp><span class="samp">\x</span></samp>' will be
interpreted as a basic hexadecimal escape, with no following digits,
giving a character whose value is zero.

   <p>Characters whose value is less than 256 can be defined by either of
the two syntaxes for `<samp><span class="samp">\x</span></samp>'. There is no difference in the way they
are handled. For example, `<samp><span class="samp">\xdc</span></samp>' is exactly the same as
`<samp><span class="samp">\x{dc}</span></samp>'.

   <p>After `<samp><span class="samp">\0</span></samp>' up to two further octal digits are read. If there are
fewer than two digits, just those that are present are used. Thus the
sequence `<samp><span class="samp">\0\x\07</span></samp>' specifies two binary zeros followed by a
&lt;BEL&gt; character (octal 007). Make sure you supply two digits after
the initial zero if the pattern character that follows is itself an
octal digit.

   <p>The handling of a backslash followed by a digit other than 0 is
complicated.  Outside a character class, PCRE reads it and any
following digits as a decimal number. If the number is less than 10,
or if there have been at least that many previous capturing left
parentheses in the expression, the entire sequence is taken as a
<dfn>back reference</dfn>. A description of how this works is given later,
following the discussion of parenthesized subpatterns.

   <p>Inside a character class, or if the decimal number is greater than 9
and there have not been that many capturing subpatterns, PCRE re-reads
up to three octal digits following the backslash, and uses them to
generate a data character. Any subsequent digits stand for
themselves. In non-UTF-8 mode, the value of a character specified in
octal must be less than `<samp><span class="samp">\400</span></samp>'. In UTF-8 mode, values up to
`<samp><span class="samp">\777</span></samp>' are permitted. For example:

     <dl>
<dt><code>\040</code><dd>is another way of writing a space
<dt><code>\40</code><dd>is the same, provided there are fewer than 40
            previous capturing subpatterns
<dt><code>\7</code><dd>is always a back reference
<dt><code>\11</code><dd>might be a back reference, or another way of
            writing a tab
<dt><code>\011</code><dd>is always a tab
<dt><code>\0113</code><dd>is a tab followed by the character `<samp><span class="samp">3</span></samp>'
<dt><code>\113</code><dd>might be a back reference, otherwise the
            character with octal code 113
<dt><code>\377</code><dd>might be a back reference, otherwise
            the byte consisting entirely of 1 bits
<dt><code>\81</code><dd>is either a back reference, or a binary zero
            followed by the two characters `<samp><span class="samp">8</span></samp>' and `<samp><span class="samp">1</span></samp>'
</dl>

   <p>Note that octal values of 100 or greater must not be introduced by a
leading zero, because no more than three octal digits are ever read.

   <p>All the sequences that define a single character value can be used
both inside and outside character classes. In addition, inside a
character class, the sequence `<samp><span class="samp">\b</span></samp>' is interpreted as the &lt;BS&gt;
character (hex 08), and the sequences `<samp><span class="samp">\R</span></samp>' and `<samp><span class="samp">\X</span></samp>' are
interpreted as the characters `<samp><span class="samp">R</span></samp>' and `<samp><span class="samp">X</span></samp>',
respectively. Outside a character class, these sequences have
different meanings (see below).

<h5 class="subsubheading">Absolute and Relative Back References</h5>

<p>The sequence `<samp><span class="samp">\g</span></samp>' followed by an unsigned or a negative number,
optionally enclosed in braces, is an absolute or relative back
reference. A named back reference can be coded as
`<samp><span class="samp">\g{name}</span></samp>'. Back references are discussed later, following the
discussion of parenthesized subpatterns.

<h5 class="subsubheading">Generic character types</h5>

<p>Another use of backslash is for specifying generic character types. The
following are always recognized:

     <dl>
<dt><code>\d</code><dd>any decimal digit
<dt><code>\D</code><dd>any character that is not a decimal digit
<dt><code>\h</code><dd>any horizontal whitespace character
<dt><code>\H</code><dd>any character that is not a horizontal whitespace character
<dt><code>\s</code><dd>any whitespace character
<dt><code>\S</code><dd>any character that is not a whitespace character
<dt><code>\v</code><dd>any vertical whitespace character
<dt><code>\V</code><dd>any character that is not a vertical whitespace character
<dt><code>\w</code><dd>any &ldquo;word&rdquo; character
<dt><code>\W</code><dd>any &ldquo;non-word&rdquo; character
</dl>

   <p>Each pair of escape sequences partitions the complete set of
characters into two disjoint sets. Any given character matches one,
and only one, of each pair.

   <p>These character type sequences can appear both inside and outside
character classes. They each match one character of the appropriate
type. If the current matching point is at the end of the subject
string, all of them fail, since there is no character to match.

   <p>For compatibility with Perl, `<samp><span class="samp">\s</span></samp>' does not match the &lt;VT&gt;
character (code 11).  This makes it different from the the POSIX
&ldquo;space&rdquo; class. The `<samp><span class="samp">\s</span></samp>' characters are &lt;TAB&gt; (9), &lt;LF&gt;
(10), &lt;FF&gt; (12), &lt;CR&gt; (13), and &lt;SPACE&gt; (32).

   <p>In UTF-8 mode, characters with values greater than 128 never match
`<samp><span class="samp">\d</span></samp>', `<samp><span class="samp">\s</span></samp>', or `<samp><span class="samp">\w</span></samp>', and always match `<samp><span class="samp">\D</span></samp>',
`<samp><span class="samp">\S</span></samp>', and `<samp><span class="samp">\W</span></samp>'.  These sequences retain their original
meanings from before UTF-8 support was available, mainly for
efficiency reasons.

   <p>The sequences `<samp><span class="samp">\h</span></samp>', `<samp><span class="samp">\H</span></samp>', `<samp><span class="samp">\v</span></samp>', and `<samp><span class="samp">\V</span></samp>' are Perl
5.10 features. In contrast to the other sequences, these do match
certain high-valued codepoints in UTF-8 mode.  The horizontal space
characters are:

     <dl>
<dt><code>U+0009</code><dd>Horizontal tab
<dt><code>U+0020</code><dd>Space
<dt><code>U+00A0</code><dd>Non-break space
<dt><code>U+1680</code><dd>Ogham space mark
<dt><code>U+180E</code><dd>Mongolian vowel separator
<br><dt><code>U+2000</code><dd>En quad
<dt><code>U+2001</code><dd>Em quad
<dt><code>U+2002</code><dd>En space
<dt><code>U+2003</code><dd>Em space
<dt><code>U+2004</code><dd>Three-per-em space
<dt><code>U+2005</code><dd>Four-per-em space
<dt><code>U+2006</code><dd>Six-per-em space
<br><dt><code>U+2007</code><dd>Figure space
<dt><code>U+2008</code><dd>Punctuation space
<dt><code>U+2009</code><dd>Thin space
<dt><code>U+200A</code><dd>Hair space
<dt><code>U+202F</code><dd>Narrow no-break space
<dt><code>U+205F</code><dd>Medium mathematical space
<dt><code>U+3000</code><dd>Ideographic space
</dl>

<p class="noindent">The vertical space characters are:

     <dl>
<dt><code>U+000A</code><dd>Linefeed
<dt><code>U+000B</code><dd>Vertical tab
<dt><code>U+000C</code><dd>Formfeed
<dt><code>U+000D</code><dd>Carriage return
<dt><code>U+0085</code><dd>Next line
<dt><code>U+2028</code><dd>Line separator
<dt><code>U+2029</code><dd>Paragraph separator
</dl>

<p class="noindent">A &ldquo;word&rdquo; character is an underscore or any character less than 256
that is a letter or digit. The definition of letters and digits is
that used for the &ldquo;C&rdquo; locale.

<h5 class="subsubheading">Newline Conventions</h5>

<p>PCRE supports five different conventions for indicating line breaks in
strings: a single CR (carriage return) character, a single LF
(linefeed) character, the two-character sequence CRLF, any of the
three preceding, or any Unicode newline sequence.  The default is to
match any Unicode newline sequence.  It is possible to override the
default newline convention by starting a pattern string with one of
the following five sequences:

     <dl>
<dt><code>(*CR)</code><dd>  carriage return
<dt><code>(*LF)</code><dd>  linefeed
<dt><code>(*CRLF)</code><dd>  carriage return, followed by linefeed
<dt><code>(*ANYCRLF)</code><dd>  any of the three above
<dt><code>(*ANY)</code><dd>  all Unicode newline sequences
</dl>

   <p>For example, the pattern

<pre class="verbatim">
         (*CR)a.b
</pre>

<p class="noindent">changes the convention to CR. That pattern matches `<samp><span class="samp">a\nb</span></samp>' because
LF is no longer a newline. Note that these special settings, which are
not Perl-compatible, are recognized only at the very start of a
pattern, and that they must be in upper case. If more than one of them
is present, the last one is used.

   <p>The newline convention does not affect what the `<samp><span class="samp">\R</span></samp>' escape
sequence matches. By default, this is any Unicode newline sequence,
for Perl compatibility. However, this can be changed; see the
description of `<samp><span class="samp">\R</span></samp>' below.  A change of `<samp><span class="samp">\R</span></samp>' setting can be
combined with a change of newline convention.

<h5 class="subsubheading">Newline Sequences</h5>

<p>Outside a character class, by default, the escape sequence `<samp><span class="samp">\R</span></samp>' matches
any Unicode newline sequence. This is a Perl 5.10 feature. In
non-UTF-8 mode `<samp><span class="samp">\R</span></samp>' is equivalent to the following:

<pre class="verbatim">
         (?>\r\n|\n|\x0b|\f|\r|\x85)
</pre>

   <p>This is an example of an "atomic group", details of which are given
below.  This particular group matches either the two-character
sequence &lt;CR&gt; followed by &lt;LF&gt;, or one of the single
characters &lt;LF&gt; (linefeed, <code>U+000A</code>), &lt;VT&gt; (vertical tab,
<code>U+000B</code>), &lt;FF&gt; (formfeed, <code>U+000C</code>), &lt;CR&gt; (carriage
return, <code>U+000D</code>), or &lt;NEL&gt; (next line, <code>U+0085</code>). The
two-character sequence is treated as a single unit that cannot be
split.  In UTF-8 mode, two additional characters whose codepoints are
greater than 255 are added: &lt;LS&gt; (line separator, <code>U+2028</code>)
and &lt;PS&gt; (paragraph separator, <code>U+2029</code>).

   <p>It is possible to change the meaning of `<samp><span class="samp">\R</span></samp>' by starting a
pattern string with one of the following sequences:

     <dl>
<dt><code>(*BSR_ANYCRLF)</code><dd>&lt;CR&gt;, &lt;LF&gt;, or &lt;CR&gt;&lt;LF&gt; only
<dt><code>(*BSR_UNICODE)</code><dd>any Unicode newline sequence (the default)
</dl>

   <p>Note that these special settings, which are not Perl-compatible, are
recognized only at the very start of a pattern, and that they must be
in upper case. If more than one of them is present, the last one is
used. They can be combined with a change of newline convention, for
example, a pattern can start with:

<pre class="verbatim">
         (*ANY)(*BSR_ANYCRLF)
</pre>

<p class="noindent">Inside a character class, `<samp><span class="samp">\R</span></samp>' matches the letter `<samp><span class="samp">R</span></samp>'.

<h5 class="subsubheading">Unicode Character Properties</h5>

<p>Three additional escape sequences match characters with specific
Unicode properties.  When not in UTF-8 mode, these sequences are of
course limited to testing characters whose codepoints are less than
256, but they do work in this mode.  The extra escape sequences are:

     <dl>
<dt><code>\p{</code><var>xx</var><code>}</code><dd>a character with the <var>xx</var> property
<dt><code>\P{</code><var>xx</var><code>}</code><dd>a character without the <var>xx</var> property
<dt><code>\X</code><dd>an extended Unicode sequence
</dl>

   <p>The property names represented by <var>xx</var> above are limited to the
Unicode script names, the general category properties, and `<samp><span class="samp">Any</span></samp>',
which matches any character (including newline). Other properties such
as `<samp><span class="samp">InMusicalSymbols</span></samp>' are not currently supported by PCRE. Note
that `<samp><span class="samp">\P{Any}</span></samp>' does not match any characters, so always causes
a match failure.

   <p>Sets of Unicode characters are defined as belonging to certain
scripts. A character from one of these sets can be matched using a
script name. For example:

<pre class="verbatim">
         \p{Greek}
         \P{Han}
</pre>

<p class="noindent">Those that are not part of an identified script are lumped together as
&ldquo;Common.&rdquo; The current list of scripts is:

   <p>Arabic,
Armenian,
Balinese,
Bengali,
Bopomofo,
Braille,
Buginese,
Buhid,
Canadian_Aboriginal,
Cherokee,
Common,
Coptic,
Cuneiform,
Cypriot,
Cyrillic,
Deseret,
Devanagari,
Ethiopic,
Georgian,
Glagolitic,
Gothic,
Greek,
Gujarati,
Gurmukhi,
Han,
Hangul,
Hanunoo,
Hebrew,
Hiragana,
Inherited,
Kannada,
Katakana,
Kharoshthi,
Khmer,
Lao,
Latin,
Limbu,
Linear_B,
Malayalam,
Mongolian,
Myanmar,
New_Tai_Lue,
Nko,
Ogham,
Old_Italic,
Old_Persian,
Oriya,
Osmanya,
Phags_Pa,
Phoenician,
Runic,
Shavian,
Sinhala,
Syloti_Nagri,
Syriac,
Tagalog,
Tagbanwa,
Tai_Le,
Tamil,
Telugu,
Thaana,
Thai,
Tibetan,
Tifinagh,
Ugaritic,
Yi.

   <p>Each character has exactly one general category property, specified by a
two-letter abbreviation. For compatibility with Perl, negation can be specified
by including a circumflex between the opening brace and the property name. For
example, `<samp><span class="samp">\p{^Lu}</span></samp>' is the same as `<samp><span class="samp">\P{Lu}</span></samp>'.

   <p>If only one letter is specified with `<samp><span class="samp">\p</span></samp>' or `<samp><span class="samp">\P</span></samp>', it
includes all the general category properties that start with that
letter. In this case, in the absence of negation, the curly brackets
in the escape sequence are optional; these two examples have the same
effect:

<pre class="verbatim">
         \p{L}
         \pL
</pre>

<p class="noindent">The following general category property codes are supported:

     <dl>
<dt><code>C</code><dd>Other
<dt><code>Cc</code><dd>Control
<dt><code>Cf</code><dd>Format
<dt><code>Cn</code><dd>Unassigned
<dt><code>Co</code><dd>Private use
<dt><code>Cs</code><dd>Surrogate

     <br><dt><code>L</code><dd>Letter
<dt><code>Ll</code><dd>Lower case letter
<dt><code>Lm</code><dd>Modifier letter
<dt><code>Lo</code><dd>Other letter
<dt><code>Lt</code><dd>Title case letter
<dt><code>Lu</code><dd>Upper case letter

     <br><dt><code>M</code><dd>Mark
<dt><code>Mc</code><dd>Spacing mark
<dt><code>Me</code><dd>Enclosing mark
<dt><code>Mn</code><dd>Non-spacing mark

     <br><dt><code>N</code><dd>Number
<dt><code>Nd</code><dd>Decimal number
<dt><code>Nl</code><dd>Letter number
<dt><code>No</code><dd>Other number

     <br><dt><code>P</code><dd>Punctuation
<dt><code>Pc</code><dd>Connector punctuation
<dt><code>Pd</code><dd>Dash punctuation
<dt><code>Pe</code><dd>Close punctuation
<dt><code>Pf</code><dd>Final punctuation
<dt><code>Pi</code><dd>Initial punctuation
<dt><code>Po</code><dd>Other punctuation
<dt><code>Ps</code><dd>Open punctuation

     <br><dt><code>S</code><dd>Symbol
<dt><code>Sc</code><dd>Currency symbol
<dt><code>Sk</code><dd>Modifier symbol
<dt><code>Sm</code><dd>Mathematical symbol
<dt><code>So</code><dd>Other symbol

     <br><dt><code>Z</code><dd>Separator
<dt><code>Zl</code><dd>Line separator
<dt><code>Zp</code><dd>Paragraph separator
<dt><code>Zs</code><dd>Space separator
</dl>

   <p>The special property `<samp><span class="samp">L&amp;</span></samp>' is also supported: it matches a
character that has the `<samp><span class="samp">Lu</span></samp>', `<samp><span class="samp">Ll</span></samp>', or `<samp><span class="samp">Lt</span></samp>' property, in
other words, a letter that is not classified as a modifier or
&ldquo;other.&rdquo;

   <p>The `<samp><span class="samp">Cs</span></samp>' (Surrogate) property applies only to characters in the
range <code>U+D800</code> to <code>U+DFFF</code>. Such characters are not valid in
UTF-8 strings (see RFC 3629) and so cannot be tested by PCRE.

   <p>The long synonyms for these properties that Perl supports (such as
`<samp><span class="samp">\p{Letter}</span></samp>') are not supported by PCRE, nor is it permitted to
prefix any of these properties with `<samp><span class="samp">Is</span></samp>'.

   <p>No character that is in the Unicode table has the `<samp><span class="samp">Cn</span></samp>'
(unassigned) property.  Instead, this property is assumed for any code
point that is not in the Unicode table.

   <p>Specifying caseless matching does not affect these escape sequences. For
example, `<samp><span class="samp">\p{Lu}</span></samp>' always matches only upper case letters.

   <p>The `<samp><span class="samp">\X</span></samp>' escape matches any number of Unicode characters that
form an extended Unicode sequence. `<samp><span class="samp">\X</span></samp>' is equivalent to

<pre class="verbatim">
         (?>\PM\pM*)
</pre>

   <p>That is, it matches a character without the &ldquo;mark&rdquo; property,
followed by zero or more characters with the &ldquo;mark&rdquo; property, and
treats the sequence as an atomic group (see below).  Characters with
the &ldquo;mark&rdquo; property are typically accents that affect the preceding
character. None of them have codepoints less than 256, so in non-UTF-8
mode `<samp><span class="samp">\X</span></samp>' matches any one character.

   <p>Matching characters by Unicode property is not fast, because PCRE has
to search a structure that contains data for over fifteen thousand
characters. That is why the traditional escape sequences such as
`<samp><span class="samp">\d</span></samp>' and `<samp><span class="samp">\w</span></samp>' do not use Unicode properties in PCRE.

<h5 class="subsubheading">Resetting the Match Start</h5>

<p>The escape sequence `<samp><span class="samp">\K</span></samp>', which is a Perl 5.10 feature, causes
any previously matched characters not to be included in the final
matched sequence. For example, the pattern:

<pre class="verbatim">
         foo\Kbar
</pre>

<p class="noindent">matches `<samp><span class="samp">foobar</span></samp>', but reports that it has matched
`<samp><span class="samp">bar</span></samp>'. This feature is similar to a lookbehind assertion
(described below).  However, in this case, the part of the subject
before the real match does not have to be of fixed length, as
lookbehind assertions do. The use of `<samp><span class="samp">\K</span></samp>' does not interfere with the
setting of captured substrings.  For example, when the pattern

<pre class="verbatim">
         (foo)\Kbar
</pre>

<p class="noindent">matches `<samp><span class="samp">foobar</span></samp>', the first substring is still set to `<samp><span class="samp">foo</span></samp>'.

<h5 class="subsubheading">Simple assertions</h5>

<p>The final use of backslash is for certain simple assertions. An
assertion specifies a condition that has to be met at a particular
point in a match, without consuming any characters from the subject
string. The use of subpatterns for more complicated assertions is
described below.  The backslashed assertions are:

     <dl>
<dt><code>\b</code><dd>matches at a word boundary
<dt><code>\B</code><dd>matches when not at a word boundary
<dt><code>\A</code><dd>matches at the start of the subject
<dt><code>\Z</code><dd>matches at the end of the subject
          also matches before a newline at the end of the subject
<dt><code>\z</code><dd>matches only at the end of the subject
<dt><code>\G</code><dd>matches at the first matching position in the subject
</dl>

<p class="noindent">These assertions may not appear in character classes (but note that
`<samp><span class="samp">\b</span></samp>' has a different meaning, namely the backspace character,
inside a character class).

   <p>A word boundary is a position in the subject string where the current
character and the previous character do not both match `<samp><span class="samp">\w</span></samp>' or
`<samp><span class="samp">\W</span></samp>' (i.e. one matches `<samp><span class="samp">\w</span></samp>' and the other matches
`<samp><span class="samp">\W</span></samp>'), or the start or end of the string if the first or last
character matches `<samp><span class="samp">\w</span></samp>', respectively.

   <p>The `<samp><span class="samp">\A</span></samp>', `<samp><span class="samp">\Z</span></samp>', and `<samp><span class="samp">\z</span></samp>' assertions differ from the
traditional circumflex and dollar (described in the next section) in
that they only ever match at the very start and end of the subject
string, whatever options are set. Thus, they are independent of
multiline mode. The difference between `<samp><span class="samp">\Z</span></samp>' and `<samp><span class="samp">\z</span></samp>' is that
`<samp><span class="samp">\Z</span></samp>' matches before a newline at the end of the string as well as
at the very end, whereas `<samp><span class="samp">\z</span></samp>' matches only at the end.

   <p>The `<samp><span class="samp">\G</span></samp>' assertion is true only when the current matching
position is at the start point of the match.  As used in Monotone,
`<samp><span class="samp">\G</span></samp>' is always equal to `<samp><span class="samp">\A</span></samp>'.

<h5 class="subsubheading">Circumflex and Dollar</h5>

<p>Outside a character class, in the default matching mode, the
circumflex character, `<samp><span class="samp">^</span></samp>', is an assertion that is true only if
the current matching point is at the start of the subject string. 
Inside a character class, circumflex has an entirely different meaning
(see below).

   <p>Circumflex need not be the first character of the pattern if a number
of alternatives are involved, but it should be the first thing in each
alternative in which it appears if the pattern is ever to match that
branch. If all possible alternatives start with a circumflex, that is,
if the pattern is constrained to match only at the start of the
subject, it is said to be an &ldquo;anchored&rdquo; pattern. (There are also
other constructs that can cause a pattern to be anchored.)

   <p>A dollar character, `<samp><span class="samp">$</span></samp>', is an assertion that is true only if the
current matching point is at the end of the subject string, or
immediately before a newline at the end of the string (by
default). Dollar need not be the last character of the pattern if a
number of alternatives are involved, but it should be the last item in
any branch in which it appears. Dollar has no special meaning in a
character class.

   <p>The meanings of the circumflex and dollar characters are changed if
the `<samp><span class="samp">(?m)</span></samp>' option is set. When this is the case, a circumflex
matches immediately after internal newlines as well as at the start of
the subject string. It does not match after a newline that ends the
string. A dollar matches before any newlines in the string, as well as
at the very end, when `<samp><span class="samp">(?m)</span></samp>' is set. When newline is specified as
the two-character sequence &lt;CR&gt;&lt;LF&gt;, isolated &lt;CR&gt; and
&lt;LF&gt; characters do not indicate newlines.

   <p>For example, the pattern `<samp><span class="samp">^abc$</span></samp>' matches the subject string
`<samp><span class="samp">def\nabc</span></samp>' (where `<samp><span class="samp">\n</span></samp>' represents a newline) in multiline
mode, but not otherwise. Consequently, patterns that are anchored in
single line mode because all branches start with ^ are not anchored in
multiline mode.

   <p>Note that the sequences `<samp><span class="samp">\A</span></samp>', `<samp><span class="samp">\Z</span></samp>', and `<samp><span class="samp">\z</span></samp>' can be
used to match the start and end of the subject in both modes, and if
all branches of a pattern start with `<samp><span class="samp">\A</span></samp>' it is always anchored.

<h5 class="subsubheading">Full Stop (Period, Dot)</h5>

<p>Outside a character class, a dot in the pattern matches any one
character in the subject string except (by default) a character that
signifies the end of a line. In UTF-8 mode, the matched character may
be more than one byte long.

   <p>When a line ending is defined as a single character, dot never matches
that character; when the two-character sequence &lt;CR&gt;&lt;LF&gt; is
used, dot does not match &lt;CR&gt; if it is immediately followed by
&lt;LF&gt;, but otherwise it matches all characters (including isolated
&lt;CR&gt;s and &lt;LF&gt;s). When any Unicode line endings are being
recognized, dot does not match &lt;CR&gt; or &lt;LF&gt; or any of the
other line ending characters.

   <p>The behaviour of dot with regard to newlines can be changed. If the
`<samp><span class="samp">(?s)</span></samp>' option is set, a dot matches any one character, without
exception. If the two-character sequence &lt;CR&gt;&lt;LF&gt; is present
in the subject string, it takes two dots to match it.

   <p>The handling of dot is entirely independent of the handling of circumflex and
dollar, the only relationship being that they both involve newlines. Dot has no
special meaning in a character class.

<h5 class="subsubheading">Matching a Single Byte</h5>

<p>Outside a character class, the escape sequence `<samp><span class="samp">\C</span></samp>' matches any
one byte, both in and out of UTF-8 mode. Unlike a dot, it always
matches any line-ending characters. The feature is provided in Perl in
order to match individual bytes in UTF-8 mode. Because it breaks up
UTF-8 characters into individual bytes, what remains in the string may
be a malformed UTF-8 string. For this reason, the `<samp><span class="samp">\C</span></samp>' escape
sequence is best avoided.

   <p>PCRE does not allow `<samp><span class="samp">\C</span></samp>' to appear in lookbehind assertions
(described below), because in UTF-8 mode this would make it impossible
to calculate the length of the lookbehind.

<h5 class="subsubheading">Square Brackets and Character Classes</h5>

<p>An opening square bracket introduces a character class, terminated by
a closing square bracket. A closing square bracket on its own is not
special. If a closing square bracket is required as a member of the
class, it should be the first data character in the class (after an
initial circumflex, if present) or escaped with a backslash.

   <p>A character class matches a single character in the subject. In UTF-8
mode, the character may occupy more than one byte. A matched character
must be in the set of characters defined by the class, unless the
first character in the class definition is a circumflex, in which case
the subject character must not be in the set defined by the class. If
a circumflex is actually required as a member of the class, ensure it
is not the first character, or escape it with a backslash.

   <p>For example, the character class `<samp><span class="samp">[aeiou]</span></samp>' matches any lower case
vowel, while `<samp><span class="samp">[^aeiou]</span></samp>' matches any character that is not a lower
case vowel. Note that a circumflex is just a convenient notation for
specifying the characters that are in the class by enumerating those
that are not. A class that starts with a circumflex is not an
assertion: it still consumes a character from the subject string, and
therefore it fails if the current pointer is at the end of the string.

   <p>In UTF-8 mode, characters with values greater than 255 can be included
in a class as a literal string of bytes, or by using the `<samp><span class="samp">\x{</span></samp>'
escaping mechanism.

   <p>When caseless matching is set, any letters in a class represent both
their upper case and lower case versions, so for example, a caseless
`<samp><span class="samp">[aeiou]</span></samp>' matches `<samp><span class="samp">A</span></samp>' as well as `<samp><span class="samp">a</span></samp>', and a caseless [^aeiou]
does not match `<samp><span class="samp">A</span></samp>', whereas a caseful version would. In UTF-8 mode,
PCRE always understands the concept of case for characters whose
values are less than 128, so caseless matching is always possible. For
characters with higher values, the concept of case is supported if
PCRE is compiled with Unicode property support, but not otherwise.  If
you want to use caseless matching for characters 128 and above, you
must ensure that PCRE is compiled with Unicode property support as
well as with UTF-8 support.

   <p>Characters that might indicate line breaks are never treated in any
special way when matching character classes, whatever line-ending
sequence is in use, and whatever setting of the `<samp><span class="samp">(?s)</span></samp>' and
`<samp><span class="samp">(?m)</span></samp>' options is used. A class such as `<samp><span class="samp">[^a]</span></samp>' always
matches one of these characters.

   <p>The minus (hyphen) character can be used to specify a range of
characters in a character class. For example, `<samp><span class="samp">[d-m]</span></samp>' matches any
letter between `<samp><span class="samp">d</span></samp>' and `<samp><span class="samp">m</span></samp>', inclusive. If a minus character
is required in a class, it must be escaped with a backslash or appear
in a position where it cannot be interpreted as indicating a range,
typically as the first or last character in the class.

   <p>It is not possible to have the literal character `<samp><span class="samp">]</span></samp>' as the end
character of a range. A pattern such as `<samp><span class="samp">[W-]46]</span></samp>' is interpreted
as a class of two characters (`<samp><span class="samp">W</span></samp>' and `<samp><span class="samp">-</span></samp>') followed by a
literal string `<samp><span class="samp">46]</span></samp>', so it would match `<samp><span class="samp">W46]</span></samp>' or
`<samp><span class="samp">-46]</span></samp>'. However, if the `<samp><span class="samp">]</span></samp>' is escaped with a backslash it
is interpreted as the end of range, so `<samp><span class="samp">[W-\]46]</span></samp>' is interpreted
as a class containing a range followed by two other characters. The
octal or hexadecimal representation of `<samp><span class="samp">]</span></samp>' can also be used to
end a range.

   <p>Ranges operate in the collating sequence of character values. They can
also be used for characters specified numerically, for example
`<samp><span class="samp">[\000-\037]</span></samp>'. In UTF-8 mode, ranges can include characters whose
values are greater than 255, for example `<samp><span class="samp">[\x{100}-\x{2ff}]</span></samp>'.

   <p>If a range that includes letters is used when caseless matching is
set, it matches the letters in either case. For example, `<samp><span class="samp">[W-c]</span></samp>'
is equivalent to `<samp><span class="samp">[][\\^_`wxyzabc]</span></samp>', matched caselessly.

   <p>The character types `<samp><span class="samp">\d</span></samp>', `<samp><span class="samp">\D</span></samp>', `<samp><span class="samp">\p</span></samp>', `<samp><span class="samp">\P</span></samp>',
`<samp><span class="samp">\s</span></samp>', `<samp><span class="samp">\S</span></samp>', `<samp><span class="samp">\w</span></samp>', and `<samp><span class="samp">\W</span></samp>' may also appear in a
character class, and add the characters that they match to the
class. For example, `<samp><span class="samp">[\dABCDEF]</span></samp>' matches any hexadecimal digit. A
circumflex can conveniently be used with the upper case character
types to specify a more restricted set of characters than the matching
lower case type. For example, the class `<samp><span class="samp">[^\W_]</span></samp>' matches any
letter or digit, but not underscore.

   <p>The only metacharacters that are recognized in character classes are
backslash, hyphen (only where it can be interpreted as specifying a
range), circumflex (only at the start), opening square bracket (only
when it can be interpreted as introducing a POSIX class name&mdash;see the
next section), and the terminating closing square bracket. However,
escaping other non-alphanumeric characters does no harm.

<h5 class="subsubheading">POSIX Character Classes</h5>

<p>Perl supports the POSIX notation for character classes. This uses
names enclosed by `<samp><span class="samp">[:</span></samp>' and `<samp><span class="samp">:]</span></samp>' within the enclosing square
brackets. PCRE also supports this notation. For example,

<pre class="verbatim">
         [01[:alpha:]%]
</pre>

<p class="noindent">matches `<samp><span class="samp">0</span></samp>', `<samp><span class="samp">1</span></samp>', any alphabetic character, or `<samp><span class="samp">%</span></samp>'. The
supported class names are

     <dl>
<dt><code>alnum</code><dd>letters and digits
<dt><code>alpha</code><dd>letters
<dt><code>ascii</code><dd>character codes 0 &ndash; 127
<dt><code>blank</code><dd>space or tab only
<dt><code>cntrl</code><dd>control characters
<dt><code>digit</code><dd>decimal digits (same as `<samp><span class="samp">\d</span></samp>')
<dt><code>graph</code><dd>printing characters, excluding space
<dt><code>lower</code><dd>lower case letters
<dt><code>print</code><dd>printing characters, including space
<dt><code>punct</code><dd>printing characters, excluding letters and digits
<dt><code>space</code><dd>white space (not quite the same as `<samp><span class="samp">\s</span></samp>')
<dt><code>upper</code><dd>upper case letters
<dt><code>word</code><dd>&ldquo;word&rdquo; characters (same as `<samp><span class="samp">\w</span></samp>')
<dt><code>xdigit</code><dd>hexadecimal digits
</dl>

   <p>The &ldquo;space&rdquo; characters are &lt;HT&gt; (9), &lt;LF&gt; (10), &lt;VT&gt;
(11), &lt;FF&gt; (12), &lt;CR&gt; (13), and space (32). Notice that this
list includes the &lt;VT&gt; character (code 11). This makes "space"
different to `<samp><span class="samp">\s</span></samp>', which does not include &lt;VT&gt; (for Perl
compatibility).

   <p>The name &ldquo;word&rdquo; is a Perl extension, and &ldquo;blank&rdquo; is a GNU
extension from Perl 5.8. Another Perl extension is negation, which is
indicated by a `<samp><span class="samp">^</span></samp>' character after the colon. For example,

<pre class="verbatim">
         [12[:^digit:]]
</pre>

<p class="noindent">matches `<samp><span class="samp">1</span></samp>', `<samp><span class="samp">2</span></samp>', or any non-digit. PCRE (and Perl) also
recognize the POSIX syntax `<samp><span class="samp">[.</span><var>ch</var><span class="samp">.]</span></samp>' and `<samp><span class="samp">[=</span><var>ch</var><span class="samp">=]</span></samp>'
where <var>ch</var> is a &ldquo;collating element,&rdquo; but these are not
supported, and an error is given if they are encountered.

   <p>In UTF-8 mode, characters with values greater than 128 do not match
any of the POSIX character classes.

<h5 class="subsubheading">Vertical Bar</h5>

<p>Vertical bar characters are used to separate alternative patterns. For
example, the pattern

<pre class="verbatim">
         gilbert|sullivan
</pre>

<p class="noindent">matches either `<samp><span class="samp">gilbert</span></samp>' or `<samp><span class="samp">sullivan</span></samp>'. Any number of
alternatives may appear, and an empty alternative is permitted
(matching the empty string). The matching process tries each
alternative in turn, from left to right, and the first one that
succeeds is used. If the alternatives are within a subpattern (defined
below), "succeeds" means matching the rest of the main pattern as well
as the alternative in the subpattern.

<h5 class="subsubheading">Internal Option Setting</h5>

<p>The behavior of the matching engine can be adjusted from within the
pattern by a sequence of option letters enclosed between `<samp><span class="samp">(?</span></samp>' and
`<samp><span class="samp">)</span></samp>'.  The option letters are

     <dl>
<dt><code>i</code><dd>Caseless: characters in one case match the corresponding
     characters in other cases as well. 
<dt><code>m</code><dd>Multiline: `<samp><span class="samp">^</span></samp>' and `<samp><span class="samp">$</span></samp>' match at newlines
     as well as at beginning and end of string. 
<dt><code>s</code><dd>Dotall: dot matches any character, including newline characters. 
<dt><code>x</code><dd>Extended syntax: unescaped white space is ignored and embedded
     comments are possible. 
<dt><code>J</code><dd>Dupnames: names for capturing subpattern need not be unique. 
<dt><code>U</code><dd>Ungreedy: quantifiers match as few times as possible by default. 
<dt><code>X</code><dd>Extra: for forward compatibility, give an error if any escape sequence
with no defined meaning appears. 
</dl>

   <p>For example, `<samp><span class="samp">(?im)</span></samp>' sets caseless, multiline matching. It is
also possible to unset these options by preceding the letters with a
hyphen, and a combined setting and unsetting such as `<samp><span class="samp">(?im-sx)</span></samp>'
is also permitted.  (This would set the caseless and multiline options
while unsetting the dotall and extended-syntax options.)  If a letter
appears both before and after the hyphen, the option is unset.  The
lowercase option letters are Perl-compatible; the uppercase ones are
PCRE only.

   <p>When an option change occurs at top level (that is, not inside
subpattern parentheses), the change applies to the remainder of the
pattern that follows.  An option change within a subpattern (see below
for a description of subpatterns) affects only that part of the
current pattern that follows it, so

<pre class="verbatim">
         (a(?i)b)c
</pre>

<p class="noindent">matches `<samp><span class="samp">abc</span></samp>' and `<samp><span class="samp">aBc</span></samp>' and no other strings.  By this
means, options can be made to have different settings in different
parts of the pattern. Any changes made in one alternative do carry on
into subsequent branches within the same subpattern. For example,

<pre class="verbatim">
         (a(?i)b|c)
</pre>

<p class="noindent">matches `<samp><span class="samp">ab</span></samp>', `<samp><span class="samp">aB</span></samp>', `<samp><span class="samp">c</span></samp>', and `<samp><span class="samp">C</span></samp>', even though when
matching `<samp><span class="samp">C</span></samp>' the first branch is abandoned before the option
setting. This is because the effects of option settings happen when
the pattern is parsed. There would be some very weird behaviour
otherwise.

   <p><em>Note:</em> Unlike these options, the similar, PCRE-specific option
sequences that start with `<samp><span class="samp">(*</span></samp>' may appear only at the very
beginning of the pattern.  Details of these sequences are given in the
section entitled &ldquo;Newline sequences,&rdquo; above.

<h5 class="subsubheading">Subpatterns</h5>

<p>Subpatterns are delimited by parentheses (round brackets), which can
be nested.  Turning part of a pattern into a subpattern does two
things:

     <ol type=1 start=1>
<li>It localizes a set of alternatives. For example, the pattern

     <pre class="verbatim">     
              cat(aract|erpillar|)
</pre>

     <p class="noindent">matches one of the words `<samp><span class="samp">cat</span></samp>', `<samp><span class="samp">cataract</span></samp>', or
`<samp><span class="samp">caterpillar</span></samp>'. Without the parentheses, it would match
`<samp><span class="samp">cataract</span></samp>', `<samp><span class="samp">erpillar</span></samp>' or an empty string.

     <li>It sets up the subpattern as a capturing subpattern.  As used in
Monotone this only means that during matching, the portion of the
subject string that matched the subpattern is available for back
references.  Captured subpatterns are, for instance, not available to
callers of <code>regex.search</code>.  Opening parentheses are counted from
left to right (starting from 1) to obtain numbers for the capturing
subpatterns.

     <p>For example, if the string `<samp><span class="samp">the red king</span></samp>' is matched against the pattern

     <pre class="verbatim">     
              the ((red|white) (king|queen))
</pre>

     <p>the captured substrings are `<samp><span class="samp">red king</span></samp>', `<samp><span class="samp">red</span></samp>', and
`<samp><span class="samp">king</span></samp>', and are numbered 1, 2, and 3, respectively.
        </ol>

   <p>The fact that plain parentheses fulfil two functions is not always
helpful.  There are often times when a grouping subpattern is required
without a capturing requirement. If an opening parenthesis is followed
by a question mark and a colon, the subpattern does not do any
capturing, and is not counted when computing the number of any
subsequent capturing subpatterns. For example, if the string `<samp><span class="samp">the
white queen</span></samp>' is matched against the pattern

<pre class="verbatim">
         the ((?:red|white) (king|queen))
</pre>

<p class="noindent">the captured substrings are `<samp><span class="samp">white queen</span></samp>' and `<samp><span class="samp">queen</span></samp>', and
are numbered 1 and 2. The maximum number of capturing subpatterns is
65535.

   <p>As a convenient shorthand, if any option settings are required at the
start of a non-capturing subpattern, the option letters may appear
between the `<samp><span class="samp">?</span></samp>' and the `<samp><span class="samp">:</span></samp>'. Thus the two patterns

<pre class="verbatim">
         (?i:saturday|sunday)
         (?:(?i)saturday|sunday)
</pre>

<p class="noindent">match exactly the same set of strings. Because alternative branches
are tried from left to right, and options are not reset until the end
of the subpattern is reached, an option setting in one branch does
affect subsequent branches, so the above patterns match `<samp><span class="samp">SUNDAY</span></samp>'
as well as `<samp><span class="samp">Saturday</span></samp>'.

<h5 class="subsubheading">Duplicate Subpattern Numbers</h5>

<p>Perl 5.10 introduced a feature whereby each alternative in a
subpattern uses the same numbers for its capturing parentheses. Such a
subpattern starts with `<samp><span class="samp">(?|</span></samp>' and is itself a non-capturing
subpattern. For example, consider this pattern:

<pre class="verbatim">
         (?|(Sat)ur|(Sun))day
</pre>

<p class="noindent">Because the two alternatives are inside a `<samp><span class="samp">(?|</span></samp>' group, both sets
of capturing parentheses are numbered one. Thus, when the pattern
matches, you can look at captured substring number one, whichever
alternative matched. This construct is useful when you want to capture
part, but not all, of one of a number of alternatives. Inside a
`<samp><span class="samp">(?|</span></samp>' group, parentheses are numbered as usual, but the number is
reset at the start of each branch. The numbers of any capturing
buffers that follow the subpattern start after the highest number used
in any branch. The following example is taken from the Perl
documentation.  The numbers underneath show in which buffer the
captured content will be stored.

<pre class="verbatim">
  # before  ---------------branch-reset----------- after
  / ( a )  (?| x ( y ) z | (p (q) r) | (t) u (v) ) ( z ) /x
  # 1            2         2  3        2     3     4
</pre>

<p class="noindent">A backreference or a recursive call to a numbered subpattern always
refers to the first one in the pattern with the given number.

   <p>An alternative approach to using this &ldquo;branch reset&rdquo; feature is to
use duplicate named subpatterns, as described in the next section.

<h5 class="subsubheading">Named Subpatterns</h5>

<p>Identifying capturing parentheses by number is simple, but it can be
very hard to keep track of the numbers in complicated regular
expressions. Furthermore, if an expression is modified, the numbers
may change. To help with this difficulty, PCRE supports the naming of
subpatterns. This feature was not added to Perl until release
5.10. Python had the feature earlier, and PCRE introduced it at
release 4.0, using the Python syntax. PCRE now supports both the Perl
and the Python syntax.

   <p>In PCRE, a subpattern can be named in one of three ways:
`<samp><span class="samp">(?&lt;</span><var>name</var><span class="samp">&gt;...)</span></samp>' or `<samp><span class="samp">(?'</span><var>name</var><span class="samp">'...)</span></samp>' as in Perl, or
`<samp><span class="samp">(?P&lt;</span><var>name</var><span class="samp">&gt;...)</span></samp>' as in Python. References to capturing
parentheses from other parts of the pattern, such as backreferences,
recursion, and conditions, can be made by name as well as by number.

   <p>Names consist of up to 32 alphanumeric characters and
underscores. Named capturing parentheses are still allocated numbers
as well as names, exactly as if the names were not present.

   <p>By default, a name must be unique within a pattern, but it is possible
to relax this constraint by setting the `<samp><span class="samp">(?J)</span></samp>' option. This can
be useful for patterns where only one instance of the named
parentheses can match. Suppose you want to match the name of a
weekday, either as a 3-letter abbreviation or as the full name, and in
both cases you want to extract the abbreviation. This pattern
(ignoring the line breaks) does the job:

<pre class="verbatim">
         (?Jx)
         (?&lt;DN>Mon|Fri|Sun)(?:day)?|
         (?&lt;DN>Tue)(?:sday)?|
         (?&lt;DN>Wed)(?:nesday)?|
         (?&lt;DN>Thu)(?:rsday)?|
         (?&lt;DN>Sat)(?:urday)?
</pre>

<p class="noindent">There are five capturing substrings, but only one is ever set after a
match.  (An alternative way of solving this problem is to use a
&ldquo;branch reset&rdquo; subpattern, as described in the previous section.)

<h5 class="subsubheading">Repetition</h5>

<p>Repetition is specified by <dfn>quantifiers</dfn>, which can follow any of
the following items:

     <ul>
<li>  a literal data character
<li>  the dot metacharacter
<li>  the `<samp><span class="samp">\C</span></samp>' escape sequence
<li>  the `<samp><span class="samp">\X</span></samp>' escape sequence (in UTF-8 mode with Unicode properties)
<li>  the `<samp><span class="samp">\R</span></samp>' escape sequence
<li>  an escape such as `<samp><span class="samp">\d</span></samp>' that matches a single character
<li>  a character class
<li>  a back reference (see next section)
<li>  a parenthesized subpattern (unless it is an assertion)
</ul>

   <p>The general repetition quantifier specifies a minimum and maximum
number of permitted matches, by giving the two numbers in curly
brackets (braces), separated by a comma. The numbers must be less than
65536, and the first must be less than or equal to the second. For
example:

<pre class="verbatim">
         z{2,4}
</pre>

<p class="noindent">matches `<samp><span class="samp">zz</span></samp>', `<samp><span class="samp">zzz</span></samp>', or `<samp><span class="samp">zzzz</span></samp>'. A closing brace on its
own is not a special character. If the second number is omitted, but
the comma is present, there is no upper limit; if the second number
and the comma are both omitted, the quantifier specifies an exact
number of required matches. Thus

<pre class="verbatim">
         [aeiou]{3,}
</pre>

<p class="noindent">matches at least 3 successive vowels, but may match many more, while

<pre class="verbatim">
         \d{8}
</pre>

<p class="noindent">matches exactly 8 digits. An opening curly bracket that appears in a
position where a quantifier is not allowed, or one that does not match
the syntax of a quantifier, is taken as a literal character. For
example, `<samp><span class="samp">{,6}</span></samp>' is not a quantifier, but a literal string of four
characters.

   <p>In UTF-8 mode, quantifiers apply to UTF-8 characters rather than to
individual bytes. Thus, for example, `<samp><span class="samp">\x{100}{2}</span></samp>' matches two
UTF-8 characters, each of which is represented by a two-byte
sequence. Similarly, `<samp><span class="samp">\X{3}</span></samp>' matches three Unicode extended
sequences, each of which may be several bytes long (and they may be of
different lengths).

   <p>The quantifier `<samp><span class="samp">{0}</span></samp>' is permitted, causing the expression to
behave as if the previous item and the quantifier were not present.

   <p>For convenience, the three most common quantifiers have
single-character abbreviations:

     <dl>
<dt><code>*</code><dd>is equivalent to {0,}
<dt><code>+</code><dd>is equivalent to {1,}
<dt><code>?</code><dd>is equivalent to {0,1}
</dl>

   <p>It is possible to construct infinite loops by following a subpattern that can
match no characters with a quantifier that has no upper limit, for example:

<pre class="verbatim">
         (a?)*
</pre>

<p class="noindent">Earlier versions of Perl and PCRE used to give an error at compile
time for such patterns. However, because there are cases where this
can be useful, such patterns are now accepted, but if any repetition
of the subpattern does in fact match no characters, the loop is
forcibly broken.

   <p>By default, the quantifiers are <dfn>greedy</dfn>, that is, they match as
much as possible (up to the maximum number of permitted times),
without causing the rest of the pattern to fail. The classic example
of where this gives problems is in trying to match comments in C
programs. These appear between `<samp><span class="samp">/*</span></samp>' and `<samp><span class="samp">*/</span></samp>', and within the
comment, individual `<samp><span class="samp">*</span></samp>' and `<samp><span class="samp">/</span></samp>' characters may appear. An
attempt to match C comments by applying the pattern

<pre class="verbatim">
         /\*.*\*/
</pre>

<p class="noindent">to the string

<pre class="verbatim">
         /* first comment */  not comment  /* second comment */
</pre>

<p class="noindent">fails, because it matches the entire string owing to the greediness of
the `<samp><span class="samp">.*</span></samp>' item.

   <p>However, if a quantifier is followed by a question mark, it ceases to
be greedy, and instead matches the minimum number of times possible,
so the pattern

<pre class="verbatim">
         /\*.*?\*/
</pre>

<p class="noindent">does the right thing with the C comments. The meaning of the various
quantifiers is not otherwise changed, just the preferred number of
matches.  Do not confuse this use of question mark with its use as a
quantifier in its own right. Because it has two uses, it can sometimes
appear doubled, as in

<pre class="verbatim">
         \d??\d
</pre>

<p class="noindent">which matches one digit by preference, but can match two if that is the only
way the rest of the pattern matches.

   <p>If the `<samp><span class="samp">(?U)</span></samp>' option is set (an option that is not available in
Perl), the quantifiers are not greedy by default, but individual ones
can be made greedy by following them with a question mark. In other
words, it inverts the default behaviour.

   <p>When a parenthesized subpattern is quantified with a minimum repeat count that
is greater than 1 or with a limited maximum, more memory is required for the
compiled pattern, in proportion to the size of the minimum or maximum.

   <p>If a pattern starts with `<samp><span class="samp">.*</span></samp>' or `<samp><span class="samp">.{0,}</span></samp>' and the
`<samp><span class="samp">(?s)</span></samp>' option is set, thus allowing the dot to match newlines,
the pattern is implicitly anchored, because whatever follows will be
tried against every character position in the subject string, so there
is no point in retrying the overall match at any position after the
first. PCRE normally treats such a pattern as though it were preceded
by `<samp><span class="samp">\A</span></samp>'.

   <p>In cases where it is known that the subject string contains no
newlines, it is worth setting `<samp><span class="samp">(?s)</span></samp>' in order to obtain this
optimization, or alternatively using `<samp><span class="samp">^</span></samp>' or `<samp><span class="samp">\A</span></samp>' to indicate
anchoring explicitly.

   <p>However, there is one situation where the optimization cannot be
used. When .* is inside capturing parentheses that are the subject of
a backreference elsewhere in the pattern, a match at the start may
fail where a later one succeeds. Consider, for example:

<pre class="verbatim">
         (.*)abc\1
</pre>

<p class="noindent">If the subject is `<samp><span class="samp">xyz123abc123</span></samp>' the match point is the fourth
character. For this reason, such a pattern is not implicitly anchored.

   <p>When a capturing subpattern is repeated, the value captured is the
substring that matched the final iteration. For example, after

<pre class="verbatim">
         (tweedle[dume]{3}\s*)+
</pre>

<p class="noindent">has matched `<samp><span class="samp">tweedledum tweedledee</span></samp>' the value of the captured
substring is `<samp><span class="samp">tweedledee</span></samp>'. However, if there are nested capturing
subpatterns, the corresponding captured values may have been set in
previous iterations. For example, after

<pre class="verbatim">
         (a|(b))+
</pre>

<p class="noindent">matches `<samp><span class="samp">aba</span></samp>' the value of the second captured substring is `<samp><span class="samp">b</span></samp>'.

<h5 class="subsubheading">Atomic Grouping and Possessive Quantifiers</h5>

<p>With both maximizing (<dfn>greedy</dfn>) and minimizing (<dfn>ungreedy</dfn> or
<dfn>lazy</dfn>) repetition, failure of what follows normally causes the
repeated item to be re-evaluated to see if a different number of
repeats allows the rest of the pattern to match. Sometimes it is
useful to prevent this, either to change the nature of the match, or
to cause it fail earlier than it otherwise might, when the author of
the pattern knows there is no point in carrying on.

   <p>Consider, for example, the pattern `<samp><span class="samp">\d+foo</span></samp>' when applied to the
subject line

<pre class="verbatim">
         123456bar
</pre>

   <p>After matching all 6 digits and then failing to match `<samp><span class="samp">foo</span></samp>', the
normal action of the matcher is to try again with only 5 digits
matching the `<samp><span class="samp">\d+</span></samp>' item, and then with 4, and so on, before
ultimately failing. <dfn>Atomic grouping</dfn> (a term taken from Jeffrey
Friedl's book) provides the means for specifying that once a
subpattern has matched, it is not to be re-evaluated in this way.

   <p>If we use atomic grouping for the previous example, the matcher gives
up immediately on failing to match `<samp><span class="samp">foo</span></samp>' the first time. The
notation is a kind of special parenthesis, starting with `<samp><span class="samp">(?&gt;</span></samp>' as in
this example:

<pre class="verbatim">
         (?>\d+)foo
</pre>

<p class="noindent">This kind of parenthesis &ldquo;locks up&rdquo; the part of the pattern it
contains once it has matched, and a failure further into the pattern
is prevented from backtracking into it. Backtracking past it to
previous items, however, works as normal.  Atomic grouping subpatterns
are not capturing subpatterns.

   <p>An alternative description is that a subpattern of this type matches
the string of characters that an identical standalone pattern would
match, if anchored at the current point in the subject string.

   <p>Simple cases such as the above example can be thought of as a
maximizing repeat that must swallow everything it can. So, while both
`<samp><span class="samp">\d+</span></samp>' and `<samp><span class="samp">\d+?</span></samp>' are prepared to adjust the number of digits
they match in order to make the rest of the pattern match,
`<samp><span class="samp">(?&gt;\d+)</span></samp>' can only match an entire sequence of digits.

   <p>Atomic groups in general can of course contain arbitrarily complicated
subpatterns, and can be nested. However, when the subpattern for an
atomic group is just a single repeated item, as in the example above,
a simpler notation, called a <dfn>possessive quantifier</dfn>, can be
used. This consists of an additional `<samp><span class="samp">+</span></samp>' character following a
quantifier. Using this notation, the previous example can be rewritten
as

<pre class="verbatim">
         \d++foo
</pre>

<p class="noindent">Note that a possessive quantifier can be used with an entire group, for
example:

<pre class="verbatim">
         (abc|xyz){2,3}+
</pre>

<p class="noindent">Possessive quantifiers are always greedy; the setting of the
`<samp><span class="samp">(?U)</span></samp>' option is ignored. They are a convenient notation for the
simpler forms of atomic group. However, there is no difference in the
meaning of a possessive quantifier and the equivalent atomic group,
though there may be a performance difference; possessive quantifiers
should be slightly faster.

   <p>The possessive quantifier syntax is an extension to the Perl 5.8
syntax.  Jeffrey Friedl originated the idea (and the name) in the
first edition of his book. Mike McCloskey liked it, so implemented it
when he built Sun's Java package, and PCRE copied it from there. It
ultimately found its way into Perl at release 5.10.

   <p>PCRE has an optimization that automatically &ldquo;possessifies&rdquo; certain
simple pattern constructs. For example, the sequence `<samp><span class="samp">A+B</span></samp>' is
treated as `<samp><span class="samp">A++B</span></samp>' because there is no point in backtracking into
a sequence of `<samp><span class="samp">A</span></samp>'s when `<samp><span class="samp">B</span></samp>' must follow.

   <p>When a pattern contains an unlimited repeat inside a subpattern that
can itself be repeated an unlimited number of times, the use of an
atomic group is the only way to avoid some failing matches taking a
very long time indeed. The pattern

<pre class="verbatim">
         (\D+|&lt;\d+>)*[!?]
</pre>

<p class="noindent">matches an unlimited number of substrings that either consist of
non-digits, or digits enclosed in `<samp><span class="samp">&lt;&gt;</span></samp>', followed by either
`<samp><span class="samp">!</span></samp>' or `<samp><span class="samp">?</span></samp>'. When it matches, it runs quickly. However, if it
is applied to

<pre class="verbatim">
         aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
</pre>

<p class="noindent">it takes a long time before reporting failure. This is because the
string can be divided between the internal `<samp><span class="samp">\D+</span></samp>' repeat and the
external `<samp><span class="samp">*</span></samp>' repeat in a large number of ways, and all have to be
tried. (The example uses `<samp><span class="samp">[!?]</span></samp>' rather than a single character at
the end, because both PCRE and Perl have an optimization that allows
for fast failure when a single character is used. They remember the
last single character that is required for a match, and fail early if
it is not present in the string.) If the pattern is changed so that it
uses an atomic group, like this:

<pre class="verbatim">
         ((?>\D+)|&lt;\d+>)*[!?]
</pre>

<p class="noindent">sequences of non-digits cannot be broken, and failure happens quickly.

<h5 class="subsubheading">Back References</h5>

<p>Outside a character class, a backslash followed by a digit greater
than 0 (and possibly further digits) is a back reference to a
capturing subpattern earlier (that is, to its left) in the pattern,
provided there have been that many previous capturing left
parentheses.

   <p>However, if the decimal number following the backslash is less than
10, it is always taken as a back reference, and causes an error only
if there are not that many capturing left parentheses in the entire
pattern. In other words, the parentheses that are referenced need not
be to the left of the reference for numbers less than 10. A &ldquo;forward
back reference&rdquo; of this type can make sense when a repetition is
involved and the subpattern to the right has participated in an
earlier iteration.

   <p>It is not possible to have a numerical &ldquo;forward back reference&rdquo; to a
subpattern whose number is 10 or more using this syntax because a
sequence such as `<samp><span class="samp">\50</span></samp>' is interpreted as a character defined in
octal. See the subsection entitled &ldquo;Non-printing characters&rdquo; above
for further details of the handling of digits following a
backslash. There is no such problem when named parentheses are used. A
back reference to any subpattern is possible using named parentheses
(see below).

   <p>Another way of avoiding the ambiguity inherent in the use of digits
following a backslash is to use the `<samp><span class="samp">\g</span></samp>' escape sequence, which
is a feature introduced in Perl 5.10. This escape must be followed by
an unsigned number or a negative number, optionally enclosed in
braces. These examples are all identical:

<pre class="verbatim">
         (ring), \1
         (ring), \g1
         (ring), \g{1}
</pre>

   <p>An unsigned number specifies an absolute reference without the
ambiguity that is present in the older syntax. It is also useful when
literal digits follow the reference. A negative number is a relative
reference. Consider this example:

<pre class="verbatim">
         (abc(def)ghi)\g{-1}
</pre>

<p class="noindent">The sequence `<samp><span class="samp">\g{-1}</span></samp>' is a reference to the most recently
started capturing subpattern before `<samp><span class="samp">\g</span></samp>', that is, is it
equivalent to `<samp><span class="samp">\2</span></samp>'. Similarly, `<samp><span class="samp">\g{-2}</span></samp>' would be
equivalent to `<samp><span class="samp">\1</span></samp>'. The use of relative references can be helpful
in long patterns, and also in patterns that are created by joining
together fragments that contain references within themselves.

   <p>A back reference matches whatever actually matched the capturing
subpattern in the current subject string, rather than anything
matching the subpattern itself (see &ldquo;Subpatterns as subroutines&rdquo; below
for a way of doing that). So the pattern

<pre class="verbatim">
         (sens|respons)e and \1ibility
</pre>

<p class="noindent">matches `<samp><span class="samp">sense and sensibility</span></samp>' and `<samp><span class="samp">response and
responsibility</span></samp>', but not `<samp><span class="samp">sense and responsibility</span></samp>'. If caseful
matching is in force at the time of the back reference, the case of
letters is relevant. For example,

<pre class="verbatim">
         ((?i)rah)\s+\1
</pre>

<p class="noindent">matches `<samp><span class="samp">rah rah</span></samp>' and `<samp><span class="samp">RAH RAH</span></samp>', but not `<samp><span class="samp">RAH rah</span></samp>',
even though the original capturing subpattern is matched caselessly.

   <p>There are several different ways of writing back references to named
subpatterns. The .NET syntax `<samp><span class="samp">\k{name}</span></samp>' and the Perl syntax
`<samp><span class="samp">\k&lt;name&gt;</span></samp>' or `<samp><span class="samp">\k'name'</span></samp>' are supported, as is the Python
syntax (?P=name). Perl 5.10's unified back reference syntax, in which
`<samp><span class="samp">\g</span></samp>' can be used for both numeric and named references, is also
supported. We could rewrite the above example in any of the following
ways:

<pre class="verbatim">
         (?&lt;p1>(?i)rah)\s+\k&lt;p1>
         (?'p1'(?i)rah)\s+\k{p1}
         (?P&lt;p1>(?i)rah)\s+(?P=p1)
         (?&lt;p1>(?i)rah)\s+\g{p1}
</pre>

<p class="noindent">A subpattern that is referenced by name may appear in the pattern
before or after the reference.

   <p>There may be more than one back reference to the same subpattern. If a
subpattern has not actually been used in a particular match, any back
references to it always fail. For example, the pattern

<pre class="verbatim">
         (a|(bc))\2
</pre>

<p class="noindent">always fails if it starts to match `<samp><span class="samp">a</span></samp>' rather than
`<samp><span class="samp">bc</span></samp>'. Because there may be many capturing parentheses in a
pattern, all digits following the backslash are taken as part of a
potential back reference number. If the pattern continues with a digit
character, some delimiter must be used to terminate the back
reference. If the `<samp><span class="samp">(?x)</span></samp>' option is set, this can be whitespace. 
Otherwise an empty comment (see &ldquo;Comments&rdquo; below) can be used.

   <p>A back reference that occurs inside the parentheses to which it refers
fails when the subpattern is first used, so, for example, `<samp><span class="samp">(a\1)</span></samp>'
never matches.  However, such references can be useful inside repeated
subpatterns. For example, the pattern

<pre class="verbatim">
         (a|b\1)+
</pre>

<p class="noindent">matches any number of `<samp><span class="samp">a</span></samp>'s and also `<samp><span class="samp">aba</span></samp>', `<samp><span class="samp">ababbaa</span></samp>'
etc. At each iteration of the subpattern, the back reference matches
the character string corresponding to the previous iteration. In order
for this to work, the pattern must be such that the first iteration
does not need to match the back reference. This can be done using
alternation, as in the example above, or by a quantifier with a
minimum of zero.

<h5 class="subsubheading">Assertions</h5>

<p>An assertion is a test on the characters following or preceding the
current matching point that does not actually consume any
characters. The simple assertions coded as `<samp><span class="samp">\b</span></samp>', `<samp><span class="samp">\B</span></samp>',
`<samp><span class="samp">\A</span></samp>', `<samp><span class="samp">\G</span></samp>', `<samp><span class="samp">\Z</span></samp>', `<samp><span class="samp">\z</span></samp>', `<samp><span class="samp">^</span></samp>' and `<samp><span class="samp">$</span></samp>' are
described above.

   <p>More complicated assertions are coded as subpatterns. There are two
kinds: those that look ahead of the current position in the subject
string, and those that look behind it. An assertion subpattern is
matched in the normal way, except that it does not cause the current
matching position to be changed.

   <p>Assertion subpatterns are not capturing subpatterns, and may not be
repeated, because it makes no sense to assert the same thing several
times. If any kind of assertion contains capturing subpatterns within
it, these are counted for the purposes of numbering the capturing
subpatterns in the whole pattern.  However, substring capturing is
carried out only for positive assertions, because it does not make
sense for negative assertions.

<h5 class="subsubheading">Lookahead Assertions</h5>

<p>Lookahead assertions start with `<samp><span class="samp">(?=</span></samp>' for positive assertions and
`<samp><span class="samp">(?!</span></samp>'  for negative assertions. For example,

<pre class="verbatim">
         \w+(?=;)
</pre>

<p class="noindent">matches a word followed by a semicolon, but does not include the semicolon in
the match, and

<pre class="verbatim">
         foo(?!bar)
</pre>

<p class="noindent">matches any occurrence of `<samp><span class="samp">foo</span></samp>' that is not followed by
`<samp><span class="samp">bar</span></samp>'. Note that the apparently similar pattern

<pre class="verbatim">
         (?!foo)bar
</pre>

<p class="noindent">does not find an occurrence of `<samp><span class="samp">bar</span></samp>' that is preceded by
something other than `<samp><span class="samp">foo</span></samp>'; it finds any occurrence of `<samp><span class="samp">bar</span></samp>'
whatsoever, because the assertion `<samp><span class="samp">(?!foo)</span></samp>' is always true when
the next three characters are `<samp><span class="samp">bar</span></samp>'. A lookbehind assertion is
needed to achieve the other effect.

   <p>If you want to force a matching failure at some point in a pattern,
the most convenient way to do it is with `<samp><span class="samp">(?!)</span></samp>' because an empty
string always matches, so an assertion that requires there not to be
an empty string must always fail.

<h5 class="subsubheading">Lookbehind Assertions</h5>

<p>Lookbehind assertions start with `<samp><span class="samp">(?&lt;=</span></samp>' for positive assertions
and `<samp><span class="samp">(?&lt;!</span></samp>'  for negative assertions. For example,

<pre class="verbatim">
         (?&lt;!foo)bar
</pre>

<p class="noindent">matches an occurrence of `<samp><span class="samp">bar</span></samp>' that is not preceded by
`<samp><span class="samp">foo</span></samp>'. The contents of a lookbehind assertion are restricted such
that all the strings it matches must have a fixed length. However, if
there are several top-level alternatives, they do not all have to have
the same fixed length. Thus

<pre class="verbatim">
         (?&lt;=bullock|donkey)
</pre>

<p class="noindent">is permitted, but

<pre class="verbatim">
         (?&lt;!dogs?|cats?)
</pre>

<p class="noindent">causes an error at compile time. Branches that match different length
strings are permitted only at the top level of a lookbehind
assertion. This is an extension compared with Perl (at least for 5.8),
which requires all branches to match the same length of string. An
assertion such as

<pre class="verbatim">
         (?&lt;=ab(c|de))
</pre>

<p class="noindent">is not permitted, because its single top-level branch can match two different
lengths, but it is acceptable if rewritten to use two top-level branches:

<pre class="verbatim">
         (?&lt;=abc|abde)
</pre>

   <p>In some cases, the Perl 5.10 escape sequence `<samp><span class="samp">\K</span></samp>' (see above) can
be used instead of a lookbehind assertion; this is not restricted to a
fixed-length.

   <p>The implementation of lookbehind assertions is, for each alternative,
to temporarily move the current position back by the fixed length and
then try to match. If there are insufficient characters before the
current position, the assertion fails.

   <p>PCRE does not allow the `<samp><span class="samp">\C</span></samp>' escape (which matches a single byte
in UTF-8 mode) to appear in lookbehind assertions, because it makes it
impossible to calculate the length of the lookbehind. The `<samp><span class="samp">\X</span></samp>'
and `<samp><span class="samp">\R</span></samp>' escapes, which can match different numbers of bytes, are
also not permitted.

   <p>Possessive quantifiers can be used in conjunction with lookbehind
assertions to specify efficient matching at the end of the subject
string. Consider a simple pattern such as

<pre class="verbatim">
         abcd$
</pre>

<p class="noindent">when applied to a long string that does not match. Because matching
proceeds from left to right, PCRE will look for each `<samp><span class="samp">a</span></samp>' in the
subject and then see if what follows matches the rest of the
pattern. If the pattern is specified as

<pre class="verbatim">
         ^.*abcd$
</pre>

<p class="noindent">the initial `<samp><span class="samp">.*</span></samp>' matches the entire string at first, but when this fails
(because there is no following `<samp><span class="samp">a</span></samp>'), it backtracks to match all
but the last character, then all but the last two characters, and so
on. Once again the search for `<samp><span class="samp">a</span></samp>' covers the entire string, from
right to left, so we are no better off. However, if the pattern is
written as

<pre class="verbatim">
         ^.*+(?&lt;=abcd)
</pre>

<p class="noindent">there can be no backtracking for the `<samp><span class="samp">.*+</span></samp>' item; it can match
only the entire string. The subsequent lookbehind assertion does a
single test on the last four characters. If it fails, the match fails
immediately. For long strings, this approach makes a significant
difference to the processing time.

<h5 class="subsubheading">Using multiple assertions</h5>

<p>Several assertions (of any sort) may occur in succession. For example,

<pre class="verbatim">
         (?&lt;=\d{3})(?&lt;!999)foo
</pre>

<p class="noindent">matches `<samp><span class="samp">foo</span></samp>' preceded by three digits that are not
`<samp><span class="samp">999</span></samp>'. Notice that each of the assertions is applied
independently at the same point in the subject string. First there is
a check that the previous three characters are all digits, and then
there is a check that the same three characters are not `<samp><span class="samp">999</span></samp>'. 
This pattern does <em>not</em> match `<samp><span class="samp">foo</span></samp>' preceded by six
characters, the first of which are digits and the last three of which
are not `<samp><span class="samp">999</span></samp>'. For example, it doesn't match `<samp><span class="samp">123abcfoo</span></samp>'. A
pattern to do that is

<pre class="verbatim">
         (?&lt;=\d{3}...)(?&lt;!999)foo
</pre>

<p class="noindent">This time the first assertion looks at the preceding six characters,
checking that the first three are digits, and then the second
assertion checks that the preceding three characters are not
`<samp><span class="samp">999</span></samp>'.

   <p>Assertions can be nested in any combination. For example,

<pre class="verbatim">
         (?&lt;=(?&lt;!foo)bar)baz
</pre>

<p class="noindent">matches an occurrence of `<samp><span class="samp">baz</span></samp>' that is preceded by `<samp><span class="samp">bar</span></samp>'
which in turn is not preceded by `<samp><span class="samp">foo</span></samp>', while

<pre class="verbatim">
         (?&lt;=\d{3}(?!999)...)foo
</pre>

<p class="noindent">is another pattern that matches `<samp><span class="samp">foo</span></samp>' preceded by three digits
and any three characters that are not `<samp><span class="samp">999</span></samp>'.

<h5 class="subsubheading">Conditional Subpatterns</h5>

<p>It is possible to cause the matching process to obey a subpattern
conditionally or to choose between two alternative subpatterns,
depending on the result of an assertion, or whether a previous
capturing subpattern matched or not. The two possible forms of
conditional subpattern are

     <ul>
<li>         (?(<var>condition</var>)<var>yes-pattern</var>)
<li>         (?(<var>condition</var>)<var>yes-pattern</var>|<var>no-pattern</var>)
</ul>

   <p>If the <var>condition</var> is satisfied, the <var>yes-pattern</var> is used;
otherwise the <var>no-pattern</var> (if present) is used. If there are more
than two alternatives in the subpattern, a compile-time error occurs.

   <p>There are four kinds of condition: references to subpatterns,
references to recursion, a pseudo-condition called `<samp><span class="samp">DEFINE</span></samp>', and
assertions.

<h5 class="subsubheading">Checking for a used subpattern by number</h5>

<p>If the text between the parentheses consists of a sequence of digits,
the condition is true if the capturing subpattern of that number has
previously matched. An alternative notation is to precede the digits
with a plus or minus sign. In this case, the subpattern number is
relative rather than absolute.  The most recently opened parentheses
can be referenced by `<samp><span class="samp">(?(-1)</span></samp>', the next most recent by
`<samp><span class="samp">(?(-2)</span></samp>', and so on. In looping constructs it can also make sense
to refer to subsequent groups with constructs such as `<samp><span class="samp">(?(+2)</span></samp>'.

   <p>Consider the following pattern, which contains non-significant white
space to make it more readable and to divide it into three parts for
ease of discussion (assume a preceding `<samp><span class="samp">(?x)</span></samp>'):

<pre class="verbatim">
         ( \( )?    [^()]+    (?(1) \) )
</pre>

   <p>The first part matches an optional opening parenthesis, and if that
character is present, sets it as the first captured substring. The
second part matches one or more characters that are not
parentheses. The third part is a conditional subpattern that tests
whether the first set of parentheses matched or not. If they did, that
is, if subject started with an opening parenthesis, the condition is
true, and so the yes-pattern is executed and a closing parenthesis is
required. Otherwise, since no-pattern is not present, the subpattern
matches nothing. In other words, this pattern matches a sequence of
non-parentheses, optionally enclosed in parentheses.

   <p>If you were embedding this pattern in a larger one, you could use a
relative reference:

<pre class="verbatim">
         ...other stuff... ( \( )?    [^()]+    (?(-1) \) ) ...
</pre>

   <p>This makes the fragment independent of the parentheses in the larger pattern.

<h5 class="subsubheading">Checking for a used subpattern by name</h5>

<p>Perl uses the syntax `<samp><span class="samp">(?(&lt;name&gt;)...)</span></samp>' or `<samp><span class="samp">(?('name')...)</span></samp>' to
test for a used subpattern by name. For compatibility with earlier
versions of PCRE, which had this facility before Perl, the syntax
`<samp><span class="samp">(?(name)...)</span></samp>' is also recognized. However, there is a possible
ambiguity with this syntax, because subpattern names may consist
entirely of digits. PCRE looks first for a named subpattern; if it
cannot find one and the name consists entirely of digits, PCRE looks
for a subpattern of that number, which must be greater than
zero. Using subpattern names that consist entirely of digits is not
recommended.

   <p>Rewriting the above example to use a named subpattern gives this:

<pre class="verbatim">
         (?&lt;OPEN> \( )?    [^()]+    (?(&lt;OPEN>) \) )
</pre>

<h5 class="subsubheading">Checking for pattern recursion</h5>

<p>If the condition is the string `<samp><span class="samp">(R)</span></samp>', and there is no subpattern
with the name `<samp><span class="samp">R</span></samp>', the condition is true if a recursive call to
the whole pattern or any subpattern has been made. If digits or a name
preceded by ampersand follow the letter `<samp><span class="samp">R</span></samp>', for example:

<pre class="verbatim">
         (?(R3)...) or (?(R&amp;name)...)
</pre>

<p class="noindent">the condition is true if the most recent recursion is into the
subpattern whose number or name is given. This condition does not
check the entire recursion stack.

   <p>At &ldquo;top level,&rdquo; all these recursion test conditions are false. Recursive
patterns are described below.

<h5 class="subsubheading">Defining subpatterns for use by reference only</h5>

<p>If the condition is the string `<samp><span class="samp">(DEFINE)</span></samp>', and there is no
subpattern with the name `<samp><span class="samp">DEFINE</span></samp>', the condition is always
false. In this case, there may be only one alternative in the
subpattern. It is always skipped if control reaches this point in the
pattern; the idea of DEFINE is that it can be used to define
<dfn>subroutines</dfn> that can be referenced from elsewhere. (The use of
subroutines is described below.) For example, a pattern to match an
IPv4 address could be written like this (ignore whitespace and line
breaks):

<pre class="verbatim">
         (?(DEFINE) (?&lt;byte> 2[0-4]\d | 25[0-5] | 1\d\d | [1-9]?\d) )
         \b (?&amp;byte) (\.(?&amp;byte)){3} \b
</pre>

   <p>The first part of the pattern is a DEFINE group inside which a another
group named "byte" is defined. This matches an individual component of
an IPv4 address (a number less than 256). When matching takes place,
this part of the pattern is skipped because DEFINE acts like a false
condition.

   <p>The rest of the pattern uses references to the named group to match
the four dot-separated components of an IPv4 address, insisting on a
word boundary at each end.

<h5 class="subsubheading">Assertion conditions</h5>

<p>If the condition is not in any of the above formats, it must be an
assertion.  This may be a positive or negative lookahead or lookbehind
assertion. Consider this pattern, again containing non-significant
white space, and with the two alternatives on the second line:

<pre class="verbatim">
         (?(?=[^a-z]*[a-z])
         \d{2}-[a-z]{3}-\d{2}  |  \d{2}-\d{2}-\d{2} )
</pre>

   <p>The condition is a positive lookahead assertion that matches an
optional sequence of non-letters followed by a letter. In other words,
it tests for the presence of at least one letter in the subject. If a
letter is found, the subject is matched against the first alternative;
otherwise it is matched against the second. This pattern matches
strings in one of the two forms `<samp><var>dd</var><span class="samp">-</span><var>aaa</var><span class="samp">-</span><var>dd</var></samp>' or
`<samp><var>dd</var><span class="samp">-</span><var>dd</var><span class="samp">-</span><var>dd</var></samp>', where <var>aaa</var> are letters and
<var>dd</var> are digits.

<h5 class="subsubheading">Comments</h5>

<p>The sequence `<samp><span class="samp">(?#</span></samp>' marks the start of a comment that continues up
to the next closing parenthesis. Nested parentheses are not
permitted. The characters that make up a comment play no part in the
pattern matching at all.

   <p>If the `<samp><span class="samp">(?x)</span></samp>' option is set, an unescaped `<samp><span class="samp">#</span></samp>' character
outside a character class introduces a comment that continues to
immediately after the next newline in the pattern.

<h5 class="subsubheading">Recursive Patterns</h5>

<p>Consider the problem of matching a string in parentheses, allowing for
unlimited nested parentheses. Without the use of recursion, the best
that can be done is to use a pattern that matches up to some fixed
depth of nesting. It is not possible to handle an arbitrary nesting
depth.

   <p>PCRE supports special syntax for recursion of the entire pattern, and
also for individual subpattern recursion. After its introduction in
PCRE and Python, this kind of recursion was introduced into Perl at
release 5.10.

   <p>A special item that consists of `<samp><span class="samp">(?</span></samp>' followed by a number greater
than zero and a closing parenthesis is a recursive call of the
subpattern of the given number, provided that it occurs inside that
subpattern. (If not, it is a subroutine call, which is described in
the next section.) The special item `<samp><span class="samp">(?R)</span></samp>' or `<samp><span class="samp">(?0)</span></samp>' is a
recursive call of the entire regular expression.

   <p>In PCRE (like Python, but unlike Perl), a recursive subpattern call is
always treated as an atomic group. That is, once it has matched some
of the subject string, it is never re-entered, even if it contains
untried alternatives and there is a subsequent matching failure.

   <p>This PCRE pattern solves the nested parentheses problem (whitespace is
insignificant):

<pre class="verbatim">
         \( ( (?>[^()]+) | (?R) )* \)
</pre>

   <p>First it matches an opening parenthesis. Then it matches any number of
substrings which can either be a sequence of non-parentheses, or a
recursive match of the pattern itself (that is, a correctly
parenthesized substring).  Finally there is a closing parenthesis.

   <p>If this were part of a larger pattern, you would not want to recurse
the entire pattern, so instead you could use this:

<pre class="verbatim">
         ( \( ( (?>[^()]+) | (?1) )* \) )
</pre>

<p class="noindent">We have put the pattern into parentheses, and caused the recursion to
refer to them instead of the whole pattern.

   <p>In a larger pattern, keeping track of parenthesis numbers can be
tricky. This is made easier by the use of relative references. (A Perl
5.10 feature.)  Instead of `<samp><span class="samp">(?1)</span></samp>' in the pattern above you can
write `<samp><span class="samp">(?-2)</span></samp>' to refer to the second most recently opened
parentheses preceding the recursion. In other words, a negative number
counts capturing parentheses leftwards from the point at which it is
encountered.

   <p>It is also possible to refer to subsequently opened parentheses, by
writing references such as `<samp><span class="samp">(?+2)</span></samp>'. However, these cannot be
recursive because the reference is not inside the parentheses that are
referenced. They are always subroutine calls, as described in the next
section.

   <p>An alternative approach is to use named parentheses instead. The Perl
syntax for this is `<samp><span class="samp">(?&amp;name)</span></samp>'; PCRE's earlier syntax
`<samp><span class="samp">(?P&gt;name)</span></samp>' is also supported. We could rewrite the above example
as follows:

<pre class="verbatim">
         (?&lt;pn> \( ( (?>[^()]+) | (?&amp;pn) )* \) )
</pre>

<p class="noindent">If there is more than one subpattern with the same name, the earliest
one is used.

   <p>This particular example pattern that we have been looking at contains
nested unlimited repeats, and so the use of atomic grouping for
matching strings of non-parentheses is important when applying the
pattern to strings that do not match. For example, when this pattern
is applied to

<pre class="verbatim">
         (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()
</pre>

<p class="noindent">it fails quickly. However, if atomic grouping is not used, the match
runs for a very long time indeed because there are so many different
ways the `<samp><span class="samp">+</span></samp>' and `<samp><span class="samp">*</span></samp>' repeats can carve up the subject, and
all have to be tested before failure can be reported.

   <p>At the end of a match, the values set for any capturing subpatterns
are those from the outermost level of the recursion at which the
subpattern value is set.  If the pattern above is matched against

<pre class="verbatim">
         (ab(cd)ef)
</pre>

<p class="noindent">the value for the capturing parentheses is `<samp><span class="samp">ef</span></samp>', which is the
last value taken on at the top level. If additional parentheses are
added, giving

<pre class="verbatim">
         \( ( ( (?>[^()]+) | (?R) )* ) \)
            ^                        ^
@end example

@noindent
the string they capture is @samp{ab(cd)ef}, the contents of the top
level parentheses.

Do not confuse the @samp{(?R)} item with the condition @samp{(?(R)},
which tests for recursion.  Consider this pattern, which matches text
in angle brackets, allowing for arbitrary nesting. Only digits are
allowed in nested brackets (that is, when recursing), whereas any
characters are permitted at the outer level.

@verbatim
         &lt; (?: (?(R) \d++  | [^&lt;>]*+) | (?R)) * >
</pre>

<p class="noindent">In this pattern, `<samp><span class="samp">(?(R)</span></samp>' is the start of a conditional
subpattern, with two different alternatives for the recursive and
non-recursive cases. The `<samp><span class="samp">(?R)</span></samp>' item is the actual recursive
call.

<h5 class="subsubheading">Subpatterns as Subroutines</h5>

<p>If the syntax for a recursive subpattern reference (either by number
or by name) is used outside the parentheses to which it refers, it
operates like a subroutine in a programming language. The called
subpattern may be defined before or after the reference. A numbered
reference can be absolute or relative, as in these examples:

<pre class="verbatim">
         (...(absolute)...)...(?2)...
         (...(relative)...)...(?-1)...
         (...(?+1)...(relative)...
</pre>

   <p>An earlier example pointed out that the pattern

<pre class="verbatim">
         (sens|respons)e and \1ibility
</pre>

<p class="noindent">matches `<samp><span class="samp">sense and sensibility</span></samp>' and `<samp><span class="samp">response and
responsibility</span></samp>', but not `<samp><span class="samp">sense and responsibility</span></samp>'. If instead
the pattern

<pre class="verbatim">
         (sens|respons)e and (?1)ibility
</pre>

<p class="noindent">is used, it does match `<samp><span class="samp">sense and responsibility</span></samp>' as well as the
other two strings. Another example is given in the discussion of
DEFINE above.

   <p>Like recursive subpatterns, a subroutine call is always treated as an
atomic group. That is, once it has matched some of the subject string,
it is never re-entered, even if it contains untried alternatives and
there is a subsequent matching failure.

   <p>When a subpattern is used as a subroutine, processing options such as
case-independence are fixed when the subpattern is defined. They
cannot be changed for different calls. For example, consider this
pattern:

<pre class="verbatim">
         (abc)(?i:(?-1))
</pre>

   <p>It matches `<samp><span class="samp">abcabc</span></samp>'. It does not match `<samp><span class="samp">abcABC</span></samp>' because the
change of processing option does not affect the called subpattern.

<h5 class="subsubheading">Backtracking Control</h5>

<p>Perl 5.10 introduced a number of special <dfn>backtracking control
verbs</dfn>, which are described in the Perl documentation as
&ldquo;experimental and subject to change or removal in a future version of
Perl.&rdquo; It goes on to say: &ldquo;Their usage in production code should be
noted to avoid problems during upgrades.&rdquo; The same remarks apply to
the PCRE features described in this section.

   <p>The new verbs make use of what was previously invalid syntax: an
opening parenthesis followed by an asterisk. In Perl, they are
generally of the form `<samp><span class="samp">(*VERB:ARG)</span></samp>' but PCRE does not support the
use of arguments, so its general form is just `<samp><span class="samp">(*VERB)</span></samp>'. Any
number of these verbs may occur in a pattern. There are two kinds:

<h5 class="subsubheading">Verbs that act immediately</h5>

<p>The following verbs act as soon as they are encountered:

     <dl>
<dt><code>(*ACCEPT)</code><dd>
This verb causes the match to end successfully, skipping the remainder
of the pattern. When inside a recursion, only the innermost pattern is
ended immediately. PCRE differs from Perl in what happens if the
`<samp><span class="samp">(*ACCEPT)</span></samp>' is inside capturing parentheses. In Perl, the data so
far is captured: in PCRE no data is captured. For example:

     <pre class="verbatim">     
              A(A|B(*ACCEPT)|C)D
</pre>

     <p>This matches `<samp><span class="samp">AB</span></samp>', `<samp><span class="samp">AAD</span></samp>', or `<samp><span class="samp">ACD</span></samp>', but when it matches
`<samp><span class="samp">AB</span></samp>', no data is captured.

     <dt><code>(*FAIL) </code><span class="roman">or</span><code> (*F)</code><dd>
This verb causes the match to fail, forcing backtracking to occur. It
is equivalent to `<samp><span class="samp">(?!)</span></samp>' but easier to read.  It is not clear
whether there is any use for this without the ability to execute code
in the middle of the pattern (which Perl has but PCRE in Monotone does
not). 
</dl>

<h5 class="subsubheading">Verbs that act after backtracking</h5>

<p>The following verbs do nothing when they are encountered. Matching
continues with what follows, but if there is no subsequent match, a
failure is forced.  The verbs differ in exactly what kind of failure
occurs.

     <dl>
<dt><code>(*COMMIT)</code><dd>
This verb causes the whole match to fail outright if the rest of the
pattern does not match. Even if the pattern is unanchored, no further
attempts to find a match by advancing the start point take place. Once
<code>(*COMMIT)</code> has been passed, the regular expression engine is
committed to finding a match at the current starting point, or not at
all. For example:

     <pre class="verbatim">     
              a+(*COMMIT)b
</pre>

     <p>This matches `<samp><span class="samp">xxaab</span></samp>' but not `<samp><span class="samp">aacaab</span></samp>'. It can be thought of
as a kind of dynamic anchor, or &ldquo;I've started, so I must finish.&rdquo;

     <dt><code>(*PRUNE)</code><dd>
This verb causes the match to fail at the current position if the rest
of the pattern does not match. If the pattern is unanchored, the
normal &ldquo;bump-along&rdquo; advance to the next starting character then
happens. Backtracking can occur as usual to the left of
<code>(*PRUNE)</code>, or when matching to the right of <code>(*PRUNE)</code>, but
if there is no match to the right, backtracking cannot cross
<code>(*PRUNE)</code>.  In simple cases, the use of <code>(*PRUNE)</code> is just
an alternative to an atomic group or possessive quantifier, but there
are some uses of <code>(*PRUNE)</code> that cannot be expressed in any other
way.

     <dt><code>(*SKIP)</code><dd>
This verb is like <code>(*PRUNE)</code>, except that if the pattern is
unanchored, the "bumpalong" advance is not to the next character, but
to the position in the subject where <code>(*SKIP)</code> was
encountered. <code>(*SKIP)</code> signifies that whatever text was matched
leading up to it cannot be part of a successful match. Consider:

     <pre class="verbatim">     
              a+(*SKIP)b
</pre>

     <p>If the subject is `<samp><span class="samp">aaaac...</span></samp>', after the first match attempt fails
(starting at the first character in the string), the starting point
skips on to start the next attempt at `<samp><span class="samp">c</span></samp>'. Note that a possessive
quantifer does not have the same effect in this example; although it
would suppress backtracking during the first match attempt, the second
attempt would start at the second character instead of skipping on to
`<samp><span class="samp">c</span></samp>'.

     <dt><code>(*THEN)</code><dd>
This verb causes a skip to the next alternation if the rest of the
pattern does not match. That is, it cancels pending backtracking, but
only within the current alternation. Its name comes from the
observation that it can be used for a pattern-based if-then-else
block:

     <pre class="verbatim">     
              ( COND1 (*THEN) FOO 
              | COND2 (*THEN) BAR 
              | COND3 (*THEN) BAZ ) ...
</pre>

     <p>If the `<samp><span class="samp">COND1</span></samp>' pattern matches, `<samp><span class="samp">FOO</span></samp>' is tried (and possibly
further items after the end of the group if `<samp><span class="samp">FOO</span></samp>' succeeds); on
failure the matcher skips to the second alternative and tries
`<samp><span class="samp">COND2</span></samp>', without backtracking into COND1. If <code>(*THEN)</code> is used
outside of any alternation, it acts exactly like <code>(*PRUNE)</code>. 
</dl>

   </body></html>

