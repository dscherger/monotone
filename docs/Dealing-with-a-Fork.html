<html lang="en">
<head><link type="text/css" rel="stylesheet" href="texinfo.css" />
<title>Dealing with a Fork - monotone documentation</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="monotone documentation">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Tutorial.html#Tutorial" title="Tutorial">
<link rel="prev" href="Making-Changes.html#Making-Changes" title="Making Changes">
<link rel="next" href="Branching-and-Merging.html#Branching-and-Merging" title="Branching and Merging">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<a name="Dealing-with-a-Fork"></a>
<p>
Next:&nbsp;<a rel="next" accesskey="n" href="Branching-and-Merging.html#Branching-and-Merging">Branching and Merging</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Making-Changes.html#Making-Changes">Making Changes</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Tutorial.html#Tutorial">Tutorial</a>
<hr>
</div>

<h3 class="section">2.11 Dealing with a Fork</h3>

<p>Careful readers will note that, in the previous section, the JuiceBot
company's work was perfectly serialized:

     <ol type=1 start=1>
<li>Jim did some work
<li>Abe synced with Jim
<li>Abe did some work
<li>Abe synced with Jim
<li>Beth synced with Jim
<li>Beth did some work
<li>Beth synced with Jim
     </ol>

<p>The result of this ordering is that Jim's work entirely preceded
Abe's work, which entirely preceded Beth's work. Moreover, each
worker was fully informed of the &ldquo;up-stream&rdquo; worker's actions, and
produced purely derivative, &ldquo;down-stream&rdquo; work:

     <ol type=1 start=1>
<li>Jim made revision 493bd... 
<li>Abe changed revision 493bd... into revision 42eae... 
<li>Beth derived revision 42eae... into revision 85573...
     </ol>

<p>This is a simple, but sadly unrealistic, ordering of events. In real
companies or work groups, people often work in parallel,
<em>diverging</em> from commonly known revisions and <em>merging</em>
their work together, sometime after each unit of work is complete.

<p>Monotone supports this diverge/merge style of operation naturally; any
time two revisions diverge from a common parent revision, we say that
the revision graph has a <dfn>fork</dfn> in it. Forks can happen at any
time, and require no coordination between workers. In fact any
interleaving of the previous events would work equally well; with one
exception: if forks were produced, someone would eventually have to
run the <samp><span class="command">merge</span></samp> command, and possibly resolve any conflicts
in the fork.

<p>To illustrate this, we return to our workers Beth and Abe. Suppose Jim
sends out an email saying that the current polling juice dispensers
use too much CPU time, and must be rewritten to use the JuiceBot's
interrupt system. Beth wakes up first and begins working immediately,
basing her work off the revision 85573... which is currently in her
workspace:

<pre class="smallexample">$ vi src/banana.c
<i>&lt;Beth changes her banana-juice dispenser to use interrupts&gt;</i>
</pre>
<p>Beth finishes and examines her changes:

<pre class="smallexample">$ mtn diff
#
# old_revision [85573a54105cd3220db10aa6a0713643cdf5ce6f]
#
# patch "src/banana.c"
#  from [d7e28a01cf6fc0f9ac04c6901dcafd77c2d32fb8]
#    to [dd979c3c880e6a7221fcecd7148bd4afcfb3e964]
#
============================================================
--- src/banana.c	d7e28a01cf6fc0f9ac04c6901dcafd77c2d32fb8
+++ src/banana.c	dd979c3c880e6a7221fcecd7148bd4afcfb3e964
@ -1,10 +1,15 @
 #include "jb.h"

+static void
+shut_off_banana()
+{
+  spoutctl(BANANA_SPOUT, SET_INTR, 0);
+  spoutctl(BANANA_SPOUT, FLOW_JUICE, 0);
+}
+
 void
 dispense_banana_juice()
 {
+  spoutctl(BANANA_SPOUT, SET_INTR, &amp;shut_off_banana);
   spoutctl(BANANA_SPOUT, FLOW_JUICE, 1);
-  while (spoutctl(BANANA_SPOUT, POLL_JUICE, 1) == 0)
-    usleep (1000);
-  spoutctl(BANANA_SPOUT, FLOW_JUICE, 0);
 }
</pre>
<p>She commits her work:

<pre class="smallexample">$ mtn commit --message="interrupt implementation of src/banana.c"
mtn: beginning commit on branch 'jp.co.juicebot.jb7'
mtn: committed revision 90abe0f1bc354a73d42d3bff1b02946559682bd9
</pre>
<p>And she syncs with Jim:

<pre class="smallexample">$ mtn sync
</pre>
<p>Unfortunately, before Beth managed to sync with Jim, Abe had woken up
and implemented a similar interrupt-based apple juice dispenser, but
his workspace is 42eae..., which is still &ldquo;upstream&rdquo; of Beth's.

<pre class="smallexample">$ vi apple.c
<i>&lt;Abe changes his apple-juice dispenser to use interrupts&gt;</i>
</pre>
<p>Thus when Abe commits, he unknowingly creates a fork:

<pre class="smallexample">$ mtn commit --message="interrupt implementation of src/apple.c"
</pre>
<p>Abe does not see the fork yet; Abe has not actually seen <em>any</em> of
Beth's work yet, because he has not synchronized with Jim. Since
he has new work to contribute, however, he now syncs:

<pre class="smallexample">$ mtn sync
</pre>
<p>Now Jim and Abe will be aware of the fork. Jim sees it when he sits
down at his desk and asks monotone for the current set of heads of
the branch:

<pre class="smallexample">$ mtn heads
mtn: branch 'jp.co.juicebot.jb7' is currently unmerged:
90abe0f1bc354a73d42d3bff1b02946559682bd9 abe@juicebot.co.jp 2004-10-26T02:53:16
951da88860a4cf7419d66ed9094d8bf24df5fb8b beth@juicebot.co.jp 2004-10-26T02:53:15
</pre>
<p>Clearly there are two heads to the branch: it contains an un-merged
fork. Beth will not yet know about the fork, but in this case it
doesn't matter: anyone can merge the fork, and since there are no
conflicts Jim does so himself:

<pre class="smallexample">$ mtn merge
mtn: 2 heads on branch 'jp.co.juicebot.jb7'
mtn: merge 1 / 1:
mtn: calculating best pair of heads to merge next
mtn: [left]  90abe0f1bc354a73d42d3bff1b02946559682bd9
mtn: [right] 951da88860a4cf7419d66ed9094d8bf24df5fb8b
mtn: [merged] 3aca69c7749bde9bd07fe4c92bb868bd69b2e421
mtn: note: your workspaces have not been updated
</pre>
<p>The output of this command shows Jim that two heads were found,
combined via a 3-way merge with their ancestor, and saved to a new
revision. This happened automatically, because the changes between the
common ancestor and heads did not conflict. If there had been a
conflict, monotone would have invoked an external merging tool to help
resolve it, or Jim could have used the <samp><span class="command">conflicts</span></samp> set of
commands to resolve it (see <a href="Conflicts.html#Conflicts">Conflicts</a>).

<p>After merging, the branch has a single head again, and Jim updates
his workspace.

<pre class="smallexample">$ mtn update
mtn: updating along branch 'jp.co.juicebot.jb7'
mtn: selected update target 3aca69c7749bde9bd07fe4c92bb868bd69b2e421
mtn: [left]  d60c18ec5e0cf1163b276f0bfdd908c1dfd53b4a
mtn: [right] 3aca69c7749bde9bd07fe4c92bb868bd69b2e421
mtn: updating src/apple.c
mtn: updating src/banana.c
mtn: updated to base revision 3aca69c7749bde9bd07fe4c92bb868bd69b2e421
</pre>
<p>The update command selected an update target &mdash; in this case the newly merged
head &mdash; and performed an in-memory merge between Jim's workspace
and the chosen target. The result was then written to Jim's workspace. If
Jim's workspace had any uncommitted changes in it, they would have been
merged with the update in exactly the same manner as the merge of multiple
committed heads.

<p>Monotone makes very little distinction between a &ldquo;pre-commit&rdquo; merge
(an update) and a &ldquo;post-commit&rdquo; merge. Both sorts of merge use the
exact same algorithm. The major difference concerns the recoverability
of the pre-merge state: if you commit your work first, and merge after
committing, then even if the merge somehow fails (due to difficulty in a
manual merge step, for instance), your committed state is still safe. 
If you update, on the other hand, you are requesting that monotone
directly modify your workspace, and while monotone will try hard not
to break anything, this process is inherently more open to error.  It is
therefore recommended that you commit your work <em>first</em>, before
merging.

<p>If you have previously used another version control system, this may at
first seem surprising; there are some systems where you are
<em>required</em> to update, and risk the above problems, before you can
commit.  Monotone, however, was designed with this problem in mind, and
thus <em>always</em> allows you to commit before merging.  A good rule of
thumb is to only use <samp><span class="command">update</span></samp> in workspaces with no local
modifications, or when you actually want to work against a different
base revision (perhaps because finishing your change turns out to
require some fixes made in another revision, or because you discover
that you have accidentally started working against a revision that
contains unrelated bugs, and need to back out to a working revision for
testing).

</body></html>

