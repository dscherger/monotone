<html lang="en">
<head><link type="text/css" rel="stylesheet" href="texinfo.css" />
<title>Database - monotone documentation</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="monotone documentation">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Command-Reference.html#Command-Reference" title="Command Reference">
<link rel="prev" href="Packet-I_002fO.html#Packet-I_002fO" title="Packet I/O">
<link rel="next" href="Automation.html#Automation" title="Automation">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Database"></a>
Next:&nbsp;<a rel="next" accesskey="n" href="Automation.html#Automation">Automation</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="Packet-I_002fO.html#Packet-I_002fO">Packet I/O</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Command-Reference.html#Command-Reference">Command Reference</a>
<hr>
</div>

<h3 class="section">5.8 Database</h3>

     <dl>
<dt><samp><span class="command">mtn set </span><var>domain</var> <var>name</var> <var>value</var></samp><a name="index-mtn-set-_0040var_007bdomain_007d-_0040var_007bname_007d-_0040var_007bvalue_007d-124"></a><dd>
Associates the value <var>value</var> to <var>name</var> in domain <var>domain</var>. 
See <a href="Vars.html#Vars">Vars</a> for more information.

     <br><dt><samp><span class="command">mtn unset </span><var>domain</var> <var>name</var></samp><a name="index-mtn-unset-_0040var_007bdomain_007d-_0040var_007bname_007d-125"></a><dd>
Deletes any value associated with <var>name</var> in <var>domain</var>.  See
<a href="Vars.html#Vars">Vars</a> for more information.

     <br><dt><samp><span class="command">mtn db init --db=</span><var>dbfile</var></samp><a name="index-mtn-db-init-_002d_002ddb_003d_0040var_007bdbfile_007d-126"></a><dd>
This command initializes a new monotone database at <var>dbfile</var>.

     <br><dt><samp><span class="command">mtn db info --db=</span><var>dbfile</var></samp><a name="index-mtn-db-info-_002d_002ddb_003d_0040var_007bdbfile_007d-127"></a><dd>
This command prints information about the monotone database <var>dbfile</var>,
including its schema version and various table size statistics.

     <br><dt><samp><span class="command">mtn db version --db=</span><var>dbfile</var></samp><a name="index-mtn-db-version-_002d_002ddb_003d_0040var_007bdbfile_007d-128"></a><dd>
This command prints out just the schema version of the monotone
database <var>dbfile</var>.

     <br><dt><samp><span class="command">mtn db dump --db=</span><var>dbfile</var></samp><a name="index-mtn-db-dump-_002d_002ddb_003d_0040var_007bdbfile_007d-129"></a><dd>
This command dumps an SQL statement representing the entire state of
<var>dbfile</var> to the standard output stream. It is a very low-level
command, and produces the most &ldquo;recoverable&rdquo; dumps of your database
possible. It is sometimes also useful when migrating databases between
variants of the underlying SQLite database format.

     <br><dt><samp><span class="command">mtn db load --db=</span><var>dbfile</var></samp><a name="index-mtn-db-load-_002d_002ddb_003d_0040var_007bdbfile_007d-130"></a><dd>
This command applies a raw SQL statement, read from the standard input
stream, to the database <var>dbfile</var>. It is most useful when loading
a database dumped with the <samp><span class="command">dump</span></samp> command.

     <p>Note that when reloading a dumped database, the schema of the dumped
database is <em>included</em> in the dump, so you should not try to
<samp><span class="command">init</span></samp> your database before a <samp><span class="command">load</span></samp>.

     <br><dt><samp><span class="command">mtn db migrate --db=</span><var>dbfile</var></samp><a name="index-mtn-db-migrate-_002d_002ddb_003d_0040var_007bdbfile_007d-131"></a><dd>
This command attempts to migrate the database <var>dbfile</var> to the
newest schema known by the version of monotone you are currently
running.  If the migration fails, no changes should be made to the
database.

     <p>If you have important information in your database, you should back up
a copy of it before migrating, in case there is an untrapped error
during migration.

     <br><dt><samp><span class="command">mtn db check --db=</span><var>dbfile</var></samp><a name="index-mtn-db-check-_002d_002ddb_003d_0040var_007bdbfile_007d-132"></a><dd>
Monotone always works hard to verify the data it creates and accesses. 
For instance, if you have hard drive problems that corrupt data in
monotone's database, and you attempt to retrieve this data, then
monotone will notice the problem and stop, instead of silently giving
you garbage data.

     <p>However, it's also nice to notice such problems early, and in rarely
used parts of history, while you still have backups.  That's what this
command is for.  It systematically checks the database <var>dbfile</var> to
ensure that it is complete and consistent. The following problems are
detected:

          <ul>
<li>missing files
that are referenced by their <span class="sc">sha1</span> hash from some manifest but do not
exist in the database.  This is a serious problem; it means that your
history is not fully reconstructible.  You can fix it by finding the
file with the given hash, and loading it into your database with
<samp><span class="command">fload</span></samp>.

          <li>unreferenced files
that exist in the database but are not referenced by their <span class="sc">sha1</span>
hash from any existing manifest.  In itself, this only indicates some
wasted space, and is not a problem; it's possible it could arise under
normal use (for instance, in some strange corner cases following an
incomplete netsync).  It could also arise, though, as a symptom of some
other more serious problem.

          <li>missing manifests
that are referenced by their <span class="sc">sha1</span> hash from some revision but do
not exist in the database.  This is a serious problem; it means that
your history is not fully reconstructible.  You can fix it by finding a
database containing the manifest, and using <samp><span class="command">mdata</span></samp> on that
database to create a manifest data packet, which can be loaded into your
database with <samp><span class="command">read</span></samp>.

          <li>unreferenced manifests
that exist in the database but are not referenced by their <span class="sc">sha1</span>
hash from any existing revision.  In itself, this only indicates some
wasted space, and is not a problem; it's possible it could arise under
normal use (for instance, if you have run <samp><span class="command">db kill_rev_locally</span></samp>,
or in some strange-but-harmless corner cases following an incomplete
netsync).  It could also arise, though, as a symptom of some other more
serious problem.

          <li>incomplete manifests
that exist in the database but contain references to files that do not
exist in the database.  For diagnosis and solution, see &ldquo;missing
files&rdquo; above.

          <li>missing revisions
that are referenced by their <span class="sc">sha1</span> hash from some other revision or
revision cert but do not exist in the database.  This may be a serious
problem; it may indicate that your history is not fully reconstructible
(if the reference is from another revision) or that someone is creating
bogus certs (if the reference is from a cert).  You can fix it by
finding a database containing the revision, and using <samp><span class="command">rdata</span></samp> on
that database to create a revision data packet, which can be loaded into
your database with <samp><span class="command">read</span></samp>.

          <li>incomplete revisions
that exist in the database but contain references to missing manifests,
incomplete manifests or missing revisions.  This always occurs with some
more detailed error; see above.

          <li>revisions with mismatched parents
that disagree with the cached revision ancestry on their parent
revisions.  This may cause problems in using the database, and suggests
the presence of a bug in monotone's caching system, but does not involve
data loss.

          <li>revisions with mismatched children
that disagree with the cached revision ancestry on their child
revisions.  This may cause problems in using the database, and suggests
the presence of a bug in monotone's caching system, but does not involve
data loss.

          <li>revisions with bad history
that exist in the database but fail monotone's normal sanity checks for
consistent and correct history.  This is a serious problem; it indicates
that your history record is somehow malformed.  This should not be
possible, since monotone carefully checks every revision before storing
it into the database, but if it does, then please request assistance on
the monotone mailing list.  Fixing this generally means you may lose
some history &mdash; for instance, renames may be degraded into delete/add
pairs &mdash; but the actual contents of every revision will still be
reproducible.

          <li>revisions with missing certs
that exist in the database lacking at least one author, branch,
changelog or date cert. All revisions are expected to have at least one
of each of these certs.  In itself, this is not necessarily a problem,
but it is peculiar, and some operations such as netsync may behave
strangely.

          <li>revisions with mismatched certs
that exist in the database with differing numbers of author, changelog
and date certs. These certs are expected to appear together, as each
revision committed should have an author, changelog and date associated
with it.  In itself, this is not a problem, but it is peculiar.  All
operations should behave normally.

          <li>missing keys
that have been used to sign certs but do not exist in the database.  In
itself, this is not a problem, except that monotone will ignore any
certs signed by the missing key.  You can fix it by finding a database
containing the key in question, and using <samp><span class="command">pubkey</span></samp> on that
database to create a public key packet, which can be loaded into your
database with <samp><span class="command">read</span></samp>.

          <li>certs with bad signatures
that exist in the database with signatures that are invalid.  In itself,
this is not a problem, except that monotone will ignore any such certs. 
You may also wish to find out who is creating certs with bad
signatures; it may indicate some kind of security attack.

          <li>certs with unchecked signatures
that exist in the database but cannot have their signatures checked
because the signing key is missing.  In itself, this is not a problem,
except that monotone will ignore any certs signed by the missing key. 
You can fix it by finding a database containing the key in question, and
using <samp><span class="command">pubkey</span></samp> on that database to create a public key packet,
which can be loaded into your database with <samp><span class="command">read</span></samp>.

     </ul>

     <p>This command also verifies that the <span class="sc">sha1</span> hash of every file, manifest,
and revision is correct.

     <br><dt><samp><span class="command">mtn db kill_rev_locally </span><var>id</var></samp><a name="index-mtn-db-kill_005frev_005flocally-_0040var_007bid_007d-133"></a><dd>
This command &ldquo;kills&rdquo;, i.e., deletes, a given revision, as well as any
certs attached to it.  It has an ugly name because it is a dangerous
command; it permanently and irrevocably deletes historical information
from your database.  There are a number of caveats:
          <ul>
<li>It can only be applied to revisions that have no descendants.  If you
want to kill a revision that has descendants, you must kill all of the
descendants first. 
<li>It only removes the revision from your local database (hence the
&ldquo;locally&rdquo; in the command name).  If you have already pushed this
revision out to another database, then the next time you pull from that
database it may come back again.  There is no way to delete a revision
from somebody else's database except to ask them to delete it for you. 
<li>It does not actually delete the revision's files or manifest from your
database.  If you run this command, and then run <samp><span class="command">db check</span></samp>, it
will note that you have an &ldquo;unreferenced manifest&rdquo;.  If you wish to
eliminate this data for good (and thus free up the space), you may use
netsync to <samp><span class="command">pull</span></samp> from your current database into a new
database; this creates a copy of your old database, without the
unreferenced data.  However, having this data in your database will not
cause any problems, and acts as a safety net; if you later realize that
you do, after all, need to retrieve the data in <var>id</var>, then
<samp><span class="command">db check</span></samp> will let you see which manifest it was, and with some
work you can extract <var>id</var>'s data. 
</ul>

     <br><dt><samp><span class="command">mtn db kill_branch_certs_locally </span><var>branch</var></samp><a name="index-mtn-db-kill_005fbranch_005fcerts_005flocally-_0040var_007bbranch_007d-134"></a><dd>
This command &ldquo;kills&rdquo; a branch by deleting all branch certs with that
branch name. You should consider carefully whether you want to use it,
because it can irrevocably delete important information. It does not
modify or delete any revisions or any of the other certificates on
revisions in the branch; it simply removes the branch certificates
matching the given branch name. Because of this, it can leave
revisions without any branch certificate at all. As with <samp><span class="command">db
kill_rev_locally</span></samp>, it only deletes the information from your local
database; if there are other databases that you sync with which have
revisions in this branch, the branch certificates will reappear when
you sync, unless the owners of those databases also delete those
certificates locally.

     <br><dt><samp><span class="command">mtn db kill_tag_locally </span><var>tag</var></samp><a name="index-mtn-db-kill_005ftag_005flocally-_0040var_007btag_007d-135"></a><dd>
This command &ldquo;kills&rdquo; a tag by deleting all tag certs with that tag
name. You should consider carefully whether you want to use it, because
it can irrevocably delete important information. It does not modify or
delete any revisions, or any of the other certificates on tagged
revisions; it simply removes all tag certificates with the given name. 
As with <samp><span class="command">db kill_rev_locally</span></samp>, it only deletes the information
from your local database; if there are other databases that you sync
with which have this tag, the tag certificates will reappear when you
sync, unless the owners of those databases also delete those
certificates locally.

     <br><dt><samp><span class="command">mtn db execute </span><var>sql-statement</var></samp><a name="index-mtn-db-execute-_0040var_007bsql_002dstatement_007d-136"></a><dd>
This is a debugging command which executes <var>sql-statement</var> against
your database, and prints any results of the expression in a tabular
form.  It can be used to investigate the state of your database, or
help diagnose failures.

</dl>

   </body></html>

