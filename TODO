* clean up rollback
   - right now, design is that rollback is tied to the transport that
   may get interrupted.  this is all wrong; it should be generic for
   all transports.  possibly it should be moved into merkle_dir
   itself, i.e., change the WriteableFS layer to provide something
   like non-clobbering "rename".  Places that are confused:
     - incomplete comment at top of merkle_dir.py
     - unused method rollback_name in WriteableFS
     - SFTP's put and rollback code
     - local transport's non-existent rollback code
* finish README
* should readers do the pause/retry dance?  (makes them very slow when
   files simply don't exist, which is common, to only protect against
   a very small race condition... hrm.)
* ftp write
   - size() requires parsing ls output (ftp SIZE command gives wrong
   data).  "ftputil" package may be useful here.  (DJB also has a db
   of possible LIST outputs, but can't use directly because of DJB
   copyright weirdness)
   - probably refactor SFTP file write, so both methods dealing with
   non-atomic rename can share code.
* make sftp support nicer (support agents, keys, etc. -- see demo.py
   in the real paramiko distribution)
* better automate-ish way to deal with keys and certs (perhaps certs
   should get their own top-level ids, they already have hashes in the
   db... then we could have commands to list certs, dump info on a
   given cert, get a packet for a given cert, etc.)
* merkle dir stuff that doesn't require loading entire chunks into
   memory all the time, partialy done (revision data, keys), left: certs
* pipelining on http read? (is urlgrabber thread-safe?)
* possibly better rollback stuff?
  - truncate DATA when possible? (local, sftp (with a simple call
   to a private method)
  - include some info in the lockdir on who has things locked, to aid
   in detecting staleness of locks
* HTTP write support using a server-side CGI (CGI, PHP, whatever
   people want support for

* automate merkle_hash <include-pattern> <exclude-pattern> <tree name> <prefix>
   could do many of the same tricks as this code, but eliminate the
   unsightly local fs repo, and make it easier for remote sides to use
   unusual representations (e.g., viewmtn could bake support in,
   backed against its real monotone db)... (more speculative)

* pseudocode for idea of storage independent (safe?) transaction:

   t.begin()
	-- begin trans
        storage.mkdir("_lock")
   t.touchfile(a):
	-- tell transaction that we replace this file
        log.append("rollback_content " + a)
        log_command.append("mv %s _lock", a)
   t.appendfile(a):
	-- tell transaction that we will append to this file
        log.append("truncate_at + storage.filesize(a))

   t.record(): 
	-- record what will be done in this transaction
        for cmd in log_command: storage.exec(a, "_lock")
        storage.put("_lock/log", log)

   t.commit()
       drop evertyhng from _lock/*
       drop _lock
   t.rollback()
       execute_rollback(get("_lock/%s" % log))
       drop evertyhng from _lock/*
       drop _lock

use case will be:

   put 100 files & append to 'appendable':

try:
  for a in files:
      t.touchfile(a)
  t.appendfile(appendable)
  t.record()

  doDangerousAndLenghtyThings(storage,files, appendable)

  t.commit()
finally:
  t.rollback()


-----------------------------------------

idea for MDS (Monotone Dumb Storage)

cert   ::= id, packet
fdelta ::= p(id,id), packet
fdata  ::=  id, packet
revision ::= id, packet
merkle_trie(p)::= merkle_trie(with key -> p.first, data -> p.second)
deltas ::= merkle_trie(fdelta)
files ::= mmrkle_trie(file)
revisions ::= merkle_trie(revisions)
certs ::= merkle_trie(cert)

push:
   R = calc_ineteresting_revisions(local)   # default yields all revisions
   diff = difference(R, dest.revisions)
   P = diff.added
   items = []
   for rev in pushed_revisions:
      ritems = local.revisions.get_items(rev)
      for ri ritems:
         if ri is fdata  and ri not in dest.files: items << ri
         if ri is fdelta and ri not in dest.fdelta: itema << ri
      items << rev.position
      CERTS
      
   