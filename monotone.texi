\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename monotone.info
@settitle monotone documentation
@setchapternewpage odd
@c %**end of header

@syncodeindex fn cp
@include version.texi

@ifinfo
This manual is for the ``monotone'' distributed version control system.
This edition documents version @value{VERSION}.

Copyright 2003 Graydon Hoare
All rights reserved
Licensed to the public under the terms of the GNU FDL (>= 1.1).
See the file COPYING for details
@end ifinfo

@dircategory Programming
@direntry
* monotone: (monotone).         Monotone version control system
@end direntry

@titlepage
@title Monotone
@subtitle A distributed version control system
@author Graydon Hoare

@page
@vskip 0pt plus 1filll
Copyright @copyright{} 2003 Graydon Hoare
All rights reserved
Licensed to the public under the terms of the GNU FDL (>= 1.1).
See the file COPYING for details
@end titlepage

@ifnottex
@node Top
@top Top

Monotone Documentation

Monotone is a distributed version control tool. It can help automate
many tedious and error-prone tasks in group software development.
@itemize
@item
Store multiple versions of files you are working on efficiently.
@item
Transmit changes to files between you and your colleagues.
@item
Merge changes you make with those your colleagues make.
@item
Make notes about your opinion of the quality of versions of files.
@item
Make decisions about using or ignoring versions, depending on the notes
you receive from others.
@end itemize

Please be aware that monotone is a slightly unorthodox version control
tool, and many of its concepts are slightly similar --- but
significantly different --- from concepts with similar names in other
version control tools.

@end ifnottex

@menu
* Concepts::            Taxonomy of monotone
* Getting Started::     Simple use of monotone
* Special Topics::      Extra explanations and details
* CVS Phrasebook::      Transitional guide for CVS users
* Command Reference::   Details of each monotone command
* Hook Reference::      Functions which extend monotone
* Man Page::            That other document
* Index::               Index of concepts and functions
@end menu


Complete table of contents

@contents

@node    Concepts
@chapter Concepts

This chapter should familiarize you with the concepts, terminology,
and behavior described in the remainder of the user manual. Please
take a moment to read it, as later sections will assume familiarity
with these terms.

@menu
* Versions of files::         Tracking changes to single files
* Versions of trees::         Tracking changes to collections of files
* Certificates::              Tracking extended information
* Storage and workflow::      Saving, sending, and receiving changes
* Packets::                   How databases and network servers relate
* Ancestry::                  Relating versions to each other
* Forks and merges::          Managing divergence of code
* Branches::                  Intentional divergence and automatic merging
@end menu

@node    Versions of files
@section Versions of files

Suppose you wish to modify a file @file{file.txt} on your
computer. You begin with one @i{version} of the file, load it into
an editor, make some changes, and save the file again. Doing so
produces a new @i{version} of the file. We will say that the older
version of the file was a @dfn{parent}, and the new version is a
@dfn{child}, and that you have performed an @dfn{edit} between the
parent and the child. We may draw the relationship between parent and
child using a graph, where the arrow in the graph indicates the
direction of the edit, from parent to child.

@example
     +----------------+
     |                |
     | parent version |
     | of file.txt    |
     |                |
     +----------------+
              |
              |
             \|/
              V
     +----------------+
     |                |
     | child version  |
     | of file.txt    |
     |                |
     +----------------+
@end example

We may want to identify the parent and the child precisely, for sake
of reference. To do so, we will compute a @i{cryptographic hash
function}, called @sc{sha1}, of each version. The details of this
function are beyond the scope of this document; in summary, the @sc{sha1}
function takes a version of a file and produces a short string of 20
bytes, which we will use to uniquely identify the version@footnote{we
say @sc{sha1} values are ``unique'' here, when in fact there is a
small probability of two different versions having the same @sc{sha1}
value. this probability is very small, so we discount it.}.  Now our
graph does not refer to some ``abstract'' parent and child, but rather
to the exact edit we performed between a specific parent and a
specific child.

@example
     +---------------------------------------------------+
     | parent version                                    |
     | of file.txt                                       |
     |                                                   |
     | SHA1 = 65f1bde1f38262034e7c3457301e8f736ba6381b   |
     +---------------------------------------------------+
              |
              |
             \|/
              V
     +---------------------------------------------------+
     | child version                                     |
     | of file.txt                                       |
     |                                                   |
     | SHA1 = a91566316d208dc405795904f8d67ae3a0e765cb   |
     +---------------------------------------------------+
@end example

When dealing with versions of files, we will dispense with writing out
``file names'', and identify versions @i{purely} by their @sc{sha1}
value, which we will also refer to as their @dfn{version code}. Using
version codes alone will often help us accommodate the fact that people
often wish to call files by different names. So now our graph of
parent and child is just a relationship between two versions, only
identified by version code.

@example
     +---------------------------------------------------+
     | parent version                                    |
     | SHA1 = 65f1bde1f38262034e7c3457301e8f736ba6381b   |
     +---------------------------------------------------+
              |
              |
             \|/
              V
     +---------------------------------------------------+
     | child version                                     |
     | SHA1 = a91566316d208dc405795904f8d67ae3a0e765cb   |
     +---------------------------------------------------+
@end example

Version control systems, such as monotone, are principally concerned
with the storage and management of @i{multiple} versions of some
files.  One way to store multiple versions of a file is, literally, to
save a separate @i{complete} copy of the file, every time you make a
change. When necessary, monotone will save complete copies of your
files in their, compressed with the @command{zlib} compression format.

@example
   +--------------+  +--------------+  +--------------+
   |              |  |              |  |              |
   | Hello        |  | Hello,       |  | Why, Hello   |
   |              |  | world!       |  | there world, |    . . .
   |              |  |              |  | how do you   |
   |              |  |              |  | do?          |
   |              |  |              |  |              |
   +--------------+  +--------------+  +--------------+

   \______  ______/  \______  ______/  \______  ______/
          \/                \/                \/
      1st version       2nd version      3rd version
@end example

Often we find that successive versions of a file are very similar to
one another, so storing multiple complete copies is a waste of
space. In these cases, rather than store @i{complete} copies of each
version of a file, we store a compact description of only the
@i{changes} which are made between versions. Such a description of
changes is called a @dfn{delta}. 

Storing deltas between files is, practically speaking, as good as
storing complete versions of files. It lets you undo changes from a
new version, by applying the delta backwards, and lets your friends
change their old version of the file into the new version, by applying
the delta forwards. Deltas are usually smaller than full files, so
when possible monotone stores deltas, using the @command{rdiff}
format. The details of this format are beyond the scope of this
document.

@example
                        difference
                     between versions
                       _____/\____
   +--------------+   /           \    +--------------+
   |              |                    |              |
   | Hello        |    +[, world!]     | Hello,       |
   |              |                    | world!       |
   |              |                    |              |
   |              |                    |              |
   |              |                    |              |
   +--------------+                    +--------------+

   \______  ______/                    \______  ______/
          \/                                  \/
     1st version                         2nd version
@end example

@node    Versions of trees
@section Versions of trees

After you have made many different files, you may wish to capture a
``snapshot'' of the versions of all the files in a particular collection.
Since files are typically collected into @i{trees} in a file system,
we say that you want to capture a @i{version of your tree}. Doing
so will permit you to undo changes to multiple files at once, or send
your friend a @i{set} of changes to many files at once.

@c figure of snapshotting a tree

To make a snapshot of a tree, we begin by writing a special file
called a @dfn{manifest}. In fact, monotone will write this file for
us, but we could write it ourselves too. It is just a plain text
file. Each line of a manifest file contains two columns. In the first
column we write the version code of a file in your tree, and in the
second column we write the path to the file, from the root of our tree
to the filename.

@example
+--------------------------------------------------------------+
|                                                              |
|  f2e5719b975e319c2371c98ed2c7231313fac9b5  fs/readdir.c      |
|  81f0c9a0df254bc8d51bb785713a9f6d0b020b22  fs/read_write.c   |
|  943851e7da46014cb07473b90d55dd5145f24de0  fs/pipe.c         |
|  ddc2686e000e97f670180c60a3066989e56a11a3  fs/open.c         |
|  295d276e6c9ce64846d309a8e39507bcb0a14248  fs/namespace.c    |
|  71e0274f16cd68bdf9a2bf5743b86fcc1e597cdc  fs/namei.c        |
|  1112c0f8054cebc9978aa77384e3e45c0f3b6472  fs/iobuf.c        |
|  8ddcfcc568f33db6205316d072825d2e5c123275  fs/inode.c        |
|                                                              |
+--------------------------------------------------------------+

\_____________________________  _______________________________/
                              \/
                          an example
                         manifest file
@end example

Now we note that a manifest is itself a file. Therefore a manifest can
serve as input to the @sc{sha1} function, and thus every manifest has
a version code of its own. By calculating the @sc{sha1} value of a
manifest, we capture the @i{state of our tree} in a single version
code. In other words, the version code of the manifest essentially
captures all the version codes and file names of every file in our
tree, combined. So we may treat manifests and their version codes as
@i{snapshots} of a tree of files, though lacking the actual contents
of the files themselves.

@example
  +--------------------------+
  |   int readdir(...) @{     |
  |     ...                  |
  |   @}                      |
  +--------------------------+

  \____________  ___________/
               \/
              SHA1
               ||
+--------------||----------------------------------------------+
|              \/                                              |
|  f2e5719b975e319c2371c98ed2c7231313fac9b5  fs/readdir.c      |
|  81f0c9a0df254bc8d51bb785713a9f6d0b020b22  fs/read_write.c   |
|  943851e7da46014cb07473b90d55dd5145f24de0  fs/pipe.c         |
|                   . . .                       . . .          |
+--------------------------------------------------------------+

\_____________________________  _______________________________/
                              \/
                             SHA1
                              ||
                              ||
                              \/
                       manifest version:
           a2eeaa28574141a7d48fa1cc2802070150b93ec4
@end example

As with versions of files, we may decide to store manifests in their
entirety, or else we may store only a compact description of changes
which occur between different versions of manifests. As with files,
when possible monotone stores compact descriptions of changes between
manifests; when necessary it stores complete versions of manifests.


@node    Certificates
@section Certificates

Often, you will wish to make a @i{statement} about a version of a file
or manifest, such as stating the reason that you made some changes, or
stating the fact that you approve of the changes which were made, or
stating the time at which you made the changes. Statements such as
these can be thought of, generally, as a bundle of information with
three parts:

@itemize
@item
a @i{version code}, indicating which file or manifest you are
making a statement about
@item
a @i{name} indicating the type of statement you are making, such as
``changelog'', ``date'' or ``disapproval''
@item
a @i{value} indicating the remaining detail of the statement, such as
``fixed a bug'', ``March 9th'' or ``approved for shipping''
@end itemize


For example, if you want to say that a particular version of a
manifest was written on April 4, 2003, you might make a statement like
this:

@example
      +------------------------------------------------------+
      |  version code                                        |
      |  a2eeaa28574141a7d48fa1cc2802070150b93ec4            |
      +--------------------------+---------------------------+
      |  statement name          |  statement value          |
      |  "date"                  |  "2003-04-04T07:39:51"    |
      +--------------------------+---------------------------+
@end example

In an ideal world, these are all the parts of a statement we would
need in order to go about our work. In the real world, however, there
are sometimes malicious people who would make false or misleading
statements; so we need a way to verify that a particular person made a
particular statement about a version. We therefore will add two more
pieces of information to our bundle:

@itemize
@item
a @i{key} which identifies the person making a statement
@item
a @i{signature} --- just a large number with particular properties ---
certifying the fact that the person made the statement
@end itemize

When these 2 items accompany a statement, we call the total bundle of
5 items a @dfn{certificate}, or @i{cert}. A cert makes a statement in
a secure fashion. The security of the signature in a cert is derived
from the @sc{rsa} cryptography system, the details of which are beyond
the scope of this document.

@example
      +------------------------------------------------------+
      |  version code                                        |
      |  a2eeaa28574141a7d48fa1cc2802070150b93ec4            |
      +--------------------------+---------------------------+
      |  cert name               |  cert value               |
      |  "date"                  |  "2003-04-04T07:39:51"    |
      +--------------------------+---------------------------+
      |  signed by key           |  signature                |
      |  "jrh@@somewhere.com"     |  "a02380def....0983fe90"  |
      +--------------------------+---------------------------+
@end example

Monotone uses certs extensively. Any extra information which needs to
be stored, transmitted or retrieved --- above and beyond versions of
files and manifests --- is kept in the form of certs. This includes
ancestry information, change logs, time and date records, and
more. When monotone makes a decision about storing, transmitting, or
recovering some files or manifests, the decision is based on certs it
has seen, and the trustworthiness you assign to those certs.

The @sc{rsa} cryptography system --- and therefore monotone itself ---
requires that you exchange special ``public'' numbers with your
friends, before they will trust certificates signed by you. These
numbers are called @dfn{public keys}. Giving someone your public key
does not give them the power to @i{impersonate} you, only to verify
signatures made by you. Exchanging public keys should be done over a
trusted medium, in person, or via a trusted third party. Advanced
secure key exchange techniques are beyond the scope of this document.


@node    Storage and workflow
@section Storage and workflow

Monotone moves information in and out of three different
types of storage:

@itemize
@item
a @i{working copy} in the local file system
@item
a @i{database} in the local file system
@item
a @i{web, mail or news server} on the network
@end itemize

All information passes @emph{through} a database, en route to some
other destination. For example, when changes are made in a working
copy, you may save those changes to a database, and later you may send
those changes from a database to a web, mail or news server. Monotone
will not move information directly between a working copy and a
network server.

@example
                 post, fetch
       (untrusted network exchanges)
            _________/\________
           /                   \

    +-------------+      +------------+      +--------------+
    |             |      |            |      |              |
    |  net server | <==> |  database  | <==> | working copy |
    |             |      |            |      |              |
    +-------------+      +------------+      +--------------+

                                \________  _______/
                                         \/
                                  commit, update
                            (certified local exchanges)
@end example

A @dfn{working copy} is a tree of files in your file system, arranged
according to the paths and version codes in a particular manifest.
A special directory called @file{MT} exists in the root of any
working copy. Monotone keeps some special files in the @file{MT}
directory, in order to track changes you make to your working copy.

Aside from the special @file{MT} directory, a working copy is just a
normal tree of files. You can directly edit the files in a working copy
using a plain text editor or other program; monotone will
automatically notice when you make any changes. If you wish to add
files, remove files, or move files within your working copy, you may
need to tell monotone explicitly what you are doing, as these actions
cannot always be deduced.

If you do not yet have a working copy, you can ``check out'' a working
copy from a database, or construct one from scratch and ``add'' it
into a database. As you work, you will occasionally ``commit'' changes
you have made in a working copy to a database, and ``update'' a
working copy to receive changes that have arrived in a
database. Committing and updating take place purely between a database
and a working copy; the network is not involved.

@example
   -----------------     check out,      working copy
  (                 )    or update      +----------------
   -----------------     ---------->    |
  |                 |                   |  src/func.c
  |      local      |   <----------     |  src/func.h
  |     database    |    add,           |  src/main.c
  |                 |    or commit      |  Makefile
  \_________________/                   |  MT/
                                        |
@end example

A @dfn{database} is a single, regular file. You can copy or back it up
using standard methods. Typically you keep a database in your home
directory. Databases are portable between different machine types. If
a database grows too big, you may choose to remove information from
it. You can have multiple databases and divide your work between them,
or keep everything in a single database if you prefer. You can dump
portions of your database out as text, and read them back into other
databases, or send them to your friends.

A database contains many versions and certificates, some of which are
not immediately of interest, some of which may be unwanted or even
false. It is a collection of information received from network servers,
working copies, and other databases. You can inspect and modify your
databases without affecting your working copies, and vice-versa.

Monotone knows how to exchange information in your database with
various sorts of @dfn{network servers}. It supports three common
networking protocols: HTTP, NNTP and SMTP. Monotone can communicate
natively with web, news and mail servers using these protocols. If you
have access to a web server which can run CGI programs, you can use
the HTTP transport easily with very little setup. See the tutorial
section for more details.

@example
                                        -----------------
  \\\             ///                  (                 )
   +---------------+       fetch        -----------------
   |               |    ----------->   |                 |
   |    network    |                   |      local      |
   |    server     |   <-----------    |     database    |
   |               |        post       |                 |
   +---------------+                   \_________________/
  ///             \\\
@end example

Communication with network servers is quite flexible, but the usual
work pattern has 4 distinct stages:

@itemize
@item
when you ``commit'' changes from your working copy to your database,
monotone also makes a note in the database to queue the changes for
transmission to a network server.
@item
when you ``post'' to a network server, monotone sends all changes queued
in your database to the network server.
@item
when you ``fetch'' from a network server, monotone copies any new changes
from the network server into your database.
@item
when you ``update'' your working copy, @i{some} of the changes which
have arrived in your database from a network server are applied to your
working copy.
@end itemize

The last stage is worth clarifying: monotone does @emph{not} blindly
apply all changes it receives from a network server to your working copy.
Doing so would be very dangerous, because network servers are not
trustworthy systems. Rather, monotone evaluates the certificates it
has received along with the changes, and decides which particular
changes are safe and desirable to apply to your working copy.

You can always adjust the criteria monotone uses to judge the
trustworthiness and desirability of changes in your database. But keep
in mind that it always uses @emph{some} criteria; receiving changes
from the network is a @emph{different} activity than applying changes
to a working copy. Sometimes you may receive changes which monotone
judges to be untrusted or bad; such changes may stay in your database
but will @emph{not} be applied to your working copy.

@node    Packets
@section Packets

When monotone sends information to network servers, it converts the
data stored in your database to a more convenient form, called
@dfn{packets}. Each packet is a sequence of lines of ASCII text,
beginning with a header (enclosed in square brackets) and ending with
the single line ``[end]''. The first word in the header of a packet
indicates the packet type. For example, a packet containing some
manifest data might look like this:

@example
[mdata 8d4d10a037ab2f814c96fbf88002473afbfb7b75]
H4sIAAAAAAAAAJVXzW6cOQ6891P0C6xDiRQlHQe7c9u5bB7AoCTS7on/4LaTzNtPfe72pD2Z
yyJAEBiuT2SxqshYY1qiTWklS5J6mz1rd7FsybPNNniptf3+l5eXw/w0Hx/icHN18+rH404K
fqWP1BPguU1R76nWYk3CB3ldhbN0+xv4+Dp23Kx6TTWP5VHaXKo5S54srWtqYqRUyMo79PBw
fLG7u38db3cqs+blXSvjL+1VCj6SnVoLzlFz9kZd/yr57uX0LspFWdFn9MQeQXXwKBWdKorv
kZe16bYugPd2eLjanlxtBmtEK75ygBeZSqzGNruZKJrcvvqOvD8cj4eHm53NqYMDvzu99Eyr
LnJNI3eppsJrjVY6/8B9Ofe5Ds+g12rToavHyjXatCGNeXW1bgKu0mpJg+d+/+9be7jx/z7e
7Nws6SyziMcQrw31ZjaMJ5U0nEZErlXpAnN1dxg38/fditwqAY3HjCtakkmMMUmVAVramKqs
GMlv9sXjcOdXdr8jsmUp8ay1upUVc5VIPWaPUC9CuS4eSy9Qh4cdKCvecvWxolRuq47GQqmS
4OWZiEZKeeGt//36y39++3W3hEYVKpkpddYmxbVGj7TMloOF4nWi+v0enJ9kdrtbiXxAI72v
YZOgsl7bCIy9WpFmmVmrt7aBDg/z7nX51b3soqypXKAmaKwS96ACeagHjNJngU9COPkGu3uc
dreBwFLhMntJlDLNPrv0DjbXZAIhtTcUBlXv96fyXp99F7l3mb2NAj2MkiHQPtrwRENDBzHE
IaXQBWYjT0tPc5ZeuaDrXkuaq2pXH0l7y/AA5ggz7fcRh3cyNmBOrWhJXDSJr57r1BIWJbdS
WspiXnnVCdbPbHy6nJlDrtR4yYDYUaC7w76K9DAMJ0lbEUlG/EDj+dPDoT16oUEzicnIlfpy
55oxhIA+4cWACNIH6PX94emIKYpTIFdaXzFQgPRSqlGvNmrrxaJyzgQX7vfH5/nJ7p5u7e3l
uavWGsiCDYKsYpiBPwXecVV0MOB3JALTJfLxGFefd8ZeHK/yYk0wAlyTkEcjGjTYa5dM1Vf0
M/L5/vwiXqslp+gjYxgLY1KwI6aptG6DpaBm+PoH7vjH8SsenOJjroHwaiSG322aVIZ0UieD
i5dhwqIn4PLxeoPn1mBFGEHFs3shyIlpjKqCf4Mih+yreIoTCiW++PEFuGYKtTE0DHLHdCU8
V5LhZ2hUSZntlIQb7oCoeu/PQpD5mzTzRH6nWHAd5S1VUSO8bkiJVC+Arw+H71uDyNwG4ihA
fSBDE6vEDLDDAodGloEMWCfk7/bVrp/t27U9bc9CHGTIIOQwOiQ0iKmkyiigtkW1O0NUI53A
99q+nOtFrSQdkbKx4Ap7dicnWbA9NW9YeGh/+BkIwX06JfED56vjbkZ1Vk6ClWNdI6PT2VIM
Q5RqQOwqGPL4Cf74Bs+jwXDZqw6BZxdMN3XSKM3huc6Y2ehul/BT2YSoCStRuCfMAepfhikN
RD62KiBpJW1+WfZW8OddziitTJ7Zc0Lep16wWIWxZLrygDYE6SZyAXx8AxIqy8hpbOzO2ZUt
TOuWZ9bwPrsI1PuupKfHb/78BAG/jZYdC7su0KqTuVNBhgl2ExHoX3OmzOgz80/Ya8TncQu1
z7vCpooUc6yuUdwgzNaxHkDc21KP1hZ+nD5+Y9nzN2zoz9uiFYfeCdugwUlhKfJG+sYignvi
SllQ2T/BL6roM9uqDOdx2+Ic+bp8NaQqBbzLW44YVvbHz5xmFuS5dispIyeM4XKFSBduFEQq
2BSIVVr+GXt97mKCyKWZypbRqhUR0qPYFAQ9Dg5bEytm4Nz5Wxd3h4fX7ypvLDApLFGWl1o8
Q2toxszxoRYdYZ1SkfXP+AsaFspHAiICIdxBi3MpYzudihJymCxWI2T4x+88Pc2Lb2hNiEDc
dLNqWgtnkML0WHXwHAZSh6BVnFQfv3FOww5FwZ5bOmGn4/LAVsP5s1BKgzUGW0JN9M7lsz9d
z0OAQVQGN2PbRCG4HHyPORbHMsoJmzYWkxGfgT8CBhck9thCyTgyah29I25xOiHqpJWMcMH7
YudAPELk56mDH2FrWEK41KLo6EoVIVkJJxh0ZDWzq/gF8NxjmUh5hFZ19AaZqk6D0QvW63at
COliNHwOxOPtO84GlQkG8KuecQc3xLZhk28ZhzArzvDSnPmMe7Lnd4VKG1m0ru3MnliqKW9h
r30OmTjiKweH4CeXyK9t00NjzAsRj/CYCJZZS8uRDMtO4bNJLhD5X+ycgP1tq3Xs+OW8zQ9x
jagGpdJCJurGRsAaHamdX3z548mPqBM6gelxFSJCCk9c2AWrj2DAbKams04M5Z2Z703P/cGZ
Cxt7NVlh+O8I4TCtC6sUGxz/y0g4xyyw0T/gYBysidoguIXpq0vGkR2aPKwxauQtyKL00rZL
+x35PowG3nHj5QmCcJngtE8IsLqpt1hdeJncKP0Abuvwzaz/n8k2KELiLav/BAdGJBi0DQAA
[end]
@end example

The contents of this packet is a gzipped, base64-encoded copy of a
manifest. Other packets have slightly different contents, but
packets have two very important properties:

@itemize
@item 
Packets are @emph{informative}. A packet represents only a piece of
information, not a conversation or a promise to do anything. Transmitting
a packet does not require or imply any sort of promise about actions
taken by the sender or receiver. Packets can always be ignored or deleted.
No packet carries any obligation to act with it.
@item
Packets describe database state @emph{completely}. No matter how else
a monotone database chooses to store data, all of its state is
captured in a dump of packets, and can be reconstructed by reading
through the packets.
@end itemize

Because of these strong properties, the network servers used by
monotone act as @emph{dumb transports}. A network server is only used
to move packets between various monotone clients; servers do
@emph{not} interpret packets when they exchange them. 

@node    Ancestry
@section Ancestry

We previously described ``old'' and ``new'' versions of a file as
``parents'' and ``children'' in a directed graph. The relationship
between a child and its parents is called the @dfn{ancestry} of the
child.

Since monotone often stores related versions as deltas, it may
sometimes be @i{possible} to infer ancestry relationships by analyzing
the deltas. For technical reasons we will not dwell on here, monotone
does not do this. Instead, ancestry relationships are stored as
certs. The cert name @code{ancestor} is reserved by monotone for
expressing this relationship; the cert value of an @code{ancestor}
cert is the @sc{sha1} of the parent version.

For example, suppose the version
994fe79ae852133ff9a93ba0146d520192977078 is logically a child of the
version 53f48d87d6ffbbb5a980f1393159e83a4921841e, as shown:

@example
     +---------------------------------------------------+
     | parent version                                    |
     | SHA1 = 53f48d87d6ffbbb5a980f1393159e83a4921841e   |
     +---------------------------------------------------+
              |
              |
             \|/
              V
     +---------------------------------------------------+
     | child version                                     |
     | SHA1 = 994fe79ae852133ff9a93ba0146d520192977078   |
     +---------------------------------------------------+
@end example

Then the following cert would express the ancestry relationship:

@example
  +----------------------------------------------------------+
  | version code                                             |
  | 994fe79ae852133ff9a93ba0146d520192977078                 |
  +-----------------+----------------------------------------+
  | cert name  |  cert value                                 |
  | "ancestor" |  "53f48d87d6ffbbb5a980f1393159e83a4921841e" |
  +--------------------------+-------------------------------+
  | signed by key           |  signature                     |
  | "jrh@@somewhere.com"     |  "ac9c489c8...5d6b1c26c"       |
  +--------------------------+-------------------------------+
@end example


@node    Forks and merges
@section Forks and merges

So far we have been talking about versions of files as though each new
version logically follows the version before it, in a simple sequence
of versions.

@example
       +----------------+
       | parent version |
       +----------------+
                |
                |
       +----------------+
       | child version  |
       +----------------+
                |
                |
     +---------------------+
     | grandchild version  |
     +---------------------+
@end example

This is a rosy picture, but sometimes it does not work out this
way. Sometimes when you make new versions of files, other people are
@i{simultaneously} making new versions too, and their new versions
might be derived from the same parent as yours. Without loss of
generality, we will assume simultaneous edits only happen
two-at-a-time; in fact many more edits may happen at once but our
reasoning will be the same.

We call this situation of simultaneous edits a @dfn{fork}, and will
refer to the two children of a fork as the @i{left child} and
@i{right child}. In a large collection of files with many people
editing versions, especially on many different computers spread all
around the world, forks are a common occurrence.


@example
             +----------------+
             | parent version |
             +----------------+
                    |   |
           +--------+   +---------+
           |                      |
     +-------------+     +--------------+
     | left child  |     | right child  |
     +-------------+     +--------------+
@end example


If we analyze the changes in each child version, we will often find
that the changes made between the parent and the left child are
unrelated to the changes made between the parent and the right
child. When this happens, we can usually @dfn{merge} the fork,
producing a common grandchild version which contains both sets of
changes. 

@example
             +----------------+
             | parent version |
             +----------------+
                    |   |
           +--------+   +---------+
           |                      |
     +-------------+     +--------------+
     | left child  |     | right child  |
     +-------------+     +--------------+
           |                      |
           +--------+   +---------+
                    |   |
             +----------------+
             | merged version |
             +----------------+
@end example

@node    Branches
@section Branches

Sometimes, people intentionally produce forks which are @emph{not
supposed to be merged}; perhaps they have agreed to work independently
for a time, or wish to change their files in ways which are not
logically compatible with each other. When someone produces a fork
which is supposed to last for a while (or perhaps permanently) we say
that the fork has produced a new @dfn{branch}. Branches tell monotone
which versions you would like to merge, and which you would like to
keep separate.

You can see all the available branches using @code{monotone list branches}.

Branches are indicated with certs.  The cert name @code{branch} is
reserved for use by monotone, for the purpose of identifying the
members of a branch. A @code{branch} cert has a symbolic ``branch
name'' as its value. When we refer to ``a branch'', we mean all
versions with a common branch name in their @code{branch} certs.

For example, suppose you are working on a program called ``wobbler''.
You might develop many versions of wobbler and then decide to split
your versions into a ``stable branch'' and an ``unstable branch'', to
help organize your work. In this case, you might call the new branches
``wobbler-stable'' and ``wobbler-unstable''. From then on, all
versions in the stable branch would get a cert with name @code{branch}
and value @code{wobbler-stable}; all versions in the unstable branch
would get a cert with name @code{branch} and value
@code{wobbler-unstable}. When a @code{wobbler-stable} version forks,
the children of the fork will be merged. When a
@code{wobbler-unstable} version forks, the children of the fork will
be merged. However, the @code{wobbler-stable} and
@code{wobbler-unstable} branches will not be merged together, despite
having a common ancestor.

@example
                   +-------------------------+
                   | common ancestor version |
                   +-------------------------+
                          |          |
                +---------+          +---------+
                |                              |
       +----------------+              +------------------+           
       | stable version |              | unstable version |           
       +----------------+              +------------------+           
              | |                               | |                   
      +-------+ +-------+               +-------+ +-------+           
      |                 |               |                 |           
+-------------+ +--------------+  +---------------+ +----------------+
| left stable | | right stable |  | left unstable | | right unstable |
|   child     | |     child    |  |   child       | |     child      |
+-------------+ +--------------+  +---------------+ +----------------+
      |                  |              |                  |          
      +-------+ +--------+              +-------+ +--------+          
              | |                               | |                   
       +----------------+                +------------------+         
       | merged stable  |                | merged unstable  |         
       |    version     |                |      version     |         
       +----------------+                +------------------+ 

\_____________  _______________/  \_______________  _________________/
              \/                                  \/
         stable branch                     unstable branch
@end example


For each branch, the set of versions with @emph{no children} is called
the @dfn{heads} of the branch. Monotone can automatically locate, and
attempt to merge, the heads of a branch. If it fails to automatically
merge the heads, it may ask you for assistance or else fail cleanly,
leaving the branch alone.

For example, if a fork's left child has a child of its own (a ``left
grandchild''), monotone will merge the fork's right child with the
left grandchild, since those versions are the heads of the branch. It
will not merge the left child with the right child, because the left
child is not a member of the heads.

@example
               +----------------+
               | parent version |
               +----------------+
                      |       |
             +--------+       |
             |                |
       +-------------+        |
       | left child  |        |
       +-------------+        |
             |                |         
*************|****************|************
*            |                |           *
*  +-----------------+  +-------------+   *
*  | left grandchild |  | right child |   *  the heads of the branch
*  +-----------------+  +-------------+   *    (before the merge)
*            |                |           *
*************|****************|************
             |                |         
             +--------+   +---+
                      |   |
               +----------------+
               | merged version |
               +----------------+
@end example

When there is only one version in the heads of a branch, we say that
@i{the heads are merged}, or more generally that @i{the branch is
merged}, since the heads is the logical set of candidates for any
merging activity. If there are two or more version in the heads of a
branch, monotone will merge them two-at-a-time until there is only
one.

@node    Getting Started
@chapter Getting Started

Getting started using monotone is easy. This chapter is a tutorial,
which illustrates the basic use of monotone by means of a small
example software project: the canonical ``hello world'' program. We
will assume the following files exist:

@example
src/hello.c
include/hello.h
Makefile
@end example

@subsection Important Options
Before operating monotone, two options should be explained.

@itemize
@item
Most commands operate on a @i{database}, which is selected with
the @option{--db} option.
@item
Many commands operate on a subset of the database, called a
@i{branch}, which is selected with the @option{--branch} option.
@end itemize

Monotone will cache the settings for these options in your working
copy, so ordinarily once you have checked out a project, you will not
need to specify them again.  We will therefore only mention these
arguments in the first example.

@subsection Version Codes
Many commands require you to supply 40-character @sc{sha1} values as
arguments, which we refer to as @i{versions}. These are tedious to
type, so monotone permits you to supply @i{unambiguous prefixes} of
versions, rather than complete versions. For example, you may type
@code{4e20} rather than
@code{4e20554acfe16dbdaaba11d5a97b05ec15d8d689}, assuming that no
other versions in your database begin with @code{4e20}. If you supply
an ambiguous prefix, monotone will list all possible completions of
the prefix, and exit. You must then try again with a longer prefix.


We are now ready to explore some version control tasks.

@menu
* Creating a Database::   Create a new database.
* Generating Keys::       Generate an @sc{rsa} public/private key pair
* Adding Files::          Import the state of the tree to the database
* Making Changes::        Edit a file and examine work
* Committing Changes::    Save your work in the database
* Checking Out::          Move to a different version of a tree
* Forking and Merging::   Make multiple changes from the same base version
* Updating::              Moving a working copy to a ``newer'' version
* Transmitting Changes::  Post your work to a network server
@end menu


@node    Creating a Database
@section Creating a Database

The first step is to create a new database.  Monotone requires this as
an explicit step to prevent spurious creation of databases when an
invalid @option{--db} option is given.

This is easily done using the special @code{monotone db init} command:

@example
$ monotone db init --db=$HOME/test.db
@end example


@node    Generating Keys
@section Generating Keys

Now we must generate an @sc{rsa} key pair for ourselves. This step requires
choosing a key identifier. Typical key identifiers are similar to email addresses,
possibly modified with some prefix or suffix to distinguish multiple keys held by
the same owner. We will use the key identifier ``testkey@@nodomain.org''. When we
ask for a key to be generated, monotone will ask us for a passphrase. This phrase
is used to encrypt the key when storing it on disk, as a security measure.

@example
$ monotone --db=$HOME/test.db genkey testkey@@nodomain.org
enter passphrase for key ID [testkey@@nodomain.org] : @i{<enter passphrase here>}
monotone: generating key-pair 'testkey@@nodomain.org'
monotone: storing key-pair 'testkey@@nodomain.org' in database
@end example

We have now generated a key pair and placed it in the database
@file{~/test.db}. We can list the keys in this database, to ensure the
correct key was generated.

@example
$ monotone --db=$HOME/test.db list keys

[public keys]
9e9e9ef1d515ad58bfaa5cf282b4a872d8fda00c testkey@@nodomain.org


[private keys]
771ace046c27770a99e5fddfa99c9247260b5401 testkey@@nodomain.org

@end example

The hexidecimal string printed out before each key name is a
@emph{fingerprint} of the key, and can be used to verify that the key
you have stored under a given name is the one you intended to
store. Monotone will never permit one database to store two keys with
the same name or the same fingerprint.

This output shows one private and one public key stored under the name
@code{testkey@@nodomain.org}, so it indicates that our keys have been
successfully generated and stored. On subsequent commands, we will
need to re-enter our passphrase to produce signatures on various tags.


@node    Adding Files
@section Adding Files

Next we add all our files to our database. We can specify directories
or filenames; monotone will recursively scan any directories we
mention.

@example
$ monotone --branch=testbranch --db=$HOME/test.db add Makefile include src
monotone: adding Makefile to working copy add set
monotone: adding include/hello.h to working copy add set
monotone: adding src/hello.c to working copy add set
@end example

This command has now added our files to the @dfn{work list}, as
``additions''.  The work list is a special file called @file{work},
stored in a special control directory monotone just created, called
@file{MT}. There is only one control directory for the entire working
copy.

If we look at the work list, we see it contains instructions to add
these files.

@example
$ cat MT/work
add 
 Makefile
add
 include/hello.h
add
 src/hello.c
@end example

Now we are ready to commit our additions. We will provide a ``log
message'' for our commit as an argument on the command line.

@example
$ monotone commit 'initial addition of files'
monotone: committing 577c21252290d4b66240efb1f917a9f3c4136fe5 to branch testbranch
enter passphrase for key ID [testkey@@nodomain.org] : @i{<enter your passphrase here>}
monotone: committed 577c21252290d4b66240efb1f917a9f3c4136fe5
@end example

Now we can check to see that monotone is tracking these files in the
working copy manifest.  The working copy manifest is held in the file
@file{MT/manifest}. 

@example
$ cat MT/manifest
84e2c30a2571bd627918deee1e6613d34e64a29e  Makefile
c61af2e67eb9b81e46357bb3c409a9a53a7cdfc6  include/hello.h
97dfc6fd4f486df95868d85b4b81197014ae2a84  src/hello.c
@end example

The column on the left contains cryptographic hashes of the files
listed in the column on the right. Such a hash is called the ``version
code'' of each file. The manifest is a plain text file, and can be
manipulated with standard tools. If a file appears in a manifest, and
you do not want to manage the file with monotone, you can remove that
line of the manifest.

We can also check to see which certificates monotone generated when we
committed our work, using the @code{list certs} command. Note that we
only need to mention the first few digits of the manifest version we
wish to inspect, and monotone completes the version code for us:

@example
$ monotone list certs manifest 577c
monotone: expanded partial id '577c' to '577c21252290d4b66240efb1f917a9f3c4136fe5'
ok sig from [testkey@@nodomain.org] : [author] = [jrh@@nodomain.org]
ok sig from [testkey@@nodomain.org] : [branch] = [testbranch]
ok sig from [testkey@@nodomain.org] : [changelog] = [initial addition of files]
ok sig from [testkey@@nodomain.org] : [date] = [2003-04-04T07:39:51]
@end example

The output of this command has a line for each cert found. Each line
has 4 significant pieces of information. The first indicates whether
this cert is ``ok'', meaning whether the @sc{rsa} signature provided is
correct for the cert data. The second indicates the signer of the
cert, in this case @code{testkey@@nodomain.org}. The third is the cert
name, and the fourth is the cert value. This list shows us that
monotone has confirmed that, according to
@code{testkey@@nodomain.org}, the manifest
@code{577c21252290d4b66240efb1f917a9f3c4136fe5} is a member of the
branch @code{testbranch}, written by @code{jrh@@nodomain.org}, with
the given date and changelog.

It is important to keep in mind that manifests are not ``in'' or
``out'' of a branch in any global sense, nor are any of these cert
values @i{true} or @i{false} in any global sense. Each cert indicates
that @i{some person} would like to associate a manifest with some
value; it is up to you to decide if you want to accept that
association.

We can check status of our branch with the following command:

@example
$ monotone heads
branch 'testbranch' is currently merged:
577c21252290d4b66240efb1f917a9f3c4136fe5
@end example

The output of this command tells us that there is only one current
``head'' version in the branch @code{testbranch}, and it is the manifest
we just imported. A head version is one without any descendents. Since
we have not committed any changes to this manifest yet, it has no
descendents. 

Finally, if we wanted to manually transmit the manifest to someone
else, we could issue the following command:

@example
$ monotone mdata 577c21252290d4b66240efb1f917a9f3c4136fe5
[mdata 577c21252290d4b66240efb1f917a9f3c4136fe5]
H4sIAAAAAAAAAC3MWwoCMQxA0f9ZRVegkzbNYxEuIk1SRiwKivtXwd8D9wpm9bZb7QwjqLKC
RGZCEkGLhkloVbOUi91yXlduTmCzJnEOHQKJ1DqP0Rx3NbXejD2mUynXu6935PnItR6nY1P+
+QycKBRTu5CE9IHfDSjvgJbVBEt5Pf1f+fYBPkTTgaMAAAA=
[end]
@end example

This command produces an @code{mdata} packet, which is short for
``manifest data''. The @code{mdata} packet does not contain the files
or the certs. The body of the @code{mdata} packet is a base64 encoded,
gzipped copy of the manifest found in @file{MT/manifest}. We will see
in later sections how to transmit more packet types.

@node    Making Changes
@section Making Changes

Initially, the contents of the file @file{src/hello.c} were as follows:

@example
#include "hello.h"

void say_hello()
@{
        printf("hello, world\n");
@}

int main()
@{
        say_hello();
@}
@end example

Suppose now that we would like to make a change to this file, say to
the message which is printed out. We can edit the file directly, and
save the following new version:

@example
#include "hello.h"

void say_hello()
@{
        printf("hello, smelly world\n");
@}

int main()
@{
        say_hello();
@}
@end example

If we would like to see a compact listing of the change we have made,
relative to the version of the file recorded in our current manifest,
we can use the following command:

@example
$ monotone status
base manifest: 577c21252290d4b66240efb1f917a9f3c4136fe5
curr manifest: 86975f57ad571a61eb653371a2ffd12b96a301ed
changes:
  patch src/hello.c 97dfc6fd4f486df95868d85b4b81197014ae2a84 -> 8574638d5f34493e05e62d9e48b3c338169e7558
@end example

The output of this command tells us that our edits, so far, constitute
only a simple edit to a single file. If we would like to see that edit
in closer detail, we can also print out a difference listing in GNU
``unified diff'' format:

@example
$ monotone diff
# Summary of changes:
#   patch src/hello.c 97dfc6fd4f486df95868d85b4b81197014ae2a84 -> 8574638d5f34493e05e62d9e48b3c338169e7558
--- src/hello.c
+++ src/hello.c
@@@@ -1,8 +1,8 @@@@
 #include "hello.h"

 void say_hello()
 @{
-       printf("hello, world\n");
+       printf("hello, smelly world\n");
 @}

 int main()
@end example

Suppose now we would also like to move our @code{say_hello}
function to a secondary source file, and modify our @file{Makefile} to
build it separately. We can make these changes directly:

@example
$ head -n 6 src/hello.c >src/say-hello.c
$ vi src/hello.c
         @i{<remove the function from this source file>}
$ vi Makefile
         @i{<add a rule to build the new object file>}
@end example

We must then add the new file to monotone's working record:

@example
$ monotone add src/say-hello.c
@end example

This command does not modify the @file{MT/manifest} file, but rather
makes a note in a persistent log file @file{MT/work}, stating that you
wish to add the file @file{src/say-hello.c}. The @file{MT/work} file
is processed when you commit your work. Before we commit anything, We
can show the current status of our working copy once more, which will 
include any changes between the @file{MT/manifest} file and the files
in our working copy, as well as any additions or deletions written in
the @file{MT/work} file: 

@example
$ monotone status
  add src/say-hello.c as 84afbb102eca7e5f802ce381987ad7100ff7a1a9
  patch Makefile 84e2c30a2571bd627918deee1e6613d34e64a29e -> b506d36ac5a6ea0fd588acacf1ebaa0317601abe
  patch src/hello.c 97dfc6fd4f486df95868d85b4b81197014ae2a84 -> eac552f8ee3d29198884368d592de67db5cb77e2
@end example

And, as before, we can view the full difference listing:

@example
$ monotone diff
# Summary of changes:
#   add src/say-hello.c as 84afbb102eca7e5f802ce381987ad7100ff7a1a9
#   patch Makefile 84e2c30a2571bd627918deee1e6613d34e64a29e -> b506d36ac5a6ea0fd588acacf1ebaa0317601abe
#   patch src/hello.c 97dfc6fd4f486df95868d85b4b81197014ae2a84 -> eac552f8ee3d29198884368d592de67db5cb77e2
--- Makefile
+++ Makefile
@@@@ -1,2 +1,6 @@@@
-hello: include/hello.h src/hello.c
-       gcc -o hello -I include src/hello.c
+hello: include/hello.h src/say-hello.o src/hello.c
+       gcc -o hello say-hello.o src/hello.c
+
+say-hello.o: include/hello.h src/say-hello.c
+       gcc -c say-hello.o src/say-hello.c
+
--- src/hello.c
+++ src/hello.c
@@@@ -1,10 +1,5 @@@@
 #include "hello.h"

-void say_hello()
-@{
-       printf("hello, world\n");
-@}
-
 int main()
 @{
        say_hello();
@end example

@node    Committing Changes
@section Committing Changes

Now that we have made changes, we can commit them to the
database. Doing so will replace the ``head'' version of our branch with
the new, changed version, and store the older version as a reverse
delta from the new version.

@example
$ monotone commit
@end example

This will first place us in a ``log message editor'' --- typically an editor
like @command{vi} --- with an explanation of the changes being committed and
the opportunity to enter a log message.

@example
example commit log
MT: ----------------------------------------------------------------------
MT: Enter Log.  Lines beginning with `MT:' are removed automatically
MT:
MT: Summary of changes:
MT:
MT:   add src/say-hello.c as 84afbb102eca7e5f802ce381987ad7100ff7a1a9
MT:   patch Makefile 84e2c30a2571bd627918deee1e6613d34e64a29e -> b506d36ac5a6ea0fd588acacf1ebaa0317601abe
MT:   patch src/hello.c 97dfc6fd4f486df95868d85b4b81197014ae2a84 -> eac552f8ee3d29198884368d592de67db5cb77e2
MT: ----------------------------------------------------------------------
MT:
@end example

We have entered a single line above the explanatory message, saying
``example commit log''. We then save the file and quit the
editor. Monotone will delete all the lines beginning with ``MT:'' and
leave only our message. Returning to the shell, we are prompted for our passphrase.

@example
monotone: committing 0b34c61bd098a9c37cece9cbf7b765cc4d7b587e to branch testbranch
enter passphrase for key ID [testkey@@nodomain.org] : @i{<enter your passphrase here>}
monotone: committed 0b34c61bd098a9c37cece9cbf7b765cc4d7b587e
@end example

A commit typically involves making several certs, as well as storing
new versions of files and the manifest in the database. We can show the
certs produced, using the @command{list certs} command.

@example
$ monotone list certs manifest 0b34
monotone: expanded partial id '0b34' to '0b34c61bd098a9c37cece9cbf7b765cc4d7b587e'
ok sig from [testkey@@nodomain.org] : [ancestor] = [577c21252290d4b66240efb1f917a9f3c4136fe5]
ok sig from [testkey@@nodomain.org] : [author] = [jrh@@nodomain.org]
ok sig from [testkey@@nodomain.org] : [branch] = [testbranch]
ok sig from [testkey@@nodomain.org] : [changelog] = [example commit log
                                                    ]
ok sig from [testkey@@nodomain.org] : [date] = [2003-04-04T07:44:54]
@end example

In this commit, monotone produced a @code{branch} cert which relates
the new version to the branch @code{testbranch}, an @code{ancestor}
cert which relates old version to the new one, and several informative
meta-data certs such as @code{author}, @code{date}, and
@code{changelog}.

If we would like to examine the ancestry graph at any time, we can
produce a representation of it suitable for viewing with the popular
@command{xvcg} graph visualization tool, with the following command:

@example
$ monotone agraph
graph:
@{
node: @{ title : "0b34c61bd098a9c37cece9cbf7b765cc4d7b587e"@}
node: @{ title : "577c21252290d4b66240efb1f917a9f3c4136fe5"@}
edge: @{ sourcename : "577c21252290d4b66240efb1f917a9f3c4136fe5"
        targetname : "0b34c61bd098a9c37cece9cbf7b765cc4d7b587e" @}
@}
@end example

@node    Checking Out
@section Checking Out

Now that we have committed one version, the @file{MT/manifest} file
has been updated to reflect the current contents of the files we are working on:

@example
$ cat MT/manifest
b506d36ac5a6ea0fd588acacf1ebaa0317601abe  Makefile
c61af2e67eb9b81e46357bb3c409a9a53a7cdfc6  include/hello.h
eac552f8ee3d29198884368d592de67db5cb77e2  src/hello.c
84afbb102eca7e5f802ce381987ad7100ff7a1a9  src/say-hello.c
@end example

This version of the tree is safely stored in the database, however, so
we can feel free to ``checkout'' previous versions from the database,
without fear of losing our work:

@example
$ monotone checkout 577c .
monotone: expanded partial id '577c' to '577c21252290d4b66240efb1f917a9f3c4136fe5'
$ cat MT/manifest
84e2c30a2571bd627918deee1e6613d34e64a29e  Makefile
c61af2e67eb9b81e46357bb3c409a9a53a7cdfc6  include/hello.h
97dfc6fd4f486df95868d85b4b81197014ae2a84  src/hello.c
$ cat src/hello.c
#include "hello.h"

void say_hello()
@{
        printf("hello, world\n");
@}

int main()
@{
        say_hello();
@}
@end example

Note that monotone has reverted the tree to its original contents. It
has @emph{not}, however, deleted the file @file{src/say-hello.c} which
we added to our second version; it has merely removed it from the
manifest.

@node    Forking and Merging
@section Forking and Merging

Suppose that we (or some other user) happen to produce a different
modified version of our example project, derived from the same initial
version. We call this situation a @dfn{fork}. Monotone does not
prevent you from making forks, even when it can detect them.

@example
$ cat >>src/hello.c

void say_goodbye()
@{
        printf("goodbye\n");
@}
^D
@end example

We can view our differences, as before:

@example
$ monotone diff
# Summary of changes:
#   patch src/hello.c 97dfc6fd4f486df95868d85b4b81197014ae2a84 -> bdcf3d335db02a8a944b8945357c0e080b40f1b4
--- src/hello.c
+++ src/hello.c
@@@@ -9,3 +9,8 @@@@
 @{
        say_hello();
 @}
+
+void say_goodbye()
+@{
+       printf("goodbye\n");
+@}
@end example

And commit our change, this time providing the changelog message on
the command line as a third argument to the @command{commit} command.

@example
$ monotone commit "a fork"
monotone: committing 57d3afae9e806b930130a674befec2a52bd85cd1 to branch testbranch
enter passphrase for key ID [testkey@@nodomain.org] : @i{<enter your passphrase here>}
monotone: committed 57d3afae9e806b930130a674befec2a52bd85cd1
@end example

Monotone does not prohibit us from making a fork. However, if we check
the heads of our branch, we will now find that it is unmerged. In
other words, it has an unresolved fork:

@example
$ monotone heads
branch 'testbranch' is currently unmerged:
0b34c61bd098a9c37cece9cbf7b765cc4d7b587e
57d3afae9e806b930130a674befec2a52bd85cd1
@end example

This state does not, in itself, constitute a threat to the branch; we
can still commit new changes, check out versions, show differences,
etc. without resolving this fork. However, we will probably want to
resolve it eventually, if for no other reason than to incorporate the
positive features of both edges into a common head version.

Merging a fork can be quite simple:

@example
$ monotone merge
enter passphrase for key ID [testkey@@nodomain.org] : @i{<enter your passphrase here>}
[source] 0b34c61bd098a9c37cece9cbf7b765cc4d7b587e 
[source] 57d3afae9e806b930130a674befec2a52bd85cd1 
[merged] ecec7c49374ab9a7706a500339a2a0d6157372f1
@end example

This case is quite trivial and was handled automatically by the built
in 3-way merge algorithm. In more complicated merges, a hook is called
and the user may provide an external merge tool. By default, this hook
runs an emacs process with a batch command invoking @code{ediff} mode
with the conflicting files, to interactively merge the difference, but
this can be overridden if you prefer some other tool. If we
investigate the resulting manifest, we see the following.

@example
$ monotone list certs manifest ecec
monotone: expanded partial id 'ecec' to 'ecec7c49374ab9a7706a500339a2a0d6157372f1'
ok sig from [testkey@@nodomain.org] [ancestor] = [57d3afae9e806b930130a674befec2a52bd85cd1]
ok sig from [testkey@@nodomain.org] [ancestor] = [0b34c61bd098a9c37cece9cbf7b765cc4d7b587e]
ok sig from [testkey@@nodomain.org] [author] = [jrh@@nodomain.org]
ok sig from [testkey@@nodomain.org] [branch] = [testbranch]
ok sig from [testkey@@nodomain.org] [changelog] = [merge of 0b34c61bd098a9c37cece9cbf7b765cc4d7b587e and 57d3afae9e806b930130a674befec2a52bd85cd1]
ok sig from [testkey@@nodomain.org] [date] = [2003-04-04T08:00:09]
@end example

In the process of merging, monotone generated a merged copy of our
forked file, a merged copy of our forked manifest, and a number of
certs relating the fork and merge:

@itemize
@item
an @code{ancestor} cert relating the @i{left} ancestor version of
@file{src/hello.c} to the merged version
@item
an @code{ancestor} cert relating the @i{right} ancestor version of
@file{src/hello.c} to the merged version
@item
an @code{ancestor} cert relating the @i{left} ancestor manifest to the merged version
@item
an @code{ancestor} cert relating the @i{right} ancestor manifest to the merged version
@item
a @code{branch} cert associating the merged manifest with @code{testbranch}
@item
the usual @code{author}, @code{date}, and @code{changelog} certs for the merged manifest
@end itemize

Each cert is recorded separately. An interesting affect of this
independent record is that once you have performed a merge between two
file versions, the merge will automatically be reused in any future
tree merges which involve the same two files, even if they appear in
different branches.

We can now check the status of our branch's heads, to ensure that only
one merged copy remains.

@example
$ monotone heads
branch 'testbranch' is currently merged:
ecec7c49374ab9a7706a500339a2a0d6157372f1
@end example

@node    Updating
@section Updating

Now that we've merged our fork, we notice that the current version of
our working copy is no longer the ``newest'', in the sense that it has
a live descendent version in the database (the merged version).

Updating our working copy is quite straightforward in this simple
case.

@example
$ monotone update
monotone: updated to base version ecec7c49374ab9a7706a500339a2a0d6157372f1
@end example

If we check our version of @file{src/hello.c}, we now see we have a
merge of the two previous files.

@example
$ cat src/hello.c
#include "hello.h"

int main()
@{
        say_hello();
@}

void say_goodbye()
@{
        printf("goodbye\n");
@}
@end example

An update actually consists of three distinct phases.

@itemize

@item
In the @dfn{select phase}, monotone selects all descendants of the
manifest version the current working copy is based on, and sorts them
based on ancestry, as well as any user-specified certs. This
sorting should select an ideal ``new base version'' for your working
copy. If the select phase does not arrive at a @emph{unique} new base
version, the update stops.

@item
In the @dfn{merge phase}, monotone performs an in-memory merge between
the new base version and your working copy. Just as during a
@code{merge} command, if the built in 3-way merge fails then monotone
will run a user-provided hook. If this merge fails, the update stops.

@item
In the @dfn{write phase}, the new base version's manifest is written into
your @file{MT/manifest} file, and the merged files are written to your
working copy. This happens after the update is @emph{known} to
succeed, so it is an all-or-nothing phase.
@end itemize

The update operation essentially ``re-parents'' your working copy,
changing it from being a child of the version it was initially checked
out as, to being a child of the new base version. Your changes
relative to your previous parent are moved forward during the merge
phase.

One interesting feature of the update operation is that you can
override or extend the logic monotone uses to sort update candidates,
with Lua hook functions. This feature is still partially unfinished,
but in the future you should be able to transparently filter out
versions lacking sufficient approval from code reviewers, with
testsuite results showing regressions, or similar ``quality control''
orderings expressed as custom certs.


@node    Transmitting Changes
@section Transmitting Changes

After doing some work, typically we want to send these changes to
other users. We have seen previously that monotone can produce
sequences of ``packets'' which encode, in a safe and portable manner,
any type of work recorded in its database. To make life easier, we can
ask monotone to send sequences of packets to directly to a network
server, after we commit work. Monotone supports three kinds of network
servers: news servers, mail servers, and web servers. We will use a
web server in this example. To use a web server with monotone, we must
install a program on the web server called @dfn{depot}, which is a CGI
program. The @code{depot} program contains a subset of the
functionality of a news server, just enough to exchange packets.

To make our depot work, we need to do two things:

@menu
* Set up a Depot::        Prepare a web server to receive packets
* Configure the Client::  Edit our @file{.monotonerc} to use the depot
@end menu

Once we have a working depot that monotone knows about, when we make a
change, monotone will queue network transmissions to the appropriate
server. Supposing we had set up our @file{.monotonerc} file earlier,
our most recent commit would result in the following messages:

@example
$ monotone commit
monotone: committing a2f12ab893e7e40feb83e19f4e707ec6a2841601 to branch testbranch
enter passphrase for key ID [testkey@@nodomain.org] :@i{<enter your passphrase here>}
monotone: queueing packets for target http://www.myisp.com/~me/depot.cgi/helloworld
monotone: [bytes 1566] [packets 6]
monotone: committed a2f12ab893e7e40feb83e19f4e707ec6a2841601
@end example

This commit is similar to the previous one, but each cert and delta
which was previously committed to the database has also been
@i{queued} for transmission to our depot. Later, when we are connected
to the network and ready to send our work, we can issue a separate
posting command to communicate with the network servers:

@example
$ monotone post
monotone: posted 6 / 6 packets ok
@end example

Elsewhere, we may wish to receive changes from a network server. This
is also quite straightforward. We add another hook function to our
configuration file specifying which URLs we would like to fetch from:

@example
$ cat >>~/.monotonerc
function get_fetch_sources(branchname)
        return @{ "http://www.myisp.com/~me/depot.cgi/helloworld" @} 
end
@end example

Then we can fetch depot postings and integrate them into our database
directly.

@example
$ monotone fetch 
monotone: fetching packets from group helloworld at http://www.myisp.com/~me/depot.cgi
monotone: [packet: 6] 
monotone: http fetch complete
monotone: fetched 6 packets
@end example

Monotone remembers ``sequence numbers'' for each URL and logical group
name, so that it can fetch only unseen packets.

It is worth noting that the packets transmitted are the @i{smallest}
patch-set that monotone could compose at the time of
transmission. Therefore files which were ``added'' may wind up being
transmitted as deltas, and files which were committed as deltas but
which subsequently had their ancestors erased may wind up being
transmitted as full files. If a recipient is unhappy with a particular
type of packet they receive from a network server, they can always
request a personal retransmission, via email for example.

@node       Set up a Depot
@subsection Set up a Depot

The first step in setting up a depot is to extract our @sc{rsa} public key
packet from our monotone database. This will enable us to communicate
securely with the depot. We will extract the key to the file
@file{key-packet.txt}:

@example
$ monotone pubkey testkey@@nodomain.org >key-packet.txt
@end example

The packet generated is a plain text encoding of an @sc{rsa} public key
number. It looks pretty much like any other packet:

@example
$ cat key-packet.txt
[pubkey testkey@@nodomain.org]
MIGdMA0GCSqGSIb3DQEBAQUAA4GLADCBhwKBgQDDEs10/X6ZDYKB7snQuESSgoAxwsk8b0au
rBroCig2qz14oIHX9DIvTlfPfiSjncnBS/zQ+seLjqEmhcegU9d/dsIEIvWlfXHlwBEkCKKL
VP0cx6WFpq1xPfrRCn6MJ1/NxYbgIFeuoNkCJR9GTM3WLV/1CaWSYGVEX+aIooRYRwIBEQ==
[end]
@end example

Next we need to set up a CGI program on a web server somewhere. For
this example, we say we will put the CGI at the (nonexistant) URL
@code{http://www.myisp.com/~me/depot.cgi}. Your URL will obviously be
different, depending on where you host your web server.

We copy the @file{depot.cgi} program to our web server, along with the
packet file @file{key-packet.txt}, and configure our web server to
execute CGI programs on our behalf. The CGI configuration step is
beyond the scope of this tutorial, but it is well documented
elsewhere.

One important point, when configuring a writable depot, is that the
directory the depot is contained in must be writable by the user which
will execute CGI programs. On some web servers this is the user owning
the directory, and on others it is a special user such as @code{www},
@code{cgi} or @code{nobody}.

Next we run an initialization command to build a small database file
for the depot program, then add the public key packet to the database
as an authorized uploader.

@example
$ ./depot.cgi initdb
$ ./depot.cgi adduser <key-packet.txt
@end example

Now one key --- @code{testkey@@nodomain.org} --- is authorized to
upload packets to the database, and anyone can download packets from
it. We are finished on the web server. To check that the depot is
ready to accept packets, we can load a status URL in a standard web
client, from our client site.

@example
$ wget -O - http://www.myisp.com/~me/depot.cgi?q=status
depot operational with 0 packets.
@end example


@node       Configure the Client
@subsection Configure the Client

For monotone to fetch from our newly created depot, we must edit our
@file{.monotonerc} file, which is a collection of functions written in
the @uref{http://www.lua.org, Lua} programming language. We will write
some entries which tell monotone which network URL to post to, and
which user name we would like to post as. Configuration in monotone is
always done as @i{hook functions}, which calculate configuration
variables based on some parameters (or, in rare cases, no parameters):

@example
$ cat >~/.monotonerc
function get_post_targets(branchname)
        return @{ "http://www.myisp.com/~me/depot.cgi/helloworld" @} 
end

function get_http_auth(url)
        return "testkey@@nodomain.org"
end
^D
@end example

We have written two hook functions. The first takes a branch name and
returns a Lua table of values. You may return different results
depending on the branch name provided, but for this example we ignore
the branch name and always return the same table. Each value in the
table is a URL, including the path to our depot CGI and a @dfn{logical
group name} as the URL's path info. Logical group names are analogous
to newsgroups on news servers: they collect some subset of the data on
the depot --- perhaps multiple branches, perhaps all your work ---
into a collection that can be requested by name.

Usually you will post all your data to a single logical group name on
a given depot, but you may occasionally wish to have more than one, if
your depot is carrying many different sorts of data, and you want to
be able to fetch only part of the data at a time.

The second hook function takes a URL and returns the name of an
@sc{rsa} keypair in your database, to use for authenticating
transmissions to the depot. This will generally be the name of the key
you use to sign certificates.


@node    Special Topics
@chapter Special Topics

This chapter covers special topics which are of interest to some users
of monotone, though possibly not all. We assume that you have read
through the taxonomy and tutorial, and possibly spent some time
playing with the program to familiarize yourself with its operation.

@menu
* Hash Integrity::         Notes on probability and failure.
* Quality Assurance::      Integrating testing and review with development.
* Internationalization::   Using monotone in non-English locales.
* Reserved Certs::         Certificate names with special meanings.
* Naming Conventions::     Choosing appropriate names for keys and branches.
* File Attributes::        Marking files as executable, or other attributes.
* Migrating and Dumping::  Changing the underlying storage system.
* Importing from CVS::     Building a monotone database from a CVS repository.
@end menu

@node    Hash Integrity
@section Hash Integrity

Some proponents of a competing, proprietary version control system
have suggested, in a
@uref{http://www.usenix.org/events/hotos03/tech/full_papers/henson/henson_html/,
usenix paper}, that the use of a cryptographic hash function such as
@sc{sha1} as an identifier for a version is unacceptably unsafe. This
section addresses the argument presented in that paper and describes
monotone's additional precautions.

To summarize our position:
@itemize
@item
the analysis in the paper is wrong,
@item
even if it were right, monotone is sufficiently safe.
@end itemize

@heading The analysis is wrong

The paper displays a fundamental lack of understanding about what a
@emph{cryptographic} hash function is, and how it differs from a
normal hash function. Furthermore it confuses accidental collision
with attack scenarios, and mixes up its analysis of the risk involved
in each. We will try to untangle these issues here.

A cryptographic hash function such as @sc{sha1} is more than just a
uniform spread of inputs to an output range. Rather, it must be
designed to withstand attempts at:

@itemize
@item 
reversal: deriving an input value from the output
@item 
collision: finding two different inputs which hash to the same output
@end itemize

Collision is the problem the paper is concerned with. Formally, an
n-bit cryptographic hash should cost @math{2^n} work units to collide
against a given value, and @math{sqrt(2^n)} tries to find a random
pair of colliding values. This latter probability is sometimes called
the hash's ``birthday paradox probability''.

@subheading Accidental collision 

One way of measuring these bounds is by measuring how single-bit
changes in the input affect bits in the hash output. The @sc{sha1}
hash has a strong @emph{avalanche property}, which means that flipping
@emph{any one bit} in the input will cause on average half the 160
bits in the output code to change. The fanciful @sc{val1} hash
presented in the paper does not have such a property --- flipping its
first bit when all the rest are zero causes @emph{no change} to any of
the 160 output bits --- and is completely unsuited for use as a
@emph{cryptographic hash}, regardless of the general shape of its
probability distribution.

The paper also suggests that birthday paradox probability cannot be
used to measure the chance of accidental @sc{sha1} collision on ``real
inputs'', because birthday paradox probability assumes a uniformly
random sample and ``real inputs'' are not uniformly random. The paper
is wrong: the inputs to @sc{sha1} are not what is being measured (and
in any case can be arbitrarily long); the collision probability being
measured is of @emph{output space}. On output space, the hash is
designed to produce uniformly random spread, even given nearly
identical inputs. In other words, it is @emph{a primary design
criterion} of such a hash that a birthday paradox probability is a
valid approximation of its collision probability.

The paper's characterization of risk when hashing ``non-random
inputs'' is similarly deceptive. It presents a fanciful case of a
program which is @emph{storing} every possible 2kb block in a
file system addressed by @sc{sha1} (the program is trying to find a
@sc{sha1} collision). While this scenario @emph{will} very likely
encounter a collision @emph{somewhere} in the course of storing all
such blocks, the paper neglects to mention that we only expect it to
collide after storing about @math{2^80} of the @math{2^16384} possible
such blocks (not to mention the requirements for compute time to
search, or disk space to store @math{2^80} 2kb blocks).

Noting that monotone can only store @math{2^41} bytes in a database,
and thus probably some lower number (say @math{2^32} or so) active
rows, we consider such birthday paradox probability well out of
practical sight. Perhaps it will be a serious concern when
multi-yottabyte hard disks are common.


@subheading Collision attacks

Setting aside accidental collisions, then, the paper's underlying
theme of vulnerability rests on the assertion that someone will break
@sc{sha1}. Breaking a cryptographic hash usually means finding a way
to collide it trivially. While we note that @sc{sha1} has in fact
resisted attempts at breaking for 8 years already, we cannot say that
it will last forever. Someone might break it. We can say, however,
that finding a way to trivially collide it only changes the resistance
to @emph{active attack}, rather than the behavior of the hash on
benign inputs.

Therefore the vulnerability is not that the hash might suddenly cease
to address benign blocks well, but merely that additional security
precautions might become a requirement to ensure that blocks are
benign, rather than malicious. The paper fails to make this
distinction, suggesting that a hash becomes ``unusable'' when it is
broken. This is plainly not true, as a number of systems continue to
get useful low collision hashing behavior --- just not good security
behavior --- out of ``broken'' cryptographic hashes such as MD4.

@heading Monotone is probably safe anyways

Perhaps our arguments above are unconvincing, or perhaps you are the
sort of person who thinks that practice never lines up with
theory. Fair enough. Below we present @emph{practical} procedures you
can follow to compensate for the supposed threats presented in the
paper.

@subheading Accidental collision

To minimize the chance of accidental collision further, monotone has a
special type of certificate called a @code{vcheck}, which you can
issue at any time and in any quantity you like. A @code{vcheck}
certificate contains a @emph{randomly keyed} message authentication
code (@sc{mac}). This effectively means that a @code{vcheck}
cert identifies your tree again, with a ``different'' variant of
@sc{sha1}.

If you have the @sc{sha1} of your manifest and a @code{vcheck} cert,
the probability of a collision involving that manifest drops from
@math{2^-160} to @math{2^-320}. If you have two @code{vcheck} certs,
it drops to @math{2^-480}, and so on. You can issue as many
@code{vcheck} certs as you like until your personal level of paranoia
is met. Each @code{vcheck} cert has its own random seed, usually 128
bits, so after you've issued about @math{2^64} @code{vcheck} certs on
the same manifest you have a decent chance of repeating one, but that
is harmless.

Adding the occasional @code{vcheck} cert to your tree is a good idea
if you are worried about the ``deterministic'' nature of accidental
collisions in @sc{sha1}, outlined in the paper. Since the @sc{mac} is
randomized, unintentional (non-attack) collisions in @code{vcheck}
certs are reliably nondeterministic. Furthermore, they minimize the
chance that a malicious collision has gone undetected, by requiring
the collision to pass an additional (and equally hard) check. A large
warning is printed if such a check fails.

@subheading Collision attacks

A successful collision attack on @sc{sha1}, as mentioned, does not
disrupt the @emph{probability} features of @sc{sha1} on benign
blocks. So if, at any time, you believe @sc{sha1} is ``broken'', it
does @emph{not} mean that you cannot use it for your work with
monotone. It means, rather, that you cannot base your @emph{trust} on
@sc{sha1} values anymore. You must trust who you communicate with.

The way around this is reasonably simple: if you do not trust
@sc{sha1} to prevent malicious blocks from slipping into your
communications, you can always augment it by enclosing your
communications in more security, such as tunnels or additional
signatures on your email posts. If you choose to do this, you will
still have the benefit of self-identifying blocks, you will simply
cease to trust such blocks unless they come with additional
authentication information.

If in the future @sc{sha1} (or, indeed, @sc{rsa}) becomes accepted as
broken we will naturally upgrade monotone to a newer hash or public
key scheme, and provide migration commands to recalculate existing
databases based on the new algorithm. 

Similarly, if you do not trust our vigilance in keeping up to date
with cryptography literature, you can modify monotone to use any
stronger hash you like, at the cost of isolating your own
communications to a group using the modified version. Monotone is free
software, and runs atop @code{crypto++}, so it is both legal and
relatively simple to change it to use some other algorithm.

@node    Quality Assurance
@section Quality Assurance

Monotone was constructed to serve both as a version control tool and
as a quality assurance tool. The quality assurance features permit
users to ignore, or filter-out, versions which do not meet their
criteria for quality. This section describes the way monotone
represents and reasons about quality information.

Monotone often views the collection of manifest @code{ancestor} certs
as a directed graph, in which manifest versions are the nodes and the
@code{ancestor} certificates are the edges. We call this graph the
@dfn{ancestry graph}. The ancestry graph has a number of important
subgraphs, many of which overlap. For example, each branch is a
subgraph of the ancestry graph, containing only the nodes carrying a
particular @code{branch} cert.

Many of monotone's operations involve searching the ancestry graph for
the ancestors or descendants of a particular manifest, or extracting
the ``heads'' of a subgraph, which is the subgraph's set of nodes with
no descendants. For example, when you run the @code{update} command,
monotone searches the subgraph consisting of descendants of the base
version of the current working copy, trying to locate a unique head to
update the base version to.

Monotone's quality assurance mechanisms are mostly based on
restricting the subgraph each command operates on. There are three
methods used to restrict the subgraph:

@itemize
@item
By restricting the set of trusted @code{ancestor} certificates, you
can require that specific code reviewers have approved of each edge in
the graph.
@item
By further removing from the set of trusted @code{ancestor} certificates, 
those which coincide with trusted @code{disapproval} certificates. 
@item
By restricting the set of trusted @code{testresult} certificates, you
can require that the @emph{endpoints} of an update operation have a
certificate asserting that the version in question passed a certain
test, or testsuite.
@end itemize

The evaluation of trust is done on a cert-by-cert basis by calling a
pair of lua hooks: @code{get_manifest_cert_trust} and
@code{get_manifest_cert_trust}. These hooks are only called when a
cert has at least one good signature from a known key, and are passed
@emph{all} the keys which have signed the cert, as well as the cert's
id, name and value. The hook can then evaluate the set of signers, as
a group, and decide whether to grant or deny trust to the assertion made
by the cert.

The evaluation of testresults is controlled by the
@code{accept_testresult_change} hook. This hook is called when
selecting update candidates, and is passed a pair of tables describing
the @code{testresult} certs present on the source and proposed
destination of an update. Only if the change in test results are
deemed ``acceptable'' does monotone actually select an update target
to merge into your working copy.


@node    Internationalization
@section Internationalization

Monotone initially dealt with only ASCII characters, in file path
names, certificate names, key names, URLs, and packets. Some
conservative extensions are provided to permit internationalized
use. These extensions can be summarized as follows:

@itemize

@item
Monotone uses GNU gettext to provide localized progress and error
messages. Translations may or may not exist for your locale, but the
infrastructure is present to add them.

@item
All command-line arguments are mapped from your local character set to
UTF-8 before processing. This means that monotone can @emph{only}
handle key names, file names, certificate names and URLs which map
cleanly into UTF-8.

@item
Monotone's control files are stored in UTF-8. This includes: manifest
files, both inside the database and when written to the
@file{MT/manifest} file in the working copy; the @file{MT/options} and
@file{MT/work} files; and the @file{.mt-attrs} file. Converting these
files to any other character set will cause monotone to break; do not
do so.

@item
File path names in the working copy are converted to the locale's
character set (determined via the LANG or CHARSET environment
variables) before monotone interacts with the file system. If you are
accustomed to being able to use file names in your locale's character
set, this should ``just work'' with monotone.

@item
Key and cert names, URLs, and similar ``name-like'' entities are
subject to some cleaning and normalization, and conversion into
network-safe subsets of ASCII (ACE or URL-encoding, depending on
context). Generally, you should be able to use ``sensible'' strings in
your locale's character set as names, but they may appear mangled or
escaped in certain contexts such as network transmission.

@item
Monotone's transmission and storage forms are otherwise
unchanged. Packets and database contents are 7-bit clean ASCII.

@end itemize

The remainder of this section is a precise specification of monotone's
internationalization behavior.

@heading General Terms

@table @asis
@item Character set conversion
The process of mapping a string of bytes representing wide characters
from one encoding to another. Per-file character set conversions are
specified by a Lua hook @code{get_charset_conv} which takes a filename
and returns a table of two strings: the first represents the
"internal" (database) charset, the second represents the "external"
(file system) charset.

@item Line ending conversion
The process of converting platform-dependent end-of-line codes
(@code{0x0D}, @code{0x0A}, or the pair @code{0x0D 0x0A}) from one
convention to another. Per-file line ending conversion is specified by
a Lua hook @code{get_linesep_conv} which takes a filename and returns
a table of two strings: the first represents the "internal" (database)
line ending convention, the second represents the "external"
(file system) line ending convention. each string should be one of the
three strings "CR", "LF", or "CRLF".

Note that Line ending conversion is always performed on the internal
character set, when both character set and line ending conversion are
enabled; this behavior is meant to encourage the use of the monotone's
``normal form'' (UTF-8, '\n') as an internal form for your source
files, when working with multiple external forms. Also note that line
ending conversion only works on character encodings with the specific
code bytes described above, such as ASCII, ISO-8859x, and UTF-8.

@item Normal form conversion
Character set and line ending conversions done between a "system form"
and a "normal form". The system character set form is inferred from
the environment, using the various locale environment variables. The
system line ending form can be additionally specialized using the
@code{get_system_linesep} hook. No hooks exist for adjusting the
system character set, since the system character set must be known
during command-line argument processing, before any Lua hooks are
loaded.

Monotone's normal form is the UTF-8 character set and the @code{0x0A}
(LF) line ending form. This form is used in any files monotone needs
to read, write, and interpret itself, such as: @file{MT/manifest},
@file{MT/work}, @file{MT/options}, @file{.mt-attrs}

@item LDH
Letters, digits, and hyphen: the set of ASCII bytes @code{0x2D},
@code{0x30..0x39}, @code{0x41..0x5A}, and @code{0x61..0x7A}.

@item stringprep
RFC 3454, a general framework for mapping, normalizing, prohibiting
and bidirectionality checking for international names prior to use in
public network protocols.

@item nameprep
RFC 3491, a specific profile of stringprep, used for preparing
international domain names (IDNs)

@item punycode
RFC 3492, a "bootstring" encoding of unicode into ASCII. 

@item IDNA
RFC 3490, international domain names for applications, a combination
of the above technologies (nameprep, punycoding, limiting to LDH
characters) to form a specific "ASCII compatible encoding" (ACE) of
unicode, signified by the presence of an "unlikely" ACE prefix string
"xn--". IDNA is intended to make it possible to use unicode relatively
"safely" over legacy ASCII-based applications. the general picture of
an IDNA string is this:

@example     
      @{ACE-prefix@}@{LDH-sanitized(punycode(nameprep(UTF-8-string)))@}
@end example

It is important to understand that IDNA encoding does @emph{not}
preserve the input string: it both prohibits a wide variety of
possible strings and normalizes non-equal strings to supposedly
"equivalent" forms.

By default, monotone does @emph{not} decode IDNA when printing to the
console (IDNA names are ASCII, which is a subset of UTF-8, so this
normal form conversion can still apply, albeit oddly). this behavior
is to protect users against security problems associated with
malicious use of "similar-looking" characters. If the hook
@code{display_decoded_idna} returns true, IDNA names are decoded for
display.

@end table
  
@heading Filenames

@itemize

@item
Filenames are subject to normal form conversion. 

@item
Filenames are subject to an additional normal form stage which adjusts
for platform name semantics, for example changing the Windows
@code{0x5C} '\' path separator to @code{0x2F} '/'. This extra
processing is performed by boost::filesystem.

@item
FIXME: Monotone does not properly handle case insensitivity on windows.

@item
A filename (in normal form) is constrained to be a nonempty sequence
of path components, separated by byte @code{0x2F} (ASCII / ), and
without a leading or trailing @code{0x2F}.

@item
A path component is a nonempty sequence of any UTF-8 character codes
except the path separator byte @code{0x2F} and any ASCII "control codes"
(@code{0x00..0x1F} and @code{0x7F}).

@item
The path components "." and ".." are prohibited.

@item
Manifests are constructed from the normal form (UTF-8). The LC_COLLATE
locale category is @emph{not} used to sort manifest entries.

@end itemize

@heading File contents

@itemize
@item
Files are subject to character set conversion and line ending
conversion.

@item
File SHA1 values are calculated from the internal form of the
conversions. If the external form of a file differs from the internal
form, running a 3rd party program such as @code{sha1sum} will produce
different results than those entries shown in the @file{MT/manifest}
file.

@end itemize

@heading UI messages

UI messages are displayed via calls to @code{gettext()}. 


@heading URLs

URLs are read on the command-line and subject to normal form
conversion. Each component of a URL is then subject to a different
further normalization or conversion:

@table @asis

@item Host names 
Split at '.', each component subject to IDNA encoding, rejoined.

@item Path components in HTTP URL
All ASCII control codes (@code{0x0..0x1F} and @code{0x7F}) and code
@code{0x20} (ASCII SP) are prohibited; 10 reserved ";/?:@@&=+$,"
characters and all other UTF-8 codes outside the unreserved class of
72 chars (62 alphanum, 9 mark "-_.!~*'()" and one escape "%") are
escaped into (%xx) hex form. Behavior roughly follows RFC 2396.

@item Email addresses and NNTP group names
Split at '.' and '@@', each component subject to IDNA encoding, and
rejoined. Behavior roughly follows suggested procedure in
draft-faerber-i18n-email-netnews-names-00.txt.

@end table

After these processing stages, URLs are stored internally as ASCII.
The invariant is that a URL inside monotone contains only the 72
non-reserved bytes and the 3 reserved bytes "/@@." described in RFC
2396.

@heading Cert names

Read on the command line and subject to normal form conversion and
IDNA encoding as a single component. The invariant is that a cert name
inside monotone is a single LDH ASCII string.

@heading Cert values

Cert values may be either text or binary, depending on the return
value of the hook @code{cert_is_binary}. If binary, the cert value is
never printed to the screen (the literal string "<binary>" is
displayed, instead), and is never subjected to line ending or
character conversion. If text, the cert value is subject to normal
form conversion, as well as having all UTF-8 codes corresponding to
ASCII control codes (@code{0x0..0x1F} and @code{0x7F}) prohibited in
the normal form, except @code{0x0A} (ASCII LF).

@heading Key names

Read on the command line and subject to normal form conversion and
IDNA encoding as an email address (split and joined at '.' and '@@'
characters). The invariant is that a key name inside monotone contains
only LDH, '.' and '@@' characters.

@heading Packets

Packets are 7-bit ASCII. The characters permitted in packets are
the union of these character sets:

@itemize
@item
The 65 characters of base64 encoding (64 coding + "=" pad).
@item
The 16 characters of hex encoding.
@item
LDH, '@@' and '.' characters, as required for key and cert names.
@item
'[' and ']', the packet delimiters.
@item
ASCII codes 0x0D (CR), 0x0A (LF), 0x09 (HT), and 0x20 (SP). 
@end itemize

@heading Explicit rename certs, @file{MT/work} and @file{.mt-attrs}

Incompatible change: these formats were changed, incompatibly, from
earlier versions of monotone which used 0x20 (ASCII SP) as a
delimiter. The files now use 0x0A (ASCII LF) as a delimiter, to permit
0x20 in filenames.


@node    Reserved Certs
@section Reserved Certs

Every certificate has a name. Some names have meaning which is built
in to monotone, others may be used for customization by a particular
user, site, or community. If you wish to define custom certificates,
you should prefix such certificate names with @code{x-}. For example,
if you want to make a certificate describing the existence of security
vulnerabilities in a version, you might wish to create a certificate
called @code{x-vulnerability}.  Monotone reserves all names which do
not begin with @code{x-} for possible internal use. If an @code{x-}
certificate becomes widely used, montotone will likey adopt it as a
reserved cert name and standardize its semantics.

Most reserved certificate names have no meaning yet; some do. Usually
monotone is also responsible for @emph{generating} these certificates,
so you should generally have no cause to make them yourself. They are
described here to help you understand monotone's operation.

The pre-defined, reserved certificate names are:

@table @code

@item ancestor
This cert's value is interpreted as the @sc{sha1} of another manifest,
and monotone interprets such a cert as an assertion that manifest
identified by the value if the cert is an ancestor of the manifest the
cert applies to. This cert controls the merging and updating algorithms.

@item author
This cert's value is the name of a person who committed the manifest
the cert is attached to. The cert is generated when you commit a
version. It is displayed by the @code{log} command.

@item changelog
This cert's value is the change log message you provide when you commit a version.
It is displayed by the @code{log} command.
@item comment
This cert's value is an additional comment, usually provided after committing, 
about a version. Certs with the name @code{comment} can be applied to files as
well, and will be shown by the @code{log} command.

@item date
This cert's value is an ISO date string indicating the time at which a manifest
was committed. It is displayed by the @code{log} command, and may be used as an
additional heuristic or selection criterion in other commands in the future.

@item rename
This cert's value is a specially formatted string which describes the
set of rename actions (if any) which occurred between some other
manifest and the one the cert is attached to. These certs are
synthesized by monotone during @code{commit}, @code{merge}, and
@code{propagate} commands. The value is used as a hint to the patch
set analysis algorithm, when comparing manifests. If @code{rename}
certs are damaged or missing, the analysis of rename events can
potentially degrade, and monotone might consider a renamed file to be
two different files (one deleted and one added). Otherwise the absence
of these certificates is harmless.

@item tag
This cert's value is a symbolic name given to a version, which may be
used in the future as a way of selecting versions for @code{checkout}.

@item disapproval
This cert's value is interpreted as the @sc{sha1} of another manifest.
Monotone interprets such a cert signed by @var{key}, with value
@var{pred} on manifest @var{id} as an assertion that @var{key}
@emph{disapproves} of the ancestry edge between @var{pred} and
@var{id}. This cert is generated by the @command{disapprove} command,
and is used to facilitate code review.  This cert controls the merging
and updating algorithms, along with the @code{ancestor} cert.

@item testresult
This cert's value is interpreted as a boolean string, either @code{0}
or @code{1}. It is generated by the @code{testresult} command and
represents the results of running a particular test on the underlying
manifest. Typically you will make a separate signing key for each test
you intend to run on tree versions. This cert controls the
@command{update} algorithm.

@item vcheck
This cert contains a seed value and a special message authentication
code (@sc{mac}) calculated with that seed value over the files of the
manifest the cert applies to. It can be used to reduce the chance of
accidental collision in @sc{sha1}.

@end table

@node    Naming Conventions
@section Naming Conventions

Some names in monotone are private to your work, such as
filenames. Other names are potentially visible outside your project,
such as @sc{rsa} key identifiers or branch names. It is possible that
if you choose such names carelessly, you will choose a name which
someone else in the world is using, and subsequently you may cause
confusion when your work and their is received simultaneously by some
third party.

We therefore recommend two naming conventions:

@itemize
@item 
For @sc{rsa} keys, use the name of an active email address you
own. This will minimize conflicts, and also serves as a mnemonic to
associate your personal @emph{identity} with signatures made with your
key. For example, monotone's primary author uses the key identifier
@code{graydon@@pobox.com}.

@item
For branch names, select any name you like but prefix it with the
``inverted domain name'' of a DNS domain you control or are otherwise
authorized to use. This behavior mimics the package naming convention
in the java programming language. For example, monotone itself is
developed within the @code{net.venge.monotone} branch, because the
author owns the DNS domain @code{venge.net}.
@end itemize

@node    File Attributes
@section File Attributes

Monotone contains a mechanism for storing @dfn{persistent file
attributes}.  These differ from file certificates in an important way:
attributes are associated with a path name in your working copy,
rather than a particular version of a file. Otherwise they are
similar: a file attribute associates a simple name/value pair with a
file in your working copy.

The attribute mechanism is motivated by the fact that some people like
to store executable programs in version control systems, and would like
the programs to remain executable when they check out a working copy.
For example, the @code{configure} shell script commonly shipped with
many programs should be executable. 

Similarly, some people would like to store devices, symbolic links,
read-only files, and all manner of extra attributes of a file, not
directly related to a file's data content. 

Rather than try to extend the manifest file to accommodate attributes,
monotone requires that you place your attributes in a specially named
file in the root of your working copy. The file is called
@file{.mt-attrs}, and it has a simple 3-column format, for example:

@example
execute   true   src/configure
execute   true   autogen.sh
@end example

Each line of an @file{.mt-attrs} file assigns an attribute to a file
in your working copy. The first column of each line contains the name
of the attribute, the second column is the value of the attribute, and
the third column is the file name within the working copy to which the
attribute will be applied.

Every time your working copy is written to, monotone will look for an
@file{.mt-attrs} file, and if it finds one, run the corresponding
hooks registered for each attribute found in the file. This way, you
can extend the vocabulary of attributes understood by monotone simply
by writing new hooks. 

For more information on defining hooks for new attributes, see the
@code{attr_functions} entry in @ref{Hook Reference}.

Aside from its special interpretation, the @file{.mt-attrs} file is a
normal text file. If you want other people to see your attributes, you
should @code{add} and @code{commit} the @file{.mt-attrs} file in your
working copy. If you make changes to it which conflict with changes
other people make, you will have to resolve those conflicts, as plain
text, just as with any other text file in your working copy.


@node    Migrating and Dumping
@section Migrating and Dumping

While the state of your database is logically captured in terms of a
packet stream, it is sometimes necessary or desirable (especially
while monotone is still in active development) to modify the SQL table
layout or storage parameters of your version database, or to make
backup copies of your database in plain text. These issues are not
properly addressed by generating packet streams: instead, you must use
@dfn{migration} or @dfn{dumping} commands.

The @command{monotone db migrate} command is used to alter the SQL
schema of a database. The schema of a monotone database is identified
by a special hash of its generating SQL, which is stored in the
database's auxiliary tables. Each version of monotone knows which
schema version it is able to work with, and it will refuse to operate
on databases with different schemas. When you run the
@command{migrate} command, monotone looks in an internal list of SQL
logic which can be used to perform in-place upgrades. It applies
entries from this list, in order, attempting to change the database it
@emph{has} into the database it @emph{wants}. Each step of this
migration is checked to ensure no errors occurred and the resulting
schema hashes to the intended value. The migration is attempted inside
a transaction, so if it fails --- for example if the result of
migration hashes to an unexpected value --- the migration is aborted.

If more drastic changes to the underlying database are made, such as
changing the page size of sqlite, or if you simply want to keep a
plain text version of your database on hand, the @command{monotone db
dump} command can produce a plain ASCII SQL statement which generates
the state of your database. This dump can later be reloaded using the
@command{monotone db load} command. 

Note that when reloading a dumped database, the schema of the dumped
database is @emph{included} in the dump, so you should not try to
@command{init} your database before a @command{load}.

@node    Importing from CVS
@section Importing from CVS

Monotone is capable of reading CVS files directly and importing them
into a database. This feature is still somewhat immature, but
moderately large ``real world'' CVS trees on the order of 1GB have
successfully been imported. 

Note however that the machine requirements for CVS trees of this size
are not trivial: it can take several hours on a modern system to
reconstruct the history of such a tree and calculate the millions of
cryptographic certificates involved. We recommend experimenting with
smaller trees first, to get a feel for the import process.

We will assume certain values for this example which will differ in your case:
@itemize
@item
Your domain name, @code{test.net} in this example.
@item 
Your key name, @code{import@@test.net} in this example.
@item
Your project name, @code{wobbler} in this example.
@item
Your database name, @file{test.db} in this example.
@item
Your CVS repository path, @file{/usr/local/cvsroot} in this example.
@end itemize

Accounting for these differences at your site, the following is an
example procedure for importing a CVS repository ``from scratch'', and
checking the resulting head version of the import out into a working
copy:

@example
$ monotone --db=test.db db init
$ monotone --db=test.db genkey import@@test.net
$ monotone --db=test.db --branch=net.test.wobbler cvs_import /usr/local/cvsroot
$ monotone --db=test.db --branch=net.test.wobbler checkout wobber-checkout
@end example


@node    CVS Phrasebook
@chapter CVS Phrasebook

This chapter translates common CVS commands into monotone commands. It
is an easy alternative to reading through the complete command
reference.

@heading Checking Out a Tree

@multitable @columnfractions .4 .4
@item
@example
$ cvs checkout -d :pserver:cvs.foo.com/wobbler -r 1.2
@end example
@tab
@example
$ monotone fetch http://www.foo.com/depot.cgi/wobbler
$ monotone checkout fe37 wobbler-checkout
@end example
@end multitable

The CVS command contacts a network server, retrieves a version, and
stores it in your working copy. There are two cosmetic differences
with the monotone command: network servers are denoted by URLs and
versions are denoted by @sc{sha1} values (or unambiguous prefixes
thereof).

There is also one deep difference: fetching versions into your
database is a separate step from checking out a single version; after
you have fetched from a network server, your database will contain
@emph{several} versions, possibly the entire history of a
project. Checking out is a separate step, after communication, which
only copies a particular version out of your database and into a named
directory.

@heading Committing Changes

@multitable @columnfractions .4 .4
@item
@example
$ cvs commit -m 'log message'
@end example
@tab
@example
$ monotone commit 'log message'
$ monotone post
@end example
@end multitable

As with other networking commands, the communication step with
monotone is explicit: committing changes only queues them for
transmission. A separate command, @command{post}, sends the changes to
their destinations on network servers.

@heading Incorporating New Changes

@multitable @columnfractions .4 .4
@item
@example
$ cvs update -d
@end example
@tab
@example
$ monotone fetch
$ monotone merge
$ monotone update
@end example
@end multitable

This command, like other networking commands, involves a separate
communication step with monotone. The extra command, @command{merge},
ensures that the branch your are working on has a unique head. You can
omit the @command{merge} step if you only want @command{update} to
examine descendants of your base version, and ignore other heads on
your branch.


@heading Viewing Differences

@multitable @columnfractions .4 .4
@item
@example
$ cvs diff
@end example
@tab
@example
$ monotone diff
@end example
@item
@example
$ cvs diff -r 1.2 -r 1.4
@end example
@tab
@example
$ monotone diff 3e7db 278df
@end example
@end multitable

Monotone's @command{diff} command is modeled on that of CVS, so the
main features are the same: @command{diff} alone prints the
differences between your working copy and its base version, whereas
@command{diff} accompanied by two version numbers prints the
difference between those two versions. The major difference between
CVS and monotone here is that monotone's version numbers are
@emph{manifest versions}, so the @command{diff} command prints the
difference between the two entire trees.

@heading Showing Working Copy Status

@multitable @columnfractions .4 .4
@item
@example
$ cvs status
@end example
@tab
@example
$ monotone status
@end example
@end multitable

This command operates similarly in monotone and CVS. The only major
difference is that monotone's @command{status} command always gives a
status of the whole tree, and outputs a more compact summary than CVS.

@heading Adding Directories and Files to Working Copy

@multitable @columnfractions .4 .4
@item
@example
$ cvs add dir
$ cvs add dir/subdir
$ cvs add dir/subdir/file.txt
@end example
@tab
@example
$ monotone add dir/subdir/file.txt
@end example
@end multitable

Monotone does not explicitly store directories, so adding a file only
involves adding the file's complete path, including any directories.
Directories are created as needed, and empty directories are ignored.


@heading Removing Directories and Files from Working Copy

@multitable @columnfractions .4 .4
@item
@example
$ rm file.txt
$ cvs remove file.txt
@end example
@tab
@example
$ monotone drop file.txt
@end example
@end multitable

Monotone does not require that you erase a file from the working copy
before you drop it. Dropping a file merely removes its entry in the
manifest.


@heading Initializing a Repository

@multitable @columnfractions .4 .4
@item
@example
$ cvs init -d /path/to/repository
@end example
@tab
@example
$ monotone db init --db=/path/to/database.db 
@end example
@end multitable

Monotone's ``repository'' is a single-file database, which is created
and initialized by this command. This file is only ever used by you,
and does not need to be in any special location, or readable by other
users.


@node    Command Reference
@chapter Command Reference

Monotone has a large number of commands. To help navigate through them
all, commands are grouped into logical categories.

@menu
* Tree::             Operations on tree states in your database
* Working Copy::     Operations on your working copy
* Network::          Communication with the network
* Informative::      Production of descriptive reports
* Key and Cert::     General operations on keys or certificates
* Certificate::      Special operations on certificates
* Packet I/O::       Production or consumption of packets
* Database::         Manipulation of your database as a whole
* RCS::              Importing legacy version control files
* Debug::            Debugging interface to monotone
@end menu


@node    Tree
@section Tree

@ftable @command
@item monotone cat file @var{id}
@itemx monotone cat manifest @var{id}

These commands write the contents of a specific file or manifest
version @var{id} to standard output. They are useful if you wish to
inspect a version without checking it out into your working copy.

@item monotone checkout @var{id} @var{directory}
@itemx monotone co @var{id} @var{directory}
@itemx monotone --branch=@var{branchname} checkout @var{directory}
@itemx monotone --branch=@var{branchname} co @var{directory}

These commands copy a manifest version @var{id} out of your database
and into @file{@var{directory}/MT/manifest}. Then they copies every
file version listed in the manifest to paths under
@var{directory}. For example, if the manifest contains these entries:

@example
84e2c30a2571bd627918deee1e6613d34e64a29e  Makefile
c61af2e67eb9b81e46357bb3c409a9a53a7cdfc6  include/hello.h
97dfc6fd4f486df95868d85b4b81197014ae2a84  src/hello.c
@end example

Then the following files are created:
@example
@var{directory}/Makefile
@var{directory}/include/hello.h
@var{directory}/src/hello.c
@end example

If you wish to @command{checkout} in the current directory, you can
supply the special name @file{.} (a single period) for
@var{directory}.

If no @var{id} is provided, as in the latter two commands, you
@emph{must} provide a @var{branchname}; monotone will attempt to infer
@var{id} as the unique head of @var{branchname} if it exists.


@item monotone heads --branch=@var{branchname}
This command lists the ``heads'' of @var{branchname}. 

The ``heads'' of a branch is the set of manifests which are members of
the branch, but which have no descendants. These manifests are
generally the ``newest'' versions committed by you or your colleagues,
at least in terms of ancestry. The heads of a branch may not be the
newest versions, in terms of time, but synchronization of time is not
reliable, so monotone usually ignores time.


@item monotone merge --branch=@var{branchname}
This command merges the ``heads'' of @var{branchname}, if there are
multiple heads, and commits the results to the database, marking the
resulting manifest as a member of @var{branchname} and connecting it
via ancestry certificates to each of its inputs. The command may also
queue the results for posting, depending on configuration.

Merging is performed by repeated pairwise merges: two heads are
selected, then their least common ancestor is located in the ancestry
graph and these 3 manifests are provided to the built-in 3-way merge
algorithm. The process then repeats for each additional head, using
the result of each previous merge as an input to the next.
@end ftable


@ftable @command
@item monotone propagate @var{sourcebranch} @var{destbranch}
This command takes a unique head from @var{sourcebranch} and merges it
with a unique head of @var{destbranch}, using the least common
ancestor of the two heads for a 3-way merge. The resulting manifest is
committed to @var{destbranch}, and possibly queued for posting. If
either @var{sourcebranch} or @var{destbranch} has multiple heads,
@command{propagate} aborts, doing nothing.

The purpose of @command{propagate} is to copy all the changes on
@var{sourcebranch}, since the last @command{propagate}, to
@var{destbranch}. This command supports the idea of making separate
branches for medium-length development activities, such as
maintenance branches for stable software releases, trivial bug fix
branches, public contribution branches, or branches devoted to the
development of a single module within a larger project.
@end ftable



@node    Working Copy
@section Working Copy

@ftable @command
@item monotone add @var{filename...}
This command places ``add'' entries for the paths specified in
@var{filename...} in the working copy's ``work list''. The work list
of your working copy is located at @file{MT/work}, and is a list of
explicit pathname changes you wish to commit at some future time, such
as addition and removal of files.

While this command places an ``add'' entry on your work list, it does
not affect your database. When you @command{commit} your working copy,
the added files on your work list will be copied into your database
and their paths and @sc{sha1} values added to your working copy manifest.


@item monotone drop @var{filename...}
This command places ``drop'' entries for the paths specified in
@var{filename...} in the working copy's ``work list''. The work list
of your working copy is located at @file{MT/work}, and is a list of
explicit pathname changes you wish to commit at some future time, such
as addition and removal of files.

While this command places an ``drop'' entry on your work list, it does
not affect your database. When you @command{commit} your working copy,
the dropped files on your work list will have their entries removed
from your working copy's manifest. 

@item monotone rename @var{src} @var{dst}
This command renames paths in your manifest from @var{src} to
@var{dst}.  If @var{src} is a file, it is renamed to @var{dst}.  If
@var{src} is a directory, all files found in @var{src} have the
@var{src} component of their pathname replaced with @var{dst}.

You should run @command{monotone rename} @emph{before} you rename a
file or directory in your source tree. Monotone will complain if it
cannot find the source of a rename.

@item monotone commit
@itemx monotone commit @var{logmsg}
This command looks at your working copy, decides which files have
changed, and saves the changes to your database. It does this by
calculating the difference between your @file{MT/manifest} file and
the files in your tree, subject to the additions and deletions in your
@file{MT/work} file.

Once the changes are recorded in you database, @command{commit}
overwrites the @file{MT/manifest} file with the changed manifest, and
deletes the @file{MT/work} file. Depending on your configuration,
@command{commit} will also queue the changes for posting to a network
server.

The @command{commit} command also synthesizes a number of
certificates, which it attaches to the new manifest version and copies
into your database:
@itemize
@item
An @code{ancestor} cert, connecting the new version to its base
version in the ancestry graph.
@item 
An @code{author} cert, indicating the person responsible for the changes
leading to the new version.
@item
A @code{date} cert, indicating when the new version was created.
@item
A @code{changelog} cert, containing the ``log message'' for these
changes.  If you provided @var{logmsg} on the command line, this text
will be used, otherwise @command{commit} will run the Lua hook
@code{edit_comment (@var{commentary})}, which typically invokes an
external editor program, in which you can compose a log message for
the change.
@end itemize


@item monotone revert
This command changes your working copy, so that changes you have made
since the last checkout or update are discarded. It does this by
changing every file listed in @file{MT/manifest} to have contents
equal to the @sc{sha1} value listed in the manifest, and by erasing the
@file{MT/work} file.


@item monotone update
This command incorporates ``recent'' changes found in your database
into your working copy. It does this by performing 3 separate
stages. If any of these stages fails, the update aborts, doing
nothing. The stages are:

@itemize
@item
Examine the graph of ancestry certificates in your database, and
(subject to trust evaluation and disapproval certs) select the set of
all descendents of your working copy's base manifest. Call this set
the ``candidates'' of the update.
@item
Remove any candidates which lack acceptable testresult
certificates. From the remaining candidates, select the deepest child
by ancestry and call it the ``target'' of the update.
@item 
Merge the target of the update with the working copy, in memory, and
if the merge is successful, write the result over top of the working
copy.
@end itemize
@end ftable



@node    Network
@section Network

@ftable @command
@item monotone netsync client readonly @var{address} @var{collection}
@itemx monotone netsync client readwrite @var{address} @var{collection}
@itemx monotone netsync client writeonly @var{address} @var{collection}
@itemx monotone netsync server readonly @var{address} @var{collection}
@itemx monotone netsync server readwrite @var{address} @var{collection}
@itemx monotone netsync server writeonly @var{address} @var{collection}

These commands operate the ``netsync'' protocol built into
monotone. This is an experimental, custom protocol for rapidly
synchronizing two monotone databases using a hash tree index. The
protocol is ``peer to peer'', but requires one peer to listen for
incoming connections (the server) and the other peer (the client) to
connect to the server. The @code{readonly}, @code{writeonly}, or
@code{readwrite} parameters indicate what sort of @emph{database
access} the netsync operation should have. For example, in
@code{readonly} mode the netsync operation will @emph{not} add entries
your local database from the network.

The network @var{address} specified in each case should be the same: a
host name to listen on, or connect to, optionally followed by a colon
and a port number. The @var{collection} parameter indicates a set of
branches to exchange; every branch for which @var{collection} is a
prefix will be indexed and made available for synchronization.

For example, supposing bob and alice wish to synchronize their
@code{net.venge.monotone.win32} and @code{net.venge.monotone.i18n}
branches. Supposing alice's computer has hostname
@code{alice.someisp.com}, then alice might run:

@example
$ monotone netsync server readwrite alice.someisp.com net.venge.monotone
@end example

And bob might run

@example
$ monotone netsync client readwrite alice.someisp.com net.venge.monotone
@end example

When the operation completes, all branches beginning with
@code{net.venge.monotone} will be synchronized between alice and bob's
databases.

@item monotone serve @var{address} @var{collection}
@itemx monotone pull @var{address} @var{collection}
@itemx monotone push @var{address} @var{collection}
@itemx monotone sync @var{address} @var{collection}

These commands are aliases for @code{netsync} commands. The
@code{serve} command is an alias for @code{netsync server
readwrite}. The @code{pull} command is an alias for @code{netsync
client writeonly}. The @code{push} command is an alias for
@code{netsync client readonly}. The @code{sync} command is an alias
for @code{netsync client readwrite}. See the @code{netsync} command
for more details.

@item monotone fetch
@itemx monotone fetch @var{url} 

These commands fetch packets from network servers. If you provide a
particular @var{url}, monotone will fetch packets from that specific
network server; otherwise monotone calls the hook
@code{get_fetch_sources (@var{branchname})}, where @var{branchname} is
the current branch, and fetches from all sources returned from that
hook.  Finally, if no hook is found, monotone fetches from all sources
it has listed in its database.

When packets are received, monotone attempts to apply them to the
database. If any packets are bad or rejected for semantic reasons,
monotone will print a warning.

@item monotone post
@itemx monotone post @var{url} 

This command attempts to post packets in the outgoing packet queue to
their respective network servers. If a @var{url} is supplied, monotone
posts only those packets queued for @var{url}. If no @var{url} is
given, monotone posts @emph{all} queued packets. 

Monotone calls the hook @code{get_http_auth (@var{url})} for any
@code{http} URLs, @code{get_news_sender (@var{url})} for any
@code{nntp} URLs, and @code{get_mail_sender (@var{url})} for any
@code{mailto} URLs. See the documentation of these hooks for more
detail.

@item monotone queue list

This command lists the contents of the outgoing network queue. This
queue lists an entry for each URL, called a @dfn{target}.  For each
target, it then lists all the packets queued to send to that
target. Each target and packet is given a number, which can be used in
other @code{monotone queue} commands such as @code{monotone queue
delete} or @code{monotone queue print}.

Note that any commands which alter the queue will invalidate target
and packet numbers.

@item monotone queue delete @var{target} @var{packet}

This command deletes the packet denoted by the numbers @var{target}
and @var{packet} from the outgoing network queue. The @var{target} and
@var{packet} numbers should correspond to a single queue entry listed
by @code{monotone queue list}.

Note that any commands which alter the queue will invalidate target
and packet numbers.

@item monotone queue print @var{target} @var{packet}

This command prints the packet denoted by the numbers @var{target}
and @var{packet}, in the outgoing network queue. The @var{target} and
@var{packet} numbers should correspond to a single queue entry listed
by @code{monotone queue list}.

Note that any commands which alter the queue will invalidate target
and packet numbers.

@item monotone queue add @var{url}

This command reads data from standard input, and adds it to the
outgoing network queue. The data is queued for transmission to the
target denoted by @var{url}.

Note that any commands which alter the queue will invalidate target
and packet numbers.

@item monotone --branch=@var{branchname} queue addtree @var{url}
@itemx monotone queue addtree @var{url} @var{id} @var{...}

This command queues the complete ancestry graph between @var{id} and
its greatest known ancestor. This is typically used to queue an
imported CVS tree for transmission to a depot.

If no @var{id} is provided, this command will queue the heads of the
@var{branchname}, which you must provide instead.

@end ftable



@node    Informative
@section Informative

@ftable @command
@item monotone status

This command prints a description of the ``status'' of your working copy.
In particular, it prints:
@itemize
@item 
The ``base manifest version'', which is the version of the manifest in @file{MT/manifest},
which your working copy is an in-progress descendant of.
@item
The ``current manifest version'', which is the version of the manifest
which results from applying @file{MT/work} to @file{MT/manifest}, and
updating any @sc{sha1} values of files to reflect changes you have
made to the working copy. In other words, the current manifest version
is the version you would commit, if you ran @command{monotone commit}.
@item
A list of logical changes between the base and current manifest
versions, such as adds, drops, renames, and patches.
@end itemize

@item monotone log
@itemx monotone log @var{id}

This command prints out a log, in reverse-ancestry order, of small
history summaries.  Each summary contains author, date, changelog and
comment information associated with a manifest, as well as any file
comments associated with file versions in that manifest. If @var{id}
is given, the command starts tracing back through history from the
manifest @var{id}, otherwise it starts from the manifest which is the
base version of your working copy.

@item monotone complete file @var{partial-id}
@itemx monotone complete manifest @var{partial-id}

These commands print out all known completions of a partial @sc{sha1}
value, listing completions which are @code{file} or @code{manifest}
versions depending on which variant is used. For example, suppose you
enter this command and get this result:

@example
$ monotone complete manifest fa36
fa36deead87811b0e15208da2853c39d2f6ebe90
fa36b76dd0139177b28b379fe1d56b22342e5306
fa36965ec190bee14c5afcac235f1b8e2239bb2a
@end example

Then monotone is telling you that there are 3 manifests it knows
about, in its database, which begin with the 4 hex digits
@code{fa36}. This command is intended to be used by programmable
completion systems, such as those in @command{bash} and @command{zsh}.

@item monotone diff 
@itemx monotone diff @var{id}
@itemx monotone diff @var{id1} @var{id2}

These commands print out GNU ``unified diff format'' textual
difference listings between various manifest versions. If no extra
arguments are given, @command{monotone diff} will print the
differences between the base manifest version and the current manifest
version in your working copy. If one argument @var{id} is given,
monotone will print the differences between the manifest @var{id} and
the current manifest version in your working copy. If two arguments
@var{id1} and @var{id2} are given, monotone will print the differences
between manifests @var{id1} and @var{id2}, ignoring your working copy.

In all cases, monotone will print a textual summary -- identical to
the summary presented by @command{monotone status} -- of the logical
differences between manifests in lines proceeding the diff. These
lines begin with a single hash mark @code{#}, and should be ignored by
a program processing the diff, such as @command{patch}.

@item monotone list certs file @var{id}
@itemx monotone list certs manifest @var{id}

These commands will print out a list of certificates associated with
a particular file or manifest @var{id}. Each line of the print out will
indicate:
@itemize
@item
Whether the signature on the certificate is @code{ok} or @code{bad}
@item
The key ID of the signer of the certificate
@item 
The name of the certificate
@item 
The value of the certificate
@end itemize

For example, this command lists the certificates associated with a
particular version of monotone itself, in the monotone development
branch:

@example
$ ./monotone list certs manifest 4a96
monotone: expanded partial id '4a96' to '4a96a230293456baa9c6e7167cafb3c5b52a8e7f'
ok sig from [graydon@@pobox.com] : [ancestor] = [680e439ea20199f76c1aca1dcac5455b445fc965]
ok sig from [graydon@@pobox.com] : [author] = [graydon@@dub.venge.net]
ok sig from [graydon@@pobox.com] : [branch] = [monotone]
ok sig from [graydon@@pobox.com] : [changelog] = [2003-10-16  graydon hoare  <graydon@@pobox.com>
                                                 
                                                        * sanity.hh: Add a const version of idx().
                                                        * diff_patch.cc: Change to using idx() everywhere.
                                                        * cert.cc (find_common_ancestor): Rewrite to recursive
                                                        form, stepping over historic merges.
                                                        * tests/t_cross.at: New test for merging merges.
                                                        * testsuite.at: Call t_cross.at.
                                                 ]
ok sig from [graydon@@pobox.com] : [date] = [2003-10-17T03:20:27]
@end example

@item monotone list keys
@itemx monotone list keys @var{pattern}
These commands list @sc{rsa} keys held in your current database. They
do not print out any cryptographic information; they simply list the
names of public and private keys you have on hand.

If @var{pattern} is provided, it is used as a glob to limit the keys
listed. Otherwise all keys in your database are listed.

@item monotone list queue

This command lists the contents of the outgoing network queue. It is a
synonym for @command{monotone queue list}.

@item monotone list branches

This command lists all known branches in your database.

@item monotone list unknown

This command lists all files in your working copy that monotone is 
either ignoring or knows nothing about.

@item monotone list ignored

This command lists all files in your working copy that monotone is 
intentionally ignoring, due to the results of the @code{ignore_file (@var{filename})} hook.

@end ftable



@node    Key and Cert
@section Key and Cert

@ftable @command
@item monotone genkey @var{keyid}

This command generates an @sc{rsa} public/private key pair, using a
system random number generator, and stores it in your database under
the key name @var{keyid}. If the the hook
@code{non_blocking_rng_ok()} returns @code{true}, the key
generation will use an unlimited random number generator (such as
@file{/dev/urandom}), otherwise it will use a higher quality random
number generator (such as @file{/dev/random}) but might run slightly
slower.

The private half of the key is stored in an encrypted form, using the
symmetric cipher @sc{arc4}, so that anyone accidentally reading your
database cannot extract your private key and use it. You must provide
a passphrase for your key when it is generated, which is used to key
the @sc{arc4} cipher. In the future you will need to enter this
passphrase again each time you sign a certificate, which happens every
time you @command{commit} to your database. You can tell monotone to
automatically use a certain passphrase for a given key using the
@code{get_passphrase(@var{keypair_id})}, but this significantly
increases the risk of a key compromise on your local computer. Be
careful using this hook.

@item monotone cert file @var{id} @var{certname} 
@itemx monotone cert file @var{id} @var{certname} @var{certval}
@itemx monotone cert manifest @var{id} @var{certname} 
@itemx monotone cert manifest @var{id} @var{certname} @var{certval}

These commands create a new certificate with name @var{certname},
either for a @code{file} or a @code{manifest} with version
@var{id}. If @var{certval} is provided, it is the value of the
certificate.  Otherwise the certificate value is read from
@code{stdin}.

@item monotone --branch=@var{branchname} vcheck create 
@item monotone vcheck create @var{id}
@item monotone --branch=@var{branchname} vcheck check
@item monotone vcheck check @var{id}

These commands produce or check @code{vcheck} certs for the given
manifest @var{id}. A @code{vcheck} cert on a manifest simply reduces
the probability that you and your colleague have different manifests
or files with the same (colliding) @sc{sha1} value. You can produce as
many @code{vcheck} certs as you like.

If you omit the @var{id}, these commands operate on the heads of
@var{branchname}, which you must provide.

@end ftable



@node    Certificate
@section Certificate

@ftable @command
@item monotone approve file @var{id1} @var{id2}
@itemx monotone approve manifest @var{id1} @var{id2}

These commands are synonyms for
@code{monotone cert file @var{id2} ancestor @var{id1}} or 
@code{monotone cert manifest @var{id2} ancestor @var{id1}}

@item monotone disapprove file @var{id1} @var{id2}
@itemx monotone disapprove manifest @var{id1} @var{id2}

These commands are synonyms for
@code{monotone cert file @var{id2} disapproval @var{id1}} or 
@code{monotone cert manifest @var{id2} disapproval @var{id1}}


@item monotone comment file @var{id}
@itemx monotone comment file @var{id} @var{comment}
@itemx monotone comment manifest @var{id}
@itemx monotone comment manifest @var{id} @var{comment}

These commands are synonyms for @code{monotone cert file @var{id}
comment @var{comment}} or @code{monotone cert manifest @var{id}
comment @var{comment}}. If @var{comment} is not provided, it is read
from @code{stdin}.


@item monotone tag @var{id} @var{tagname}

This command is a synonyms for @code{monotone cert manifest @var{id}
tag @var{tagname}}. 

@item monotone testresult @var{id} 0
@item monotone testresult @var{id} 1

These commands are synonyms for @code{monotone cert manifest @var{id}
testresult 0} or @code{monotone cert manifest @var{id} testresult 1}.

@end ftable



@node    Packet I/O
@section Packet I/O

@ftable @command
@item monotone fcerts @var{id}
@itemx monotone mcerts @var{id}

These commands print out an @code{fcert} or @code{mcert} packet for
each file or manifest cert in your database associated with @var{id}.
These can be used to transport certificates safely between monotone
databases.

@item monotone fdata @var{id}
@itemx monotone mdata @var{id}

These commands print out an @code{fdata} or @code{mdata} packet for
the file or manifest @var{id} in your database.  These can be used to
transport file or manifest versions, in their entirety, safely between
monotone databases.


@item monotone fdelta @var{id1} @var{id2}
@itemx monotone mdelta @var{id1} @var{id2}

These commands print out an @code{fdelta} or @code{mdelta} packet for
the differences between file or manifest versions @var{id1} and
@var{id2}, in your database.  These can be used to transport file or
manifest differences safely between monotone databases.

@item monotone privkey @var{keyid}
@itemx monotone pubkey @var{keyid}

These commands print out an @code{privkey} or @code{pubkey} packet for
the @sc{rsa} key @var{keyid}. These can be used to transport public or
private keys safely between monotone databases.


@item monotone read

This command reads packets from @code{stdin} and applies them to your
database. Unlike fetching from a network, it will also insert public
and private keys. Be careful which keys you accept.

@end ftable


@node    Database
@section Database

@ftable @command
@item monotone db init --db=@var{dbfile} 

This command initializes a new monotone database at @file{dbfile}.

@item monotone db info --db=@var{dbfile} 

This command prints information about the monotone database @file{dbfile},
including its schema version and various table size statistics.

@item monotone db version --db=@var{dbfile} 

This command prints out just the schema version of the monotone
database @file{dbfile}.

@item monotone db dump --db=@var{dbfile} 

This command dumps an SQL statement representing the entire state of
@file{dbfile} to the standard output stream. It is a very low-level
command, and produces the most ``recoverable'' dumps of your database
possible. It is sometimes also useful when migrating databases between
variants of the underlying sqlite database format.

@item monotone db load --db=@var{dbfile} 

This command applies a raw SQL statement, read from the standard input
stream, to the database @file{dbfile}. It is most useful when loading
a database dumped with the @command{dump} command.

Note that when reloading a dumped database, the schema of the dumped
database is @emph{included} in the dump, so you should not try to
@command{init} your database before a @command{load}.

@item monotone db migrate --db=@var{dbfile} 

This command attempts to migrate the database @file{dbfile} to the
newest schema known by the version of monotone you are currently
running.  If the migration fails, no changes should be made to the
database.

If you have important information in your database, you should back up
a copy of it before migrating, in case there is an untrapped error
during migration.

@end ftable


@node    RCS
@section RCS

@ftable @command
@item monotone rcs_import @var{filename...}

This command imports all the file versions in each RCS file listed in
@var{filename...}.  These files should be raw RCS files, ending in
@code{,v}. Monotone parses them directly and inserts them into your
database.

@item monotone cvs_import @var{pathname...}

This command imports all the file versions in each RCS file found in
the tree of files starting at @var{pathname...}, then reconstructs the
tree-wide history of logical changes by comparing RCS time stamps and
change log entries. For each logical tree-wide change, monotone
synthesizes a manifest change and commits that manifest and all
associated file versions to your database. It also copies all
change log entries, author identifiers, and date stamps to manifest
certificates.  
@end ftable


@node    Debug
@section Debug

@ftable @command
@item monotone debug @var{sql-statement}

This is a debugging command which executes @var{sql-statement} against
your database, and prints any results of the expression in a tabular
form.  It can be used to investigate the state of your database, or
help diagnose failures.
@end ftable





@node    Hook Reference
@chapter Hook Reference

Monotone's behavior can be customized and extended by writing
@dfn{hook functions}, which are written in the
@uref{http://www.lua.org, Lua} programming language. At certain points
in time, when monotone is running, it will call a hook function to
help it make a decision or perform some action.  If you provide a hook
function definition which suits your preferences, monotone will
execute it. This way you can modify how monotone behaves.

You can put new definitions for any of these hook functions in a file
@file{$HOME/.monotonerc}, or in your working copy in
@file{MT/monotonerc}, both of which will be read every time monotone
runs. Definitions in @file{MT/monotonerc} shadow (override)
definitions made in your @file{$HOME/.monotonerc}. You can also tell
monotone to interpret extra hook functions from any other @var{file}
using the @option{--rcfile=@var{file}} option; hooks defined in files
specified on the command-line will shadow hooks from the the automatic
files.

The remainder of this section documents the existing hook functions
and their default definitions. 

@ftable @code
@item get_branch_key (@var{branchname})

Returns a string which is the name of an @sc{rsa} private key used to sign
certificates in a particular branch @var{branchname}. There is no
default definition for this hook. The command-line option
@option{--key=@var{keyname}} overrides any value returned from this
hook function. If you have only one private key in your database, you
do not need to define this function or provide a
@option{--key=@var{keyname}} option; monotone will guess that you want
to use the unique private key.

@item get_passphrase (@var{keypair_id})

Returns a string which is the passphrase used to encrypt the private
half of @var{keypair_id} in your database, using the @sc{arc4}
symmetric cipher. This hook has no default definition. If this hook is not
defined, monotone will prompt you for a passphrase each time it needs
to use a private key.

@item get_author (@var{branchname})

Returns a string which is used as a value for automatically generated 
@code{author} certificates when you commit changes to @var{branchname}.

The default definition of this hook looks is:
@example
function get_author(branchname)
        local user = os.getenv("USER")
        local host = os.getenv("HOSTNAME")
        if ((user == nil) or (host == nil)) then return nil end
        return string.format("%s@@%s", user, host)
end
@end example

@item edit_comment (@var{commentary})

Returns a log entry for a given set of changes, described in
@var{commentary}.  The commentary is identical to the output of
@command{monotone status}. This hook is intended to interface with
some sort of editor, so that you can interactively document each
change you make. The result is used as the value for a
@code{changelog} certificate, automatically generated when you commit
changes.

The default definition of this hook is:

@example
function edit_comment(commentary)
        local exe = "vi"
        local visual = os.getenv("VISUAL")
        if (visual ~= nil) then exe = visual end
        local editor = os.getenv("EDITOR")
        if (editor ~= nil) then exe = editor end

        local tmp, tname = temp_file()
        if (tmp == nil) then return nil end
        commentary = "MT: " .. string.gsub(commentary, "\n", "\nMT: ")
        tmp:write(commentary)
        io.close(tmp)

        if (os.execute(string.format("%s %s", exe, tname)) ~= 0) then
                os.remove(tname)
                return nil
        end

        tmp = io.open(tname, "r")
        if (tmp == nil) then os.remove(tname); return nil end
        local res = ""
        local line = tmp:read()
        while(line ~= nil) do 
                if (not string.find(line, "^MT:")) then
                        res = res .. line .. "\n"
                end
                line = tmp:read()
        end
        io.close(tmp)
        os.remove(tname)
        return res
end
@end example

@item persist_phrase_ok ()

Returns @code{true} if you want monotone to remember the passphrase of
a private key for the duration of a single command, or @code{false} if
you want monotone to prompt you for a passphrase for each certificate
it generates. Since monotone often generates several certificates in 
quick succession, unless you are very concerned about security you
probably want this hook to return @code{true}.

The default definition of this hook is:
@example
function persist_phrase_ok()
        return true
end
@end example

@item non_blocking_rng_ok ()

Returns @code{true} if you are willing to let monotone use the
system's non-blocking random number generator, such as
@file{/dev/urandom}, for generating random values during cryptographic
operations. This diminishes the cryptographic strength of such
operations, but speeds them up. Returns @code{false} if you want to
force monotone to always use higher quality random numbers, such as
those from @file{/dev/random}.

The default definition of this hook is:
@example
function non_blocking_rng_ok()
        return true
end
@end example


@item get_netsync_read_permitted (@var{collection}, @var{identity})

Returns @code{true} if a peer authenticated as key @var{identity}
should be allowed to read from your database certs, manifests, and
files associated with the netsync index @var{collection}; otherwise
@code{false}. This hook has no default definition, therefore the
default behavior is to deny all reads.

Note that the @var{identity} value is a key id (such as
``@code{graydon@@pobox.com}'') but will correspond to a @emph{unique}
key fingerprint (hash) in your database. Monotone will not permit two
keys in your database to have the same id. Make sure you confirm the
key fingerprints of each key in your database, as key id strings are
``convenience names'', not security tokens.

@item get_netsync_anonymous_read_permitted (@var{collection})

This hook has identical semantics to @code{get_netsync_read_permitted}
except that it is called when a connecting client requests anonymous
read access to a collection. There is no corresponding anonymous write
access hook. This hook has no default definition, therefore the
default behavior is to deny all anonymous reads.

@item get_netsync_write_permitted (@var{collection}, @var{identity})

Returns @code{true} if a peer authenticated as key @var{identity}
should be allowed to write into your database certs, manifests, and
files associated with the netsync index @var{collection}; otherwise
@code{false}. This hook has no default definition, therefore the
default behavior is to deny all writes.

Note that the @var{identity} value is a key id (such as
``@code{graydon@@pobox.com}'') but will correspond to a @emph{unique}
key fingerprint (hash) in your database. Monotone will not permit two
keys in your database to have the same id. Make sure you confirm the
key fingerprints of each key in your database, as key id strings are
``convenience names'', not security tokens.

@item get_news_sender (@var{url})

Returns a string which is the email address (or other identifying
sender address) of a news article, to be used when monotone is posting
news articles to @var{url}. This hook is only called when posting to
@code{nntp} URLs. This hook has no default definition.

@item get_mail_sender (@var{url})

Returns a string which is the email address (or other identifying
sender address) of an email message, to be used when monotone is
posting email messages to @var{url}. This hook is only called when
posting to @code{mailto} URLs. This hook has no default definition.

@item get_mail_hostname (@var{url})

Returns a string which is the host name used to identify ourselves as
in the opening @code{HELO} exchange, when speaking SMTP to an MX
server responsible for the mail destination identified by
@var{url}. This hook is only called when posting to @code{mailto}
URLs.

The default definition of this hook is:
@example
function get_mail_hostname(url)
	return os.getenv("HOSTNAME")
end
@end example

@item get_http_auth (@var{url})

Returns a string which is the name of a private @sc{rsa} key you wish
to use for posting packets to an @code{http} depot. Depots verify
incoming packet streams by examining an @sc{rsa} signature on the
entire transmission, so you need to return the name of a key which you
have also put the public half of in the depot's database. This hook
has no default definition.

@item get_http_proxy (@var{host}, @var{port})

Returns a 2-entry table which contains a string specifying a host, and
an integer specifying a port, used as a proxy to connect to the HTTP
server at @var{host} and @var{port}. 

The default definition of this hook is:

@example
function get_http_proxy(host, port)
	val = os.getenv("HTTP_PROXY")
	if (val == nil) then 
		val = os.getenv("http_proxy") 
	end
	if (val == nil) then 
		return nil
	end
	val = string.gsub(val, "http://", "")
	b, e = string.find(val, ":")
	if (b ~= nil and b > 0) then
		chost = string.sub(val, 0, b-1)
		cport = string.sub(val, b+1)
		return @{ chost, cport @}
	end
	return @{ val, port @}
end
@end example

@item get_connect_addr (@var{proto}, @var{host}, @var{port})

Returns a 2-entry table which contains a string specifying a host, and
an integer specifying a port, used as a ``connection address'' when
sending or receiving packets. Unlike an HTTP proxy, a connection
address has no affect on the protocol parameters after the socket is
opened; it is intended for redirecting connections into local
tunnels. If you want to use an HTTP proxy, you should use the
@code{get_http_proxy} hook.

This hook has no default definition.


@item get_post_targets (@var{branchname})

Returns a table of strings, each of which is a URL for a posting
target you wish to send packets to, when committing to
@var{branchname}. Packets will be queued to send to all targets
returned by this hook.

This hook has no default definition, but it returns a somewhat unusual
structure, so we give an example here. Suppose that when you commit to
a branch called @code{examplebranch} you want to send to the logical group
@code{example} at the depot @code{http://www.myisp.com/~user/depot.cgi},
as well as to the news group @code{com.myisp.example} at the news server
@code{nntp://news.myisp.com}. Then you would write the following hook:

@example
function get_fetch_sources(branch)
        if (branch == "examplebranch") then
                return @{ "http://www.myisp.com/~user/depot.cgi/example",
                         "nntp://news.myisp.com/com.myisp.example"  @}
        end
end
@end example

@item get_fetch_sources (@var{branchname})

Returns a table of strings, each of which is a URL for a fetching
source you wish to retrieve packets from, when you run @code{monotone
fetch} for a particular @var{branchname}. Packets will be fetched from
all sources returned by this hook.

This hook has no default definition, but its operation is analogous to
the @code{get_post_targets (@var{branchname})} hook, described
previously.

@item ignore_file (@var{filename})

Returns @code{true} if @var{filename} should be ignored while adding,
dropping, or moving files. Otherwise returns @code{false}. This is
most important when performing recursive actions on directories, which
may affect multiple files simultaneously. The default definition of
this hook is:

@example
function ignore_file(name)
        if (string.find(name, "%.o$")) then return true end
        if (string.find(name, "%.aux$")) then return true end
        if (string.find(name, "%.bak$")) then return true end
        if (string.find(name, "%.orig$")) then return true end
        if (string.find(name, "%.rej$")) then return true end
        if (string.find(name, "/core$")) then return true end
        if (string.find(name, "^CVS/")) then return true end
        if (string.find(name, "^SVN/")) then return true end
        if (string.find(name, "/CVS/")) then return true end
        if (string.find(name, "/SVN/")) then return true end
        return false
end
@end example

@item get_manifest_cert_trust (@var{signers}, @var{id}, @var{name}, @var{val})

Returns whether or not you @emph{trust} the assertion
@var{name}=@var{value} on a given manifest @var{id}, given a valid
signature from all the keys in @var{signers}. The @var{signers}
parameter is a table containing all the key names which signed this
cert, the other three parameters are strings.

The default definition of this hook simply returns @code{true}, which
corresponds to a form of trust where every key which is defined in
your database is trusted. This is a @emph{weak} trust setting; you
should change it to something stronger. A possible example of a
stronger trust function (along with a utility function for computing
the intersection of tables) is the following:

@example
function intersection(a,b)
   local s=@{@}
   local t=@{@}
   for k,v in pairs(a) do s[v] = 1 end
   for k,v in pairs(b) do if s[v] ~= nil then table.insert(t,v) end end
   return t
end

function get_manifest_cert_trust(signers, id, name, val)
   local trusted_signers = @{ "bob@@happyplace.com", 
                             "friend@@trustedplace.com", 
                             "myself@@home.com" @}
   local t = intersection(signers, trusted_signers)

   if t == nil then return false end

   if    (name ~= "ancestor" and table.getn(t) >= 1)
      or (name == "ancestor" and table.getn(t) >= 2)
   then
      return true
   else
      return false
   end
end
@end example

In this example, any manifest certificate is trusted if it is signed
by at least one of three ``trusted'' keys, unless it is an
@code{ancestor} certificate, in which case it must be signed by
@emph{two} or more trusted keys. This is one way of requiring that
ancestry assertions go through an extra ``reviewer'' before they are
accepted.

@item get_file_cert_trust (@var{signers}, @var{id}, @var{name}, @var{val})

This hook is identical to the hook @code{get_manifest_cert_trust},
except it is called for file certificates rather than manifest
certificates. See the documentation for that hook for more details.

@item accept_testresult_change (@var{old_results}, @var{new_results})

This hook is used by the update algorithm to determine whether a
change in test results between update source and update target is
acceptable. The hook is called with two tables, each of which maps a
signing key -- representing a particular testsuite -- to a boolean
value indicating whether or not the test run was successful. The
function should return @code{true} if you consider an update from the
version carrying the @var{old_results} to the version carrying the
@var{new_results} to be acceptable.

The default definition of this hook follows:

@example
function accept_testresult_change(old_results, new_results)
   for test,res in pairs(old_results)
   do
      if res == true and new_results[test] ~= true
      then
	 return false
      end
   end
   return true
end
@end example

This definition accepts only those updates which preserve the set of
@code{true} test results from update source to target. If no rest
results exist, this hook has no affect; but once a @code{true} test
result is present, future updates will require it. If you want a more
lenient behavior you must redefine this hook.

@item merge2 (@var{left}, @var{right})

Returns a string, which should be the merger of the 2 provided
strings, which are the contents of the @var{left} and @var{right}
nodes of a file fork which monotone was unable to automatically
merge. The merge should either call an intelligent merge program or
interact with the user. The default definition of this hook is:

@example
function merge2(left, right)
   local lfile = nil
   local rfile = nil
   local outfile = nil
   local data = nil

   lfile = write_to_temporary_file(left)
   rfile = write_to_temporary_file(right)
   outfile = write_to_temporary_file("")

   if lfile ~= nil and
      rfile ~= nil and
      outfile ~= nil 
   then 
      local cmd = nil
      if program_exists_in_path("xxdiff") then
	 cmd = merge2_xxdiff_cmd(lfile, rfile, outfile)
      elseif program_exists_in_path("emacs") then
	 cmd = merge2_emacs_cmd(lfile, rfile, outfile)
      end

      if cmd ~= nil
      then
	 io.write(string.format("executing external 2-way merge command: %s\n", cmd))
	 if os.execute(cmd) == 0 
	 then
	    data = read_contents_of_file(outfile)
	 end
      end
   end
   
   os.remove(lfile)
   os.remove(rfile)
   os.remove(outfile)
   
   return data
end
@end example

@item merge3 (@var{ancestor}, @var{left}, @var{right})

Returns a string, which should be the merger of the 3 provided
strings, which are the contents of @var{left} and @var{right} nodes,
and least common @var{ancestor}, of a file fork which monotone was
unable to automatically merge. The merge should either call an
intelligent merge program or interact with the user. The default
definition of this hook is:

@example
function merge3(ancestor, left, right)
   local afile = nil
   local lfile = nil
   local rfile = nil
   local outfile = nil
   local data = nil

   lfile = write_to_temporary_file(left)
   afile = write_to_temporary_file(ancestor)
   rfile = write_to_temporary_file(right)
   outfile = write_to_temporary_file("")

   if lfile ~= nil and
      rfile ~= nil and
      afile ~= nil and
      outfile ~= nil 
   then 
      local cmd = nil
      if program_exists_in_path("xxdiff") then
	 cmd = merge3_xxdiff_cmd(lfile, afile, rfile, outfile)
      elseif program_exists_in_path("emacs") then
	 cmd = merge3_emacs_cmd(lfile, afile, rfile, outfile)
      end

      if cmd ~= nil
      then
	 io.write(string.format("executing external 3-way merge command: %s\n", cmd))
	 if os.execute(cmd) == 0 
	 then
	    data = read_contents_of_file(outfile)
	 end
      end
   end
   
   os.remove(lfile)
   os.remove(rfile)
   os.remove(afile)
   os.remove(outfile)
   
   return data
end
@end example

@item get_system_linesep ()

Returns a string which defines the default system line separator.
This should be one of the strings @code{CR}, @code{LF}, or
@code{CRLF}. The system line separator may be used when reading or
writing data to the terminal, or otherwise interfacing with the user.
The system line separator is not used to convert files in the working
copy; use @code{get_linesep_conv} for converting line endings in the
working copy.

This hook has no default definition. For more information on line
ending conversion, see the section on @ref{Internationalization}.

@item get_linesep_conv (@var{filename})

Returns a table which contains two strings. The first string in the
return value is the name of a line ending convention to use for the
``internal'' representation of @var{filename}. The second string in
the return value is the name of a line ending convention to use for
the ``external'' representation of @var{filename}. Line ending
conventions should be one of the strings @code{CR}, @code{LF}, or
@code{CRLF}. 

When @var{filename} is read from the working copy, it is run through
line ending conversion from the external form to the internal
form. When @var{filename} is written to the working copy, it is run
through line ending conversion from the internal form to the external
form. @sc{sha1} values are calculated from the internal form of
@var{filename}. It is your responsibility to decide which line ending
conversions your work will use.

This hook has no default definition; monotone's default behavior is to
keep external and internal forms byte-for-byte identical. For more
information on line ending conversion, see the section on
@ref{Internationalization}.

@item get_charset_conv (@var{filename})

Returns a table which contains two strings. The first string in the
return value is the name of a character set to use for the
``internal'' representation of @var{filename}. The second string in
the return value is the name of a character set to use for the
``external'' representation of @var{filename}.  

When @var{filename} is read from the working copy, it is run through
character set conversion from the external form to the internal
form. When @var{filename} is written to the working copy, it is run
through character set conversion from the internal form to the
external form. @sc{sha1} values are calculated from the internal
form of @var{filename}. It is your responsibility to decide which
character set conversions your work will use. 

This hook has no default definition; monotone's default behavior is to
keep external and internal forms byte-for-byte identical. For more
information on character set conversion, see the section on
@ref{Internationalization}.


@item attr_functions [@var{arrtibute}] (@var{filename}, @var{value})

This is not a hook function, but a @emph{table} of hook
functions. Each entry in the table @code{attr_functions}, at table
entry @var{attribute}, is a function taking a file name @var{filename}
and a attribute value @var{value}. The function should ``apply'' the 
attribute to the file, possibly in a platform-specific way.

Persistent attributes are stored in the @file{.mt-attrs}, in your
working copy and manifest. If such a file exists, hook functions from
this table are called for each triple found in the file, after any
command which modifies the working copy. This facility can be used to
extend monotone's understanding of files with platform-specific attributes,
such as permission bits, access control lists, or special file types.

By default, there is only one entry in this table, for the @code{execute}
attribute. Its definition is:

@example
attr_functions["execute"] = 
  function(filename, value) 
        if (value == "true") then
                os.execute(string.format("chmod +x %s", filename))
        end
  end
@end example

@end ftable


@node    Man Page
@chapter Man Page
@c DEBUG: print_menu("Top")

@ifnottex
@menu
* NAME::
* SYNOPSIS::
* DESCRIPTION::
* OPTIONS::
* ENVIRONMENT::
* FILES::
* NOTES::
* SEE ALSO::
* BUGS::
* AUTHOR::

@end menu
@end ifnottex


@comment TROFF INPUT: .SH NAME

@node NAME

@section NAME
@c DEBUG: print_menu("NAME")

monotone @minus{} distributed version control system
@comment TROFF INPUT: .SH SYNOPSIS

@node SYNOPSIS

@section SYNOPSIS
@c DEBUG: print_menu("SYNOPSIS")

@ifnottex
@menu
* Note::
* Commands::

@end menu
@end ifnottex


@b{monotone} @i{[options] <command> [parameters]}
@comment TROFF INPUT: .P
@comment .P
Options, which affect global behavior or set default values, come
first in the argument list. A single command must follow, indicating
the operation to perform, followed by parameters which vary depending
on the command.
@comment TROFF INPUT: .SS Note

@node Note

@subsection Note

This man page is a summary of some of the features and commands of
@b{monotone}, but it is not the most detailed source of information
available. For a complete discussion of the concepts and a tutorial on
its use, please refer to the texinfo manual (via the @b{info
monotone} command, or online).
@comment TROFF INPUT: .SS Commands

@node Commands

@subsection Commands

@comment TROFF INPUT: .TP

@c ---------------------------------------------------------------------
@table @code
@item @b{comment} @i{(file|manifest) <id>}
Write a comment cert for a file or manifest version.
@comment TROFF INPUT: .TP

@item @b{approve} @i{(file|manifest) <id1> <id2>}
Make a cert approving of a file or manifest change.
@comment TROFF INPUT: .TP

@item @b{disapprove} @i{(file|manifest) <id1> <id2>}
Make a cert disapproving of a file or manifest change.
@comment TROFF INPUT: .TP

@item @b{tag} @i{<id> <tagname>}
Put a symbolic tag cert on a manifest version.
@comment TROFF INPUT: .TP

@item @b{testresult} @i{<id> (0|1)}
Indicate a passing or failing test result on a manifest version.
@comment TROFF INPUT: .TP

@item @b{agraph}
Dump ancestry graph to stdout.
@comment TROFF INPUT: .TP

@item @b{diff}
Show diffs between working copy and database.
@comment TROFF INPUT: .TP

@item @b{status}
Show status of working copy.
@comment TROFF INPUT: .TP

@item @b{log} @i{[id]}
Show historical log of manifests, starting from working copy
base version, or @i{[id]} if given.
@comment TROFF INPUT: .TP

@item @b{cert} @i{(file|manifest) <id> <certname> [certval]}
Create a custom cert for a file or manifest. Reads cert value
from stdin if no value given on command line.
@comment TROFF INPUT: .TP

@item @b{vcheck} @i{(create|check) [id]}
Produce or check @code{vcheck} certs for the given manifest @i{[id]}.
@comment TROFF INPUT: .TP

@item @b{genkey} @i{<keyid>}
Generate an @sc{rsa} key-pair and store it in the database.
@comment TROFF INPUT: .TP

@item @b{list certs} @i{(file|manifest) <id>}
@itemx @b{ls certs} @i{(file|manifest) <id>}
List certs associated with manifest or file.
@comment TROFF INPUT: .TP

@item @b{list keys} @i{[partial-id]}
@itemx @b{ls keys} @i{[partial-id]}
List keys matching glob, or list all keys if no glob given.
@comment TROFF INPUT: .TP

@item @b{list queue}
@itemx @b{ls queue}
List contents of outgoing network queue.
@comment TROFF INPUT: .TP

@item @b{list branches}
@itemx @b{ls branches}
List all branches.
@comment TROFF INPUT: .TP

@item @b{list unknown}
@itemx @b{ls unknown}
List files in working directory, but not in manifest or work list.
@comment TROFF INPUT: .TP

@item @b{list ignored}
@itemx @b{ls ignored}
List files intentionally ignored due to the ignore_file hook.
@comment TROFF INPUT: .TP

@item @b{fetch} @i{[URL]}
Fetch recent packets from network servers. Does not read public
or private key packets; use the @b{read} command instead.
@comment TROFF INPUT: .TP

@item @b{post} @i{[URL]}
Post queued packets to network servers.
@comment TROFF INPUT: .TP

@item @b{queue list}
List contents of outgoing network queue.
@comment TROFF INPUT: .TP

@item @b{queue print} @i{<target>} @i{<packet>}
Print packet in outgoing network queue.
@comment TROFF INPUT: .TP

@item @b{queue delete} @i{<target>} @i{<packet>}
Delete packet from outgoing network queue
@comment TROFF INPUT: .TP

@item @b{queue add} @i{<url>}
Queue contents of standard input to transmit to @i{<url>} 
@comment TROFF INPUT: .TP

@item @b{queue addtree} @i{<url>} @i{[id]}
Queue history of @i{id} to transmit to @i{<url>} 
@comment TROFF INPUT: .TP

@item @b{fcerts} @i{<id>}
Write file cert packets to stdout.
@comment TROFF INPUT: .TP

@item @b{fdata} @i{<id>}
Write file data packet to stdout.
@comment TROFF INPUT: .TP

@item @b{fdelta} @i{<oldid> <newid>}
Write file delta packet to stdout.
@comment TROFF INPUT: .TP
 
@item @b{mcerts} @i{<id>}
Write manifest cert packets to stdout.
@comment TROFF INPUT: .TP

@item @b{mdata} @i{<id>}
Write manifest data packet to stdout.
@comment TROFF INPUT: .TP

@item @b{privkey} @i{<id>}
Write private key packet to stdout.
@comment TROFF INPUT: .TP

@item @b{pubkey} @i{<id>}
Write public key packet to stdout.
@comment TROFF INPUT: .TP

@item @b{read}
Read packets from stdin. This is the only way of reading cryptographic
key packets; the @b{fetch} command will not read public or private
keys from the network. It is very important to @b{only read keys from
trusted sources}; all other trust relationships are built out of the
trust assigned to keys.
@comment TROFF INPUT: .TP

@item @b{cvs_import} @i{<cvsroot>}
Import all versions in CVS repository. Reconstructs ancestry edges and
converts metadata to certificates. A private signing key must already
exist in the database.
@comment TROFF INPUT: .TP

@item @b{rcs_import} @i{<rcsfile> ...}
Import all versions in RCS files. Does not reconstruct ancestry edges
or convert ancestry edges.
@comment TROFF INPUT: .TP

@item @b{checkout} @i{[manifest-id]} @i{<directory>}
@itemx @b{co} @i{[manifest-id]} @i{<directory>}
Check out tree state from database, into directory.
@comment TROFF INPUT: .TP

@item @b{cat} @i{(file|manifest) <id>}
Write file or manifest from database to stdout.
@comment TROFF INPUT: .TP

@item @b{heads}
Show unmerged heads of branch, or report when branch is merged.
@comment TROFF INPUT: .TP

@item @b{merge}
Merge unmerged heads of branch.
@comment TROFF INPUT: .TP

@item @b{add} @i{<pathname> [...]}
Add files to working copy. adding a file does not copy it into the database,
merely adds it to the manifest. You must @b{commit} your changes in order
to copy added files to the database.
@comment TROFF INPUT: .TP

@item @b{commit} @i{[log message]}
Commit working copy to database. If a log message is provided on the command
line, it is used; otherwise a log message editor will be invoked.
@comment TROFF INPUT: .TP

@item @b{drop} @i{<pathname> [...]}
Drop files from working copy. Files are not deleted from working copy,
merely removed from the manifest.
@comment TROFF INPUT: .TP

@item @b{rename} @i{<src> <dst>}
Rename files from @i{<src>} to @i{<dst>} in working copy.
@comment TROFF INPUT: .TP

@item @b{update} 
Update working copy.
@comment TROFF INPUT: .SH DESCRIPTION

@item @b{db} @i{(init|info|version|dump|load|migrate)}
Manipulate database state.
@comment TROFF INPUT: .SH DESCRIPTION

@end table

@c ---------------------------------------------------------------------

@node DESCRIPTION

@section DESCRIPTION
@c DEBUG: print_menu("DESCRIPTION")

Monotone is a version control system, which allows you to keep old
versions of files, as well as special @i{manifest files} which
describe the location of files in a tree. Unlike other systems,
versions in monotone are @i{identified} by cryptographic hash, and
operations are authenticated by individual users' evaluating
cryptographic signatures on meta-data, rather than any central
authority.

Monotone keeps a collection of versions in a single-file relational
database. It is essentially serverless, using network servers only as
untrusted communication facilities. A monotone database is a regular
file, which contains all the information needed to extract previous
versions of files, verify signatures, merge and modify versions, and
communicate with network servers.
@comment TROFF INPUT: .SH OPTIONS

@node OPTIONS

@section OPTIONS
@c DEBUG: print_menu("OPTIONS")

@comment TROFF INPUT: .TP

@c ---------------------------------------------------------------------
@table @code
@item @b{--help}
Print help message.
@comment TROFF INPUT: .TP

@item @b{--verbose}
Trace execution verbosely. default is to be silent, unless
an error occurs, in which case failure log is dumped.
@comment TROFF INPUT: .TP

@item @b{--nostd}
Do not evaluate "standard" Lua hooks compiled into @b{monotone}.
@comment TROFF INPUT: .TP

@item @b{--norc}
Do not load Lua hooks from user's @b{~/.monotonerc} file.
@comment TROFF INPUT: .TP

@item @b{--rcfile=}@i{<file>}
Load extra Lua hooks from @i{file} (may be given multiple times).
@comment TROFF INPUT: .TP

@item @b{--db=}@i{<file>}
Use database in @i{file}.
@comment TROFF INPUT: .TP

@item @b{--key=}@i{<keyid>}
Use @i{keyid} for operations which produce @sc{rsa}
signatures. Default is inferred from presence of unique private key in
database. Can also be customized on a per-branch basis with hook
function @b{get@t{_}branch@t{_}key(branchname)}.
@comment TROFF INPUT: .TP

@item @b{--branch=}@i{<branchname>}
Use @i{branchname} for operations on a branch. Default is inferred
in operations on existing branches (commit, update, etc). Can also be set
with environment variable @b{MT@t{_}BRANCH}.
@comment TROFF INPUT: .SH ENVIRONMENT

@end table

@c ---------------------------------------------------------------------

@node ENVIRONMENT

@section ENVIRONMENT
@c DEBUG: print_menu("ENVIRONMENT")

@comment TROFF INPUT: .TP

@c ---------------------------------------------------------------------
@table @code

@item @b{EDITOR}
Used to edit comments, log messages, etc.
@comment TROFF INPUT: .TP

@item @b{VISUAL}
Used in preference to @b{EDITOR}, if set.
@comment TROFF INPUT: .SH FILES

@end table

@c ---------------------------------------------------------------------

@node FILES

@section FILES
@c DEBUG: print_menu("FILES")

@comment TROFF INPUT: .TP

@c ---------------------------------------------------------------------
@table @code
@item @b{$HOME/.monotonerc}
A Lua script, used as a customization file.
@comment TROFF INPUT: .SH NOTES

@end table

@c ---------------------------------------------------------------------

@node NOTES

@section NOTES
@c DEBUG: print_menu("NOTES")

@comment TROFF INPUT: .IP \(bu

Command line options override environment variables and
settings in Lua scripts (such as @b{.monotonerc})

@comment TROFF INPUT: .SH "SEE ALSO"

@node SEE ALSO

@section SEE ALSO
@c DEBUG: print_menu("SEE ALSO")

@b{info monotone}
@comment TROFF INPUT: .SH BUGS

@node BUGS

@section BUGS
@c DEBUG: print_menu("BUGS")

see http://savannah.nongnu.org/bugs/?group=monotone
@comment TROFF INPUT: .SH AUTHOR

@node AUTHOR

@section AUTHOR
@c DEBUG: print_menu("AUTHOR")

graydon hoare <graydon@@pobox.com>

@node Index
@unnumbered Index
     
@printindex cp

@bye
